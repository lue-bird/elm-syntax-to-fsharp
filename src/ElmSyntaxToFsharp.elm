module ElmSyntaxToFsharp exposing
    ( modules, fsharpDeclarationsToModuleString
    , FsharpLetDeclaration(..), FsharpExpression(..), FsharpPattern(..), FsharpType(..)
    )

{-| Transpiling [`elm-syntax`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/)
declarations to fsharp (tested to be compatible with .net8.0 and .net9.0).

@docs modules, fsharpDeclarationsToModuleString
@docs FsharpLetDeclaration, FsharpExpression, FsharpPattern, FsharpType

If you need more fine-grained helpers,
[open an issue](https://github.com/lue-bird/elm-syntax-format/issues/new)

-}

import Bitwise
import Data.Graph
import Elm.Syntax.Declaration
import Elm.Syntax.Exposing
import Elm.Syntax.Expression
import Elm.Syntax.File
import Elm.Syntax.Import
import Elm.Syntax.Module
import Elm.Syntax.Node
import Elm.Syntax.Range
import Elm.Syntax.TypeAnnotation
import ElmSyntaxTypeInfer
import FastDict
import FastSet
import Print exposing (Print)
import Unicode


{-| The sub-set of fsharp type syntax used in generated code
-}
type FsharpType
    = FsharpTypeConstruct
        { moduleOrigin : Maybe String
        , name : String
        , arguments : List FsharpType
        }
    | FsharpTypeTuple
        { part0 : FsharpType
        , part1 : FsharpType
        , part2Up : List FsharpType
        }
    | FsharpTypeVariable String
    | FsharpTypeFunction
        { input : FsharpType
        , output : FsharpType
        }


{-| The sub-set of fsharp pattern syntax used in generated code
-}
type FsharpPattern
    = FsharpPatternIgnore
    | FsharpPatternInt Int
    | FsharpPatternChar Char
    | FsharpPatternStringLiteral String
    | FsharpPatternVariable String
    | FsharpPatternAs
        { variable : String
        , pattern : FsharpPattern
        }
    | FsharpPatternListCons
        { head : FsharpPattern
        , tail : FsharpPattern
        }
    | FsharpPatternListExact (List FsharpPattern)
    | FsharpPatternRecordInexhaustive (FastDict.Dict String FsharpPattern)
    | FsharpPatternVariant
        { moduleOrigin : Maybe String
        , name : String
        , values : List FsharpPattern
        }
    | FsharpPatternTuple
        { part0 : FsharpPattern
        , part1 : FsharpPattern
        , part2Up : List FsharpPattern
        }


{-| The sub-set of fsharp expression syntax used in generated code
-}
type FsharpExpression
    = FsharpExpressionUnit
    | FsharpExpressionFloat Float
    | FsharpExpressionInt64 Int
    | FsharpExpressionChar Char
    | FsharpExpressionStringLiteral String
    | FsharpExpressionReference
        { moduleOrigin : Maybe String
        , name : String
        }
    | FsharpExpressionRecordAccess
        { record : FsharpExpression
        , field : String
        }
    | FsharpExpressionTuple
        { part0 : FsharpExpression
        , part1 : FsharpExpression
        , part2Up : List FsharpExpression
        }
    | FsharpExpressionIfElse
        { condition : FsharpExpression
        , onTrue : FsharpExpression
        , onFalse : FsharpExpression
        }
    | FsharpExpressionListLiteral (List FsharpExpression)
    | FsharpExpressionArrayLiteral (List FsharpExpression)
    | FsharpExpressionRecord (FastDict.Dict String FsharpExpression)
    | FsharpExpressionRecordUpdate
        { originalRecordVariable : String
        , fields : FastDict.Dict String FsharpExpression
        }
    | FsharpExpressionCall
        { called : FsharpExpression
        , arguments : List FsharpExpression
        }
    | FsharpExpressionLambda
        { parameters : List { pattern : FsharpPattern, type_ : FsharpType }
        , result : FsharpExpression
        }
    | FsharpExpressionMatchWith
        { matched : FsharpExpression
        , case0 :
            { pattern : FsharpPattern
            , patternType : FsharpType
            , result : FsharpExpression
            }
        , case1Up :
            List
                { pattern : FsharpPattern
                , patternType : FsharpType
                , result : FsharpExpression
                }
        }
    | FsharpExpressionWithLetDeclarations
        { declaration0 : FsharpLetDeclaration
        , declaration1Up : List FsharpLetDeclaration
        , result : FsharpExpression
        }


{-| The sub-set of fsharp local declaration syntax used in generated fsharp code
-}
type FsharpLetDeclaration
    = FsharpLetDestructuring
        { pattern : FsharpPattern
        , patternType : FsharpType
        , expression : FsharpExpression
        }
    | FsharpLetDeclarationValueOrFunction
        { name : String
        , parameters : List { pattern : FsharpPattern, type_ : FsharpType }
        , result : FsharpExpression
        , resultType : FsharpType
        }


{-| How do references used in a module map to their origin module?

Contains variants, variant function and value declaration names.

-}
type alias ModuleContext =
    { recordTypeAliases :
        FastDict.Dict
            -- module origin
            String
            (FastDict.Dict
                String
                (List String)
            )
    , portIncomingLookup : FastSet.Set ( String, String )
    , portOutgoingLookup : FastSet.Set ( String, String )
    }


{-| Calculate valid mappings of qualifications + name
to origin module based on a module's imports.

Requires all exposed names
so we can resolve `exposing (..)` and `ChoiceType(..)`.

-}
importsToModuleContext :
    FastDict.Dict
        String
        { valueOrFunctionOrTypeAliasNames : FastSet.Set String
        , choiceTypesExposingVariants :
            FastDict.Dict String (FastDict.Dict String { valueCount : Int })
        , recordTypeAliases :
            FastDict.Dict String (List String)
        , portsIncoming : FastSet.Set String
        , portsOutgoing : FastSet.Set String
        }
    -> List (Elm.Syntax.Node.Node Elm.Syntax.Import.Import)
    -> ModuleContext
importsToModuleContext moduleExposes imports =
    let
        importsNormal :
            List
                { moduleName : String
                , alias : Maybe String
                , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes :
                    FastSet.Set String
                , exposedVariants :
                    FastDict.Dict String { valueCount : Int }
                , exposedRecordTypeAliases :
                    FastDict.Dict String (List String)
                , exposedPortsOutgoing : FastSet.Set String
                , exposedPortsIncoming : FastSet.Set String
                }
        importsNormal =
            implicitImports
                ++ (imports
                        |> List.map
                            (\(Elm.Syntax.Node.Node _ syntaxImport) ->
                                let
                                    importModuleName : String
                                    importModuleName =
                                        syntaxImport.moduleName
                                            |> Elm.Syntax.Node.value
                                            |> String.join "."

                                    exposes :
                                        { valuesAndFunctionsAndTypeAliasesAndChoiceTypes :
                                            FastSet.Set String
                                        , variants :
                                            FastDict.Dict String { valueCount : Int }
                                        , recordTypeAliases :
                                            FastDict.Dict String (List String)
                                        , portsOutgoing : FastSet.Set String
                                        , portsIncoming : FastSet.Set String
                                        }
                                    exposes =
                                        case syntaxImport.exposingList of
                                            Nothing ->
                                                exposesEmpty

                                            Just (Elm.Syntax.Node.Node _ syntaxExposing) ->
                                                case moduleExposes |> FastDict.get importModuleName of
                                                    Nothing ->
                                                        exposesEmpty

                                                    Just moduleExposedNames ->
                                                        case syntaxExposing of
                                                            Elm.Syntax.Exposing.All _ ->
                                                                { valuesAndFunctionsAndTypeAliasesAndChoiceTypes =
                                                                    moduleExposedNames.choiceTypesExposingVariants
                                                                        |> FastDict.foldl
                                                                            (\choiceTypeName _ soFar ->
                                                                                soFar |> FastSet.insert choiceTypeName
                                                                            )
                                                                            moduleExposedNames.valueOrFunctionOrTypeAliasNames
                                                                , variants =
                                                                    moduleExposedNames.choiceTypesExposingVariants
                                                                        |> FastDict.foldl
                                                                            (\_ variantNames soFar -> FastDict.union variantNames soFar)
                                                                            FastDict.empty
                                                                , recordTypeAliases =
                                                                    moduleExposedNames.recordTypeAliases
                                                                , portsOutgoing = moduleExposedNames.portsOutgoing
                                                                , portsIncoming = moduleExposedNames.portsIncoming
                                                                }

                                                            Elm.Syntax.Exposing.Explicit explicitEposes ->
                                                                explicitEposes
                                                                    |> List.foldl
                                                                        (\(Elm.Syntax.Node.Node _ expose) soFar ->
                                                                            case expose of
                                                                                Elm.Syntax.Exposing.InfixExpose _ ->
                                                                                    soFar

                                                                                Elm.Syntax.Exposing.TypeOrAliasExpose name ->
                                                                                    { valuesAndFunctionsAndTypeAliasesAndChoiceTypes =
                                                                                        soFar.valuesAndFunctionsAndTypeAliasesAndChoiceTypes
                                                                                            |> FastSet.insert name
                                                                                    , variants = soFar.variants
                                                                                    , recordTypeAliases =
                                                                                        case moduleExposedNames.recordTypeAliases |> FastDict.get name of
                                                                                            Nothing ->
                                                                                                soFar.recordTypeAliases

                                                                                            Just fieldOrder ->
                                                                                                soFar.recordTypeAliases
                                                                                                    |> FastDict.insert name fieldOrder
                                                                                    , portsOutgoing = soFar.portsOutgoing
                                                                                    , portsIncoming = soFar.portsIncoming
                                                                                    }

                                                                                Elm.Syntax.Exposing.FunctionExpose name ->
                                                                                    if moduleExposedNames.portsOutgoing |> FastSet.member name then
                                                                                        { valuesAndFunctionsAndTypeAliasesAndChoiceTypes =
                                                                                            soFar.valuesAndFunctionsAndTypeAliasesAndChoiceTypes
                                                                                        , variants = soFar.variants
                                                                                        , recordTypeAliases = soFar.recordTypeAliases
                                                                                        , portsOutgoing =
                                                                                            soFar.portsOutgoing
                                                                                                |> FastSet.insert name
                                                                                        , portsIncoming = soFar.portsIncoming
                                                                                        }

                                                                                    else if moduleExposedNames.portsIncoming |> FastSet.member name then
                                                                                        { valuesAndFunctionsAndTypeAliasesAndChoiceTypes =
                                                                                            soFar.valuesAndFunctionsAndTypeAliasesAndChoiceTypes
                                                                                        , variants = soFar.variants
                                                                                        , recordTypeAliases = soFar.recordTypeAliases
                                                                                        , portsOutgoing = soFar.portsOutgoing
                                                                                        , portsIncoming =
                                                                                            soFar.portsIncoming
                                                                                                |> FastSet.insert name
                                                                                        }

                                                                                    else
                                                                                        { valuesAndFunctionsAndTypeAliasesAndChoiceTypes =
                                                                                            soFar.valuesAndFunctionsAndTypeAliasesAndChoiceTypes
                                                                                                |> FastSet.insert name
                                                                                        , variants = soFar.variants
                                                                                        , recordTypeAliases = soFar.recordTypeAliases
                                                                                        , portsOutgoing = soFar.portsOutgoing
                                                                                        , portsIncoming = soFar.portsIncoming
                                                                                        }

                                                                                Elm.Syntax.Exposing.TypeExpose choiceTypeExpose ->
                                                                                    { valuesAndFunctionsAndTypeAliasesAndChoiceTypes =
                                                                                        soFar.valuesAndFunctionsAndTypeAliasesAndChoiceTypes
                                                                                            |> FastSet.insert choiceTypeExpose.name
                                                                                    , variants =
                                                                                        case choiceTypeExpose.open of
                                                                                            Nothing ->
                                                                                                soFar.variants

                                                                                            Just _ ->
                                                                                                case
                                                                                                    moduleExposedNames.choiceTypesExposingVariants
                                                                                                        |> FastDict.get choiceTypeExpose.name
                                                                                                of
                                                                                                    Nothing ->
                                                                                                        soFar.variants

                                                                                                    Just choiceTypeDeclared ->
                                                                                                        FastDict.union
                                                                                                            soFar.variants
                                                                                                            choiceTypeDeclared
                                                                                    , recordTypeAliases = soFar.recordTypeAliases
                                                                                    , portsOutgoing = soFar.portsOutgoing
                                                                                    , portsIncoming = soFar.portsIncoming
                                                                                    }
                                                                        )
                                                                        exposesEmpty
                                in
                                { moduleName = importModuleName
                                , alias =
                                    syntaxImport.moduleAlias
                                        |> Maybe.map
                                            (\(Elm.Syntax.Node.Node _ syntaxAlias) ->
                                                syntaxAlias |> String.join "."
                                            )
                                , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes =
                                    exposes.valuesAndFunctionsAndTypeAliasesAndChoiceTypes
                                , exposedVariants = exposes.variants
                                , exposedRecordTypeAliases = exposes.recordTypeAliases
                                , exposedPortsOutgoing = exposes.portsOutgoing
                                , exposedPortsIncoming = exposes.portsIncoming
                                }
                            )
                   )
                |> importsCombine
    in
    importsNormal
        |> List.foldl
            (\syntaxImport soFar ->
                let
                    importedModuleMembers :
                        { recordTypeAliases :
                            FastDict.Dict String (List String)
                        , portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        }
                    importedModuleMembers =
                        case moduleExposes |> FastDict.get syntaxImport.moduleName of
                            Nothing ->
                                { recordTypeAliases = FastDict.empty
                                , portsIncoming = FastSet.empty
                                , portsOutgoing = FastSet.empty
                                }

                            Just moduleExposedNames ->
                                { recordTypeAliases =
                                    moduleExposedNames.recordTypeAliases
                                , portsIncoming = moduleExposedNames.portsIncoming
                                , portsOutgoing = moduleExposedNames.portsOutgoing
                                }
                in
                soFar
                    |> moduleContextMerge
                        { recordTypeAliases =
                            FastDict.singleton syntaxImport.moduleName
                                importedModuleMembers.recordTypeAliases
                        , portIncomingLookup =
                            syntaxImport.exposedPortsIncoming
                                |> FastSet.map (\portName -> ( syntaxImport.moduleName, portName ))
                        , portOutgoingLookup =
                            syntaxImport.exposedPortsOutgoing
                                |> FastSet.map (\portName -> ( syntaxImport.moduleName, portName ))
                        }
            )
            moduleContextEmpty


moduleContextEmpty : ModuleContext
moduleContextEmpty =
    { recordTypeAliases = FastDict.empty
    , portIncomingLookup = FastSet.empty
    , portOutgoingLookup = FastSet.empty
    }


exposesEmpty :
    { valuesAndFunctionsAndTypeAliasesAndChoiceTypes :
        FastSet.Set String
    , variants :
        FastDict.Dict String { valueCount : Int }
    , recordTypeAliases :
        FastDict.Dict String (List String)
    , portsOutgoing : FastSet.Set String
    , portsIncoming : FastSet.Set String
    }
exposesEmpty =
    { valuesAndFunctionsAndTypeAliasesAndChoiceTypes =
        FastSet.empty
    , variants = FastDict.empty
    , recordTypeAliases = FastDict.empty
    , portsOutgoing = FastSet.empty
    , portsIncoming = FastSet.empty
    }


moduleContextMerge : ModuleContext -> ModuleContext -> ModuleContext
moduleContextMerge a b =
    { recordTypeAliases =
        FastDict.union
            a.recordTypeAliases
            b.recordTypeAliases
    , portIncomingLookup =
        FastSet.union a.portIncomingLookup b.portIncomingLookup
    , portOutgoingLookup =
        FastSet.union a.portOutgoingLookup b.portOutgoingLookup
    }


implicitImports :
    List
        { moduleName : String
        , alias : Maybe String
        , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes :
            FastSet.Set String
        , exposedVariants :
            FastDict.Dict String { valueCount : Int }
        , exposedRecordTypeAliases :
            FastDict.Dict String (List String)
        , exposedPortsOutgoing : FastSet.Set String
        , exposedPortsIncoming : FastSet.Set String
        }
implicitImports =
    [ { moduleName = "Basics"
      , alias = Nothing
      , exposedRecordTypeAliases = FastDict.empty
      , exposedPortsOutgoing = FastSet.empty
      , exposedPortsIncoming = FastSet.empty
      , exposedVariants =
            FastDict.fromList
                [ ( "EQ", { valueCount = 0 } )
                , ( "LT", { valueCount = 0 } )
                , ( "GT", { valueCount = 0 } )
                , ( "True", { valueCount = 0 } )
                , ( "False", { valueCount = 0 } )
                ]
      , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes =
            FastSet.fromList
                [ "Int"
                , "Float"
                , "toFloat"
                , "round"
                , "floor"
                , "ceiling"
                , "truncate"
                , "max"
                , "min"
                , "compare"
                , "Order"
                , "Bool"
                , "not"
                , "xor"
                , "modBy"
                , "remainderBy"
                , "negate"
                , "abs"
                , "clamp"
                , "sqrt"
                , "logBase"
                , "e"
                , "pi"
                , "cos"
                , "sin"
                , "tan"
                , "acos"
                , "asin"
                , "atan"
                , "atan2"
                , "degrees"
                , "radians"
                , "turns"
                , "toPolar"
                , "fromPolar"
                , "isNaN"
                , "isInfinite"
                , "identity"
                , "always"
                , "Never"
                , "never"
                ]
      }
    , { moduleName = "List"
      , alias = Nothing
      , exposedRecordTypeAliases = FastDict.empty
      , exposedPortsOutgoing = FastSet.empty
      , exposedPortsIncoming = FastSet.empty
      , exposedVariants = FastDict.empty
      , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes =
            FastSet.fromList [ "List" ]
      }
    , { moduleName = "Maybe"
      , alias = Nothing
      , exposedRecordTypeAliases = FastDict.empty
      , exposedPortsOutgoing = FastSet.empty
      , exposedPortsIncoming = FastSet.empty
      , exposedVariants =
            FastDict.fromList
                [ ( "Just", { valueCount = 1 } )
                , ( "Nothing", { valueCount = 0 } )
                ]
      , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes =
            FastSet.fromList [ "Maybe" ]
      }
    , { moduleName = "Result"
      , alias = Nothing
      , exposedRecordTypeAliases = FastDict.empty
      , exposedPortsOutgoing = FastSet.empty
      , exposedPortsIncoming = FastSet.empty
      , exposedVariants =
            FastDict.fromList
                [ ( "Ok", { valueCount = 1 } )
                , ( "Err", { valueCount = 1 } )
                ]
      , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes =
            FastSet.fromList [ "Result" ]
      }
    , { moduleName = "String"
      , alias = Nothing
      , exposedRecordTypeAliases = FastDict.empty
      , exposedPortsOutgoing = FastSet.empty
      , exposedPortsIncoming = FastSet.empty
      , exposedVariants = FastDict.empty
      , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes =
            FastSet.fromList [ "String" ]
      }
    , { moduleName = "Char"
      , alias = Nothing
      , exposedRecordTypeAliases = FastDict.empty
      , exposedPortsOutgoing = FastSet.empty
      , exposedPortsIncoming = FastSet.empty
      , exposedVariants = FastDict.empty
      , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes =
            FastSet.fromList [ "Char" ]
      }
    , { moduleName = "Tuple"
      , alias = Nothing
      , exposedRecordTypeAliases = FastDict.empty
      , exposedPortsOutgoing = FastSet.empty
      , exposedPortsIncoming = FastSet.empty
      , exposedVariants = FastDict.empty
      , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes =
            FastSet.empty
      }
    , { moduleName = "Debug"
      , alias = Nothing
      , exposedRecordTypeAliases = FastDict.empty
      , exposedPortsOutgoing = FastSet.empty
      , exposedPortsIncoming = FastSet.empty
      , exposedVariants = FastDict.empty
      , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes =
            FastSet.empty
      }
    , { moduleName = "Platform"
      , alias = Nothing
      , exposedRecordTypeAliases = FastDict.empty
      , exposedPortsOutgoing = FastSet.empty
      , exposedPortsIncoming = FastSet.empty
      , exposedVariants = FastDict.empty
      , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes =
            FastSet.fromList [ "Program" ]
      }
    , { moduleName = "Platform.Cmd"
      , alias = Just "Cmd"
      , exposedRecordTypeAliases = FastDict.empty
      , exposedPortsOutgoing = FastSet.empty
      , exposedPortsIncoming = FastSet.empty
      , exposedVariants = FastDict.empty
      , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes =
            FastSet.fromList [ "Cmd" ]
      }
    , { moduleName = "Platform.Sub"
      , alias = Just "Sub"
      , exposedRecordTypeAliases = FastDict.empty
      , exposedPortsOutgoing = FastSet.empty
      , exposedPortsIncoming = FastSet.empty
      , exposedVariants = FastDict.empty
      , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes =
            FastSet.fromList [ "Sub" ]
      }
    ]


importsCombine :
    List
        { moduleName : String
        , alias : Maybe String
        , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes :
            FastSet.Set String
        , exposedVariants :
            FastDict.Dict String { valueCount : Int }
        , exposedRecordTypeAliases :
            FastDict.Dict String (List String)
        , exposedPortsOutgoing : FastSet.Set String
        , exposedPortsIncoming : FastSet.Set String
        }
    ->
        List
            { moduleName : String
            , alias : Maybe String
            , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes :
                FastSet.Set String
            , exposedVariants :
                FastDict.Dict String { valueCount : Int }
            , exposedRecordTypeAliases :
                FastDict.Dict String (List String)
            , exposedPortsOutgoing : FastSet.Set String
            , exposedPortsIncoming : FastSet.Set String
            }
importsCombine syntaxImports =
    importsCombineFrom [] syntaxImports


importsCombineFrom :
    List
        { moduleName : String
        , alias : Maybe String
        , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes :
            FastSet.Set String
        , exposedVariants :
            FastDict.Dict String { valueCount : Int }
        , exposedRecordTypeAliases :
            FastDict.Dict String (List String)
        , exposedPortsOutgoing : FastSet.Set String
        , exposedPortsIncoming : FastSet.Set String
        }
    ->
        List
            { moduleName : String
            , alias : Maybe String
            , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes :
                FastSet.Set String
            , exposedVariants :
                FastDict.Dict String { valueCount : Int }
            , exposedRecordTypeAliases :
                FastDict.Dict String (List String)
            , exposedPortsOutgoing : FastSet.Set String
            , exposedPortsIncoming : FastSet.Set String
            }
    ->
        List
            { moduleName : String
            , alias : Maybe String
            , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes :
                FastSet.Set String
            , exposedVariants :
                FastDict.Dict String { valueCount : Int }
            , exposedRecordTypeAliases :
                FastDict.Dict String (List String)
            , exposedPortsOutgoing : FastSet.Set String
            , exposedPortsIncoming : FastSet.Set String
            }
importsCombineFrom soFar syntaxImports =
    case syntaxImports of
        [] ->
            soFar

        [ onlyImport ] ->
            onlyImport :: soFar

        import0 :: import1 :: import2Up ->
            if import0.moduleName == import1.moduleName then
                importsCombineFrom soFar
                    (importMerge import0 import1
                        :: import2Up
                    )

            else
                importsCombineFrom
                    (import0 :: soFar)
                    (import1 :: import2Up)


importMerge :
    { moduleName : String
    , alias : Maybe String
    , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes :
        FastSet.Set String
    , exposedVariants :
        FastDict.Dict String { valueCount : Int }
    , exposedRecordTypeAliases :
        FastDict.Dict String (List String)
    , exposedPortsOutgoing : FastSet.Set String
    , exposedPortsIncoming : FastSet.Set String
    }
    ->
        { moduleName : String
        , alias : Maybe String
        , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes :
            FastSet.Set String
        , exposedVariants :
            FastDict.Dict String { valueCount : Int }
        , exposedRecordTypeAliases :
            FastDict.Dict String (List String)
        , exposedPortsOutgoing : FastSet.Set String
        , exposedPortsIncoming : FastSet.Set String
        }
    ->
        { moduleName : String
        , alias : Maybe String
        , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes :
            FastSet.Set String
        , exposedVariants :
            FastDict.Dict String { valueCount : Int }
        , exposedRecordTypeAliases :
            FastDict.Dict String (List String)
        , exposedPortsOutgoing : FastSet.Set String
        , exposedPortsIncoming : FastSet.Set String
        }
importMerge earlier later =
    { moduleName = earlier.moduleName
    , alias =
        case earlier.alias of
            Just alias ->
                alias |> Just

            Nothing ->
                later.alias
    , exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes =
        FastSet.union
            earlier.exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes
            later.exposedValuesAndFunctionsAndTypeAliasesAndChoiceTypes
    , exposedVariants =
        FastDict.union
            earlier.exposedVariants
            later.exposedVariants
    , exposedRecordTypeAliases =
        FastDict.union
            earlier.exposedRecordTypeAliases
            later.exposedRecordTypeAliases
    , exposedPortsOutgoing =
        FastSet.union earlier.exposedPortsIncoming
            later.exposedPortsIncoming
    , exposedPortsIncoming =
        FastSet.union earlier.exposedPortsOutgoing
            later.exposedPortsOutgoing
    }


typeContainedRecords :
    Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    ->
        FastSet.Set
            -- sorted field names
            (List String)
typeContainedRecords (Elm.Syntax.Node.Node _ syntaxType) =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            FastSet.empty

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            FastSet.empty

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            FastSet.union
                (inType |> typeContainedRecords)
                (outType |> typeContainedRecords)

        Elm.Syntax.TypeAnnotation.Tupled typeTupleParts ->
            typeTupleParts
                |> listMapToFastSetsAndUnify
                    typeContainedRecords

        Elm.Syntax.TypeAnnotation.Typed _ arguments ->
            arguments
                |> listMapToFastSetsAndUnify
                    typeContainedRecords

        Elm.Syntax.TypeAnnotation.Record fields ->
            FastSet.insert
                (fields
                    |> List.map
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                            name
                        )
                    |> List.sort
                )
                (fields
                    |> List.map
                        (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                            value
                        )
                    |> listMapToFastSetsAndUnify
                        typeContainedRecords
                )

        Elm.Syntax.TypeAnnotation.GenericRecord _ (Elm.Syntax.Node.Node _ fields) ->
            fields
                |> List.map
                    (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                        value
                    )
                |> listMapToFastSetsAndUnify
                    typeContainedRecords


syntaxExpressionContainedConstructedRecords :
    Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
    ->
        FastSet.Set
            -- sorted field names
            (List String)
syntaxExpressionContainedConstructedRecords syntaxExpressionNode =
    -- IGNORE TCO
    FastSet.union
        (case syntaxExpressionNode |> Elm.Syntax.Node.value of
            Elm.Syntax.Expression.RecordExpr fields ->
                FastSet.singleton
                    (fields
                        |> List.map
                            (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                                name
                            )
                        |> List.sort
                    )

            Elm.Syntax.Expression.UnitExpr ->
                FastSet.empty

            Elm.Syntax.Expression.Floatable _ ->
                FastSet.empty

            Elm.Syntax.Expression.Integer _ ->
                FastSet.empty

            Elm.Syntax.Expression.Hex _ ->
                FastSet.empty

            Elm.Syntax.Expression.CharLiteral _ ->
                FastSet.empty

            Elm.Syntax.Expression.Literal _ ->
                FastSet.empty

            Elm.Syntax.Expression.FunctionOrValue _ _ ->
                FastSet.empty

            Elm.Syntax.Expression.RecordAccess _ _ ->
                FastSet.empty

            Elm.Syntax.Expression.TupledExpression _ ->
                FastSet.empty

            Elm.Syntax.Expression.IfBlock _ _ _ ->
                FastSet.empty

            Elm.Syntax.Expression.ListExpr _ ->
                FastSet.empty

            Elm.Syntax.Expression.RecordUpdateExpression _ _ ->
                FastSet.empty

            Elm.Syntax.Expression.Application _ ->
                FastSet.empty

            Elm.Syntax.Expression.LambdaExpression _ ->
                FastSet.empty

            Elm.Syntax.Expression.CaseExpression _ ->
                FastSet.empty

            Elm.Syntax.Expression.LetExpression _ ->
                FastSet.empty

            Elm.Syntax.Expression.OperatorApplication _ _ _ _ ->
                FastSet.empty

            Elm.Syntax.Expression.PrefixOperator _ ->
                FastSet.empty

            Elm.Syntax.Expression.Operator _ ->
                FastSet.empty

            Elm.Syntax.Expression.Negation _ ->
                FastSet.empty

            Elm.Syntax.Expression.ParenthesizedExpression _ ->
                FastSet.empty

            Elm.Syntax.Expression.RecordAccessFunction _ ->
                FastSet.empty

            Elm.Syntax.Expression.GLSLExpression _ ->
                FastSet.empty
        )
        (syntaxExpressionNode
            |> syntaxExpressionSubs
            |> listMapToFastSetsAndUnify
                syntaxExpressionContainedConstructedRecords
        )


{-| All surface-level child [expression](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression)s
-}
syntaxExpressionSubs :
    Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
    -> List (Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression)
syntaxExpressionSubs (Elm.Syntax.Node.Node _ syntaxExpression) =
    case syntaxExpression of
        Elm.Syntax.Expression.Application expressions ->
            expressions

        Elm.Syntax.Expression.ListExpr elements ->
            elements

        Elm.Syntax.Expression.RecordExpr fields ->
            List.map (\(Elm.Syntax.Node.Node _ ( _, expr )) -> expr) fields

        Elm.Syntax.Expression.RecordUpdateExpression _ setters ->
            List.map (\(Elm.Syntax.Node.Node _ ( _, expr )) -> expr) setters

        Elm.Syntax.Expression.ParenthesizedExpression expr ->
            [ expr ]

        Elm.Syntax.Expression.OperatorApplication _ _ left right ->
            [ left, right ]

        Elm.Syntax.Expression.IfBlock cond then_ else_ ->
            [ cond, then_, else_ ]

        Elm.Syntax.Expression.LetExpression letIn ->
            List.foldr
                (\declaration soFar ->
                    case Elm.Syntax.Node.value declaration of
                        Elm.Syntax.Expression.LetFunction function ->
                            (function.declaration
                                |> Elm.Syntax.Node.value
                                |> .expression
                            )
                                :: soFar

                        Elm.Syntax.Expression.LetDestructuring _ expr ->
                            expr :: soFar
                )
                [ letIn.expression ]
                letIn.declarations

        Elm.Syntax.Expression.CaseExpression caseOf ->
            caseOf.expression
                :: List.map (\( _, caseExpression ) -> caseExpression) caseOf.cases

        Elm.Syntax.Expression.LambdaExpression lambda ->
            [ lambda.expression ]

        Elm.Syntax.Expression.TupledExpression expressions ->
            expressions

        Elm.Syntax.Expression.Negation expr ->
            [ expr ]

        Elm.Syntax.Expression.RecordAccess expr _ ->
            [ expr ]

        Elm.Syntax.Expression.PrefixOperator _ ->
            []

        Elm.Syntax.Expression.Operator _ ->
            []

        Elm.Syntax.Expression.Integer _ ->
            []

        Elm.Syntax.Expression.Hex _ ->
            []

        Elm.Syntax.Expression.Floatable _ ->
            []

        Elm.Syntax.Expression.Literal _ ->
            []

        Elm.Syntax.Expression.CharLiteral _ ->
            []

        Elm.Syntax.Expression.UnitExpr ->
            []

        Elm.Syntax.Expression.FunctionOrValue _ _ ->
            []

        Elm.Syntax.Expression.RecordAccessFunction _ ->
            []

        Elm.Syntax.Expression.GLSLExpression _ ->
            []


fsharpExpressionUsedLocalReferences : FsharpExpression -> FastSet.Set String
fsharpExpressionUsedLocalReferences syntaxExpression =
    -- IGNORE TCO
    case syntaxExpression of
        FsharpExpressionReference reference ->
            case reference.moduleOrigin of
                Just _ ->
                    FastSet.empty

                Nothing ->
                    FastSet.singleton reference.name

        expressionNotReference ->
            expressionNotReference
                |> fsharpExpressionSubs
                |> listMapToFastSetsAndUnify
                    fsharpExpressionUsedLocalReferences


{-| All surface-level child [expression](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Expression)s.
Order is not specified
-}
fsharpExpressionSubs : FsharpExpression -> List FsharpExpression
fsharpExpressionSubs fsharpExpression =
    case fsharpExpression of
        FsharpExpressionUnit ->
            []

        FsharpExpressionInt64 _ ->
            []

        FsharpExpressionFloat _ ->
            []

        FsharpExpressionStringLiteral _ ->
            []

        FsharpExpressionChar _ ->
            []

        FsharpExpressionReference _ ->
            []

        FsharpExpressionCall call ->
            call.called
                :: call.arguments

        FsharpExpressionListLiteral elements ->
            elements

        FsharpExpressionArrayLiteral elements ->
            elements

        FsharpExpressionRecord fields ->
            fields |> FastDict.values

        FsharpExpressionRecordUpdate recordUpdate ->
            recordUpdate.fields |> FastDict.values

        FsharpExpressionIfElse ifThenElse ->
            [ ifThenElse.condition
            , ifThenElse.onTrue
            , ifThenElse.onFalse
            ]

        FsharpExpressionWithLetDeclarations letIn ->
            List.foldl
                (\declaration soFar ->
                    case declaration of
                        FsharpLetDeclarationValueOrFunction letValueOrFunction ->
                            letValueOrFunction.result :: soFar

                        FsharpLetDestructuring letDestructuring ->
                            letDestructuring.expression :: soFar
                )
                [ letIn.result ]
                (letIn.declaration0 :: letIn.declaration1Up)

        FsharpExpressionMatchWith matchWith ->
            matchWith.matched
                :: matchWith.case0.result
                :: (matchWith.case1Up |> List.map .result)

        FsharpExpressionLambda lambda ->
            [ lambda.result ]

        FsharpExpressionTuple parts ->
            parts.part0
                :: parts.part1
                :: parts.part2Up

        FsharpExpressionRecordAccess recordAccess ->
            [ recordAccess.record ]


choiceTypeDeclaration :
    { name : String
    , parameters : List String
    , variants : FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
    }
    ->
        { name : String
        , parameters : List String
        , variants : FastDict.Dict String (Maybe FsharpType)
        }
choiceTypeDeclaration syntaxChoiceType =
    { name = syntaxChoiceType.name
    , parameters =
        syntaxChoiceType.parameters
            |> List.map variableNameDisambiguateFromFsharpKeywords
    , variants =
        syntaxChoiceType.variants
            |> FastDict.map
                (\_ variantValues ->
                    case variantValues of
                        [] ->
                            Nothing

                        [ variantValue ] ->
                            Just (variantValue |> type_)

                        variantValue0 :: variantValue1 :: variantValue2Up ->
                            Just
                                (FsharpTypeTuple
                                    { part0 = variantValue0 |> type_
                                    , part1 = variantValue1 |> type_
                                    , part2Up = variantValue2Up |> List.map type_
                                    }
                                )
                )
    }


fsharpTypeParametersToString : List String -> String
fsharpTypeParametersToString fsharpTypeParameters =
    case fsharpTypeParameters of
        [] ->
            ""

        parameter0 :: parameter1Up ->
            "<"
                ++ ((parameter0 :: parameter1Up)
                        |> List.map (\parameter -> "'" ++ parameter)
                        |> String.join ", "
                   )
                ++ ">"


printFsharpChoiceTypeDeclaration :
    { name : String
    , parameters : List String
    , variants : FastDict.Dict String (Maybe FsharpType)
    }
    -> Print
printFsharpChoiceTypeDeclaration fsharpChoiceType =
    Print.exactly
        (fsharpChoiceType.name
            ++ fsharpTypeParametersToString fsharpChoiceType.parameters
            ++ " ="
        )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (fsharpChoiceType.variants
                            |> FastDict.toList
                            |> Print.listMapAndIntersperseAndFlatten
                                (\( name, maybeValue ) ->
                                    printFsharpVariantDeclaration
                                        { name = name
                                        , maybeValue = maybeValue
                                        }
                                )
                                Print.linebreakIndented
                        )
                )
            )


printFsharpVariantDeclaration : { name : String, maybeValue : Maybe FsharpType } -> Print
printFsharpVariantDeclaration fsharpVariant =
    Print.exactly ("| " ++ fsharpVariant.name)
        |> Print.followedBy
            (case fsharpVariant.maybeValue of
                Nothing ->
                    Print.empty

                Just value ->
                    let
                        valuePrint : Print
                        valuePrint =
                            value |> printFsharpTypeParenthesizedIfSpaceSeparated
                    in
                    Print.exactly (" of " ++ fsharpVariant.name ++ ":")
                        |> Print.followedBy
                            (Print.withIndentAtNextMultipleOf4
                                (Print.spaceOrLinebreakIndented
                                    (valuePrint |> Print.lineSpread)
                                    |> Print.followedBy valuePrint
                                )
                            )
            )


typeAliasDeclaration :
    { name : String
    , parameters : List String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        { name : String
        , parameters : List String
        , type_ : FsharpType
        }
typeAliasDeclaration inferredTypeAlias =
    { name = inferredTypeAlias.name
    , parameters =
        inferredTypeAlias.parameters
            |> List.map
                variableNameDisambiguateFromFsharpKeywords
    , type_ =
        inferredTypeAlias.type_
            |> type_
    }


printFsharpTypeAliasDeclaration :
    { name : String
    , parameters : List String
    , type_ : FsharpType
    }
    -> Print
printFsharpTypeAliasDeclaration fsharpTypeAliasDeclaration =
    Print.exactly
        (fsharpTypeAliasDeclaration.name
            ++ fsharpTypeParametersToString fsharpTypeAliasDeclaration.parameters
            ++ " ="
        )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (fsharpTypeAliasDeclaration.type_
                            |> printFsharpTypeNotParenthesized
                        )
                )
            )


printFsharpRecordTypeDeclaration : List String -> Print
printFsharpRecordTypeDeclaration fsharpRecordFieldNames =
    let
        fsharpRecordFields : FastDict.Dict String FsharpType
        fsharpRecordFields =
            fsharpRecordFieldNames
                |> List.foldl
                    (\fieldName soFar ->
                        soFar
                            |> FastDict.insert fieldName
                                (FsharpTypeVariable
                                    (fieldName
                                        |> stringFirstCharToLower
                                        |> variableNameDisambiguateFromFsharpKeywords
                                    )
                                )
                    )
                    FastDict.empty

        fieldsPrint : Print
        fieldsPrint =
            fsharpRecordFields
                |> FastDict.toList
                |> Print.listMapAndIntersperseAndFlatten
                    (\( fieldName, fieldValue ) ->
                        let
                            valuePrint : Print
                            valuePrint =
                                printFsharpTypeNotParenthesized fieldValue
                        in
                        Print.withIndentIncreasedBy 2
                            (Print.exactly (fieldName ++ ":")
                                |> Print.followedBy
                                    (Print.withIndentAtNextMultipleOf4
                                        (Print.spaceOrLinebreakIndented
                                            (valuePrint |> Print.lineSpread)
                                            |> Print.followedBy valuePrint
                                        )
                                    )
                            )
                    )
                    printLinebreakIndentedSemicolonSpace
    in
    printExactlyStructLinebreakIndented
        |> Print.followedBy
            (Print.exactly
                ("type "
                    ++ generatedFsharpRecordTypeAliasName
                        fsharpRecordFieldNames
                    ++ (fsharpRecordFieldNames
                            |> List.map
                                (\fieldName ->
                                    fieldName
                                        |> stringFirstCharToLower
                                        |> variableNameDisambiguateFromFsharpKeywords
                                )
                            |> fsharpTypeParametersToString
                       )
                    ++ " ="
                )
            )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (linebreakIndentedCurlyOpeningSpace
                    |> Print.followedBy fieldsPrint
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented
                            (fieldsPrint |> Print.lineSpread)
                        )
                    |> Print.followedBy printExactlyCurlyClosing
                )
            )


linebreakIndentedCurlyOpeningSpace : Print
linebreakIndentedCurlyOpeningSpace =
    Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyOpeningSpace


printExactlyStructLinebreakIndented : Print
printExactlyStructLinebreakIndented =
    Print.exactly "[<Struct>]"
        |> Print.followedBy Print.linebreakIndented


fsharpTypeFloat : FsharpType
fsharpTypeFloat =
    FsharpTypeConstruct
        { moduleOrigin = Nothing
        , name = "float"
        , arguments = []
        }


type_ : ElmSyntaxTypeInfer.Type -> FsharpType
type_ inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            if variable.name |> String.startsWith "number" then
                -- assume Float
                fsharpTypeFloat

            else
                FsharpTypeVariable (variable.name |> variableNameDisambiguateFromFsharpKeywords)

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            typeNotVariable inferredTypeNotVariable


typeNotVariable : ElmSyntaxTypeInfer.TypeNotVariable -> FsharpType
typeNotVariable inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            fsharpTypeUnit

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            let
                fsharpReference : { moduleOrigin : Maybe String, name : String }
                fsharpReference =
                    case
                        { moduleOrigin = typeConstruct.moduleOrigin
                        , name = typeConstruct.name
                        }
                            |> typeConstructReferenceToCoreFsharp
                    of
                        Just coreFsharp ->
                            coreFsharp

                        Nothing ->
                            { moduleOrigin = Nothing
                            , name =
                                { moduleOrigin = typeConstruct.moduleOrigin
                                , name = typeConstruct.name
                                }
                                    |> referenceToFsharpName
                            }
            in
            FsharpTypeConstruct
                { moduleOrigin = fsharpReference.moduleOrigin
                , name = fsharpReference.name
                , arguments =
                    typeConstruct.arguments
                        |> List.map type_
                }

        ElmSyntaxTypeInfer.TypeTuple typeTuple ->
            FsharpTypeTuple
                { part0 = typeTuple.part0 |> type_
                , part1 = typeTuple.part1 |> type_
                , part2Up = []
                }

        ElmSyntaxTypeInfer.TypeTriple typeTriple ->
            FsharpTypeTuple
                { part0 = typeTriple.part0 |> type_
                , part1 = typeTriple.part1 |> type_
                , part2Up = [ typeTriple.part2 |> type_ ]
                }

        ElmSyntaxTypeInfer.TypeRecord recordFields ->
            let
                fsharpFields : FastDict.Dict String FsharpType
                fsharpFields =
                    recordFields
                        |> FastDict.foldr
                            (\name valueType soFar ->
                                soFar
                                    |> FastDict.insert (name |> stringFirstCharToUpper)
                                        (valueType |> type_)
                            )
                            FastDict.empty
            in
            FsharpTypeConstruct
                { moduleOrigin = Nothing
                , name =
                    generatedFsharpRecordTypeAliasName
                        (fsharpFields |> FastDict.keys)
                , arguments =
                    fsharpFields |> FastDict.values
                }

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            FsharpTypeFunction
                { input = typeFunction.input |> type_
                , output = typeFunction.output |> type_
                }

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            -- Err
            --     ((typeRange |> rangeToInfoString)
            --         ++ " extensible record types are not supported"
            --     )
            let
                fsharpFields : FastDict.Dict String FsharpType
                fsharpFields =
                    typeRecordExtension.fields
                        |> FastDict.foldr
                            (\name valueType soFar ->
                                soFar
                                    |> FastDict.insert (name |> stringFirstCharToUpper)
                                        (valueType |> type_)
                            )
                            FastDict.empty
            in
            FsharpTypeConstruct
                { moduleOrigin = Nothing
                , name =
                    generatedFsharpRecordTypeAliasName
                        (fsharpFields |> FastDict.keys)
                , arguments =
                    fsharpFields |> FastDict.values
                }


printFsharpTypeNotParenthesized : FsharpType -> Print
printFsharpTypeNotParenthesized fsharpType =
    -- IGNORE TCO
    case fsharpType of
        FsharpTypeVariable variable ->
            Print.exactly ("'" ++ variable)

        FsharpTypeConstruct typeConstruct ->
            printFsharpTypeConstruct typeConstruct

        FsharpTypeTuple parts ->
            printFsharpTypeTuple parts

        FsharpTypeFunction typeFunction ->
            printFsharpTypeFunction typeFunction


printFsharpTypeFunction :
    { input : FsharpType, output : FsharpType }
    -> Print
printFsharpTypeFunction typeFunction =
    let
        inputPrint : Print
        inputPrint =
            printFsharpTypeParenthesizedIfSpaceSeparated
                typeFunction.input

        outputExpanded : List FsharpType
        outputExpanded =
            fsharpTypeExpandFunctionOutput typeFunction.output

        outputPrints : List Print
        outputPrints =
            outputExpanded
                |> List.map printFsharpTypeParenthesizedIfSpaceSeparated

        fullLineSpread : Print.LineSpread
        fullLineSpread =
            inputPrint
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() ->
                        outputPrints
                            |> Print.lineSpreadListMapAndCombine
                                Print.lineSpread
                    )
    in
    inputPrint
        :: (outputPrints
                |> List.map Print.withIndentAtNextMultipleOf4
           )
        |> Print.listIntersperseAndFlatten
            (printExactlySpaceMinusGreaterThan
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented fullLineSpread)
                    )
            )


fsharpTypeExpandFunctionOutput : FsharpType -> List FsharpType
fsharpTypeExpandFunctionOutput fsharpType =
    fsharpTypeExpandFunctionIntoReverse [] fsharpType
        |> List.reverse


fsharpTypeExpandFunctionIntoReverse : List FsharpType -> FsharpType -> List FsharpType
fsharpTypeExpandFunctionIntoReverse soFarReverse fsharpType =
    case fsharpType of
        FsharpTypeFunction function ->
            fsharpTypeExpandFunctionIntoReverse
                (function.input :: soFarReverse)
                function.output

        FsharpTypeConstruct construct ->
            FsharpTypeConstruct construct :: soFarReverse

        FsharpTypeTuple parts ->
            FsharpTypeTuple parts :: soFarReverse

        FsharpTypeVariable variable ->
            FsharpTypeVariable variable :: soFarReverse


printFsharpTypeTuple :
    { part0 : FsharpType, part1 : FsharpType, part2Up : List FsharpType }
    -> Print
printFsharpTypeTuple parts =
    let
        part0Print : Print
        part0Print =
            parts.part0 |> printFsharpTypeNotParenthesized

        part1Print : Print
        part1Print =
            parts.part1 |> printFsharpTypeNotParenthesized

        part2UpPrints : List Print
        part2UpPrints =
            parts.part2Up
                |> List.map printFsharpTypeNotParenthesized
    in
    printExactlyParenOpeningStructParenOpeningLinebreakIndentedSpaceSpace
        |> Print.followedBy
            ((part0Print :: part1Print :: part2UpPrints)
                |> Print.listMapAndIntersperseAndFlatten
                    (\partPrint ->
                        Print.withIndentIncreasedBy 2
                            partPrint
                    )
                    printLinebreakIndentedStarSpace
            )
        |> Print.followedBy
            printLinebreakIndentedParenClosingParenClosing


printExactlyParenOpeningStructParenOpeningLinebreakIndentedSpaceSpace : Print
printExactlyParenOpeningStructParenOpeningLinebreakIndentedSpaceSpace =
    printExactlyParenOpeningStructParenOpening
        |> Print.followedBy
            (Print.withIndentIncreasedBy 2
                Print.linebreakIndented
            )


printLinebreakIndentedStarSpace : Print
printLinebreakIndentedStarSpace =
    Print.linebreakIndented
        |> Print.followedBy
            (Print.exactly "* ")


printLinebreakIndentedParenClosingParenClosing : Print
printLinebreakIndentedParenClosingParenClosing =
    Print.linebreakIndented
        |> Print.followedBy (Print.exactly "))")


printFsharpTypeConstruct :
    { moduleOrigin : Maybe String
    , name : String
    , arguments : List FsharpType
    }
    -> Print
printFsharpTypeConstruct typeConstruct =
    let
        referencePrint : Print
        referencePrint =
            Print.exactly
                (fsharpReferenceToString
                    { moduleOrigin = typeConstruct.moduleOrigin
                    , name = typeConstruct.name
                    }
                )
    in
    case typeConstruct.arguments of
        [] ->
            referencePrint

        argument0 :: argument1Up ->
            let
                argumentPrints : List Print
                argumentPrints =
                    (argument0 :: argument1Up)
                        |> List.map printFsharpTypeNotParenthesized

                fullLineSpread : Print.LineSpread
                fullLineSpread =
                    argumentPrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            referencePrint
                |> Print.followedBy printExactlyLessThan
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented fullLineSpread
                            |> Print.followedBy
                                (argumentPrints
                                    |> Print.listIntersperseAndFlatten
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented fullLineSpread)
                                        )
                                )
                            |> Print.followedBy
                                (Print.emptyOrLinebreakIndented fullLineSpread)
                            |> Print.followedBy
                                printExactlyGreaterThan
                        )
                    )


printExactlyLessThan : Print
printExactlyLessThan =
    Print.exactly "<"


printExactlyGreaterThan : Print
printExactlyGreaterThan =
    Print.exactly ">"


printExactlyComma : Print
printExactlyComma =
    Print.exactly ","


typeIsSpaceSeparated : FsharpType -> Bool
typeIsSpaceSeparated fsharpType =
    case fsharpType of
        FsharpTypeVariable _ ->
            False

        FsharpTypeConstruct _ ->
            False

        FsharpTypeTuple _ ->
            False

        FsharpTypeFunction _ ->
            True


printFsharpTypeParenthesizedIfSpaceSeparated : FsharpType -> Print
printFsharpTypeParenthesizedIfSpaceSeparated fsharpType =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            fsharpType |> printFsharpTypeNotParenthesized
    in
    if fsharpType |> typeIsSpaceSeparated then
        printParenthesized notParenthesizedPrint

    else
        notParenthesizedPrint


floatLiteral : Float -> String
floatLiteral float =
    let
        asString : String
        asString =
            float |> String.fromFloat
    in
    if asString |> String.contains "." then
        asString

    else if asString |> String.contains "e" then
        asString

    else
        asString ++ ".0"


intLiteral : Int -> String
intLiteral int =
    (int |> String.fromInt) ++ "L"


fsharpReferenceToString :
    { moduleOrigin : Maybe String
    , name : String
    }
    -> String
fsharpReferenceToString reference =
    case reference.moduleOrigin of
        Nothing ->
            reference.name

        Just moduleName ->
            moduleName
                ++ "."
                ++ reference.name


stringFirstCharToUpper : String -> String
stringFirstCharToUpper string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( headChar, tailString ) ->
            String.cons (Char.toUpper headChar) tailString


stringFirstCharToLower : String -> String
stringFirstCharToLower string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( headChar, tailString ) ->
            String.cons (Char.toLower headChar) tailString


printFsharpStringLiteral : String -> Print
printFsharpStringLiteral stringContent =
    let
        singleDoubleQuotedStringContentEscaped : String
        singleDoubleQuotedStringContentEscaped =
            stringContent
                |> String.foldl
                    (\contentChar soFar ->
                        soFar ++ singleDoubleQuotedStringCharToEscaped contentChar ++ ""
                    )
                    ""
    in
    Print.exactly ("\"" ++ singleDoubleQuotedStringContentEscaped ++ "\"")


singleDoubleQuotedStringCharToEscaped : Char -> String
singleDoubleQuotedStringCharToEscaped character =
    case character of
        '"' ->
            "\\\""

        '\\' ->
            "\\\\"

        '\t' ->
            "\\t"

        '\n' ->
            "\\n"

        '$' ->
            "\\$"

        '\u{000D}' ->
            "\\r"

        otherCharacter ->
            if characterIsNotPrint otherCharacter then
                "\\u" ++ characterHex otherCharacter

            else
                String.fromChar otherCharacter


unsafeHexDigitIntToString : Int -> String
unsafeHexDigitIntToString int =
    case int of
        0 ->
            "0"

        1 ->
            "1"

        2 ->
            "2"

        3 ->
            "3"

        4 ->
            "4"

        5 ->
            "5"

        6 ->
            "6"

        7 ->
            "7"

        8 ->
            "8"

        9 ->
            "9"

        10 ->
            "A"

        11 ->
            "B"

        12 ->
            "C"

        13 ->
            "D"

        14 ->
            "E"

        -- 15
        _ ->
            "F"


characterHex : Char -> String
characterHex character =
    let
        charCode : Int
        charCode =
            Char.toCode character
    in
    String.toUpper
        (unsafeHexDigitIntToString
            (charCode
                |> Bitwise.and 0xF000
                |> Bitwise.shiftRightBy 12
            )
            ++ unsafeHexDigitIntToString
                (charCode
                    |> Bitwise.and 0x0F00
                    |> Bitwise.shiftRightBy 8
                )
            ++ unsafeHexDigitIntToString
                (charCode
                    |> Bitwise.and 0xF0
                    |> Bitwise.shiftRightBy 4
                )
            ++ unsafeHexDigitIntToString
                (charCode |> Bitwise.and 0x0F)
            ++ ""
        )


characterIsNotPrint : Char -> Bool
characterIsNotPrint character =
    if
        -- Unicode.getCategory is very expensive so we shortcut if at all possible
        charIsLatinAlphaNumOrUnderscoreFast character
            || (case character of
                    ' ' ->
                        True

                    '.' ->
                        True

                    '!' ->
                        True

                    '?' ->
                        True

                    '-' ->
                        True

                    ':' ->
                        True

                    _ ->
                        False
               )
    then
        False

    else
        case Unicode.getCategory character of
            Nothing ->
                True

            Just category ->
                case category of
                    Unicode.SeparatorLine ->
                        True

                    Unicode.SeparatorParagraph ->
                        True

                    Unicode.OtherControl ->
                        True

                    Unicode.OtherFormat ->
                        True

                    Unicode.OtherSurrogate ->
                        True

                    Unicode.OtherPrivateUse ->
                        True

                    Unicode.OtherNotAssigned ->
                        True

                    Unicode.LetterUppercase ->
                        False

                    Unicode.LetterLowercase ->
                        False

                    Unicode.LetterTitlecase ->
                        False

                    Unicode.MarkNonSpacing ->
                        False

                    Unicode.MarkSpacingCombining ->
                        False

                    Unicode.MarkEnclosing ->
                        False

                    Unicode.NumberDecimalDigit ->
                        False

                    Unicode.NumberLetter ->
                        False

                    Unicode.NumberOther ->
                        False

                    Unicode.SeparatorSpace ->
                        True

                    Unicode.LetterModifier ->
                        False

                    Unicode.LetterOther ->
                        False

                    Unicode.PunctuationConnector ->
                        False

                    Unicode.PunctuationDash ->
                        False

                    Unicode.PunctuationOpen ->
                        False

                    Unicode.PunctuationClose ->
                        False

                    Unicode.PunctuationInitialQuote ->
                        False

                    Unicode.PunctuationFinalQuote ->
                        False

                    Unicode.PunctuationOther ->
                        False

                    Unicode.SymbolMath ->
                        False

                    Unicode.SymbolCurrency ->
                        False

                    Unicode.SymbolModifier ->
                        False

                    Unicode.SymbolOther ->
                        False


charLiteral : Char -> String
charLiteral charContent =
    "'"
        ++ quotedCharToEscaped charContent
        ++ "'"


quotedCharToEscaped : Char -> String
quotedCharToEscaped character =
    case character of
        '\'' ->
            "\\'"

        '\\' ->
            "\\\\"

        '\t' ->
            "\\t"

        '\n' ->
            "\\n"

        '\u{000D}' ->
            "\\r"

        otherCharacter ->
            if characterIsNotPrint otherCharacter then
                "\\u" ++ characterHex otherCharacter

            else
                String.fromChar otherCharacter


charCodeIsLower : Int -> Bool
charCodeIsLower code =
    0x61 <= code && code <= 0x7A


charCodeIsUpper : Int -> Bool
charCodeIsUpper code =
    code <= 0x5A && 0x41 <= code


charCodeIsDigit : Int -> Bool
charCodeIsDigit code =
    code <= 0x39 && 0x30 <= code


charIsLatinAlphaNumOrUnderscoreFast : Char -> Bool
charIsLatinAlphaNumOrUnderscoreFast c =
    let
        code : Int
        code =
            Char.toCode c
    in
    charCodeIsLower code
        || charCodeIsUpper code
        || charCodeIsDigit code
        || -- (c == '_')
           (code == 95)


pattern :
    ElmSyntaxTypeInfer.TypedNode
        ElmSyntaxTypeInfer.Pattern
    ->
        Result
            String
            { pattern : FsharpPattern
            , introducedVariables : FastSet.Set String
            }
pattern patternInferred =
    -- IGNORE TCO
    case patternInferred.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            okFsharpPatternIgnoreIntroducedVariablesSetEmpty

        ElmSyntaxTypeInfer.PatternUnit ->
            okFsharpPatternIgnoreIntroducedVariablesSetEmpty

        ElmSyntaxTypeInfer.PatternChar charValue ->
            Ok
                { pattern = FsharpPatternChar charValue
                , introducedVariables = FastSet.empty
                }

        ElmSyntaxTypeInfer.PatternString stringValue ->
            Ok
                { pattern =
                    FsharpPatternVariant
                        { moduleOrigin = Nothing
                        , name = "StringRopeOne"
                        , values =
                            [ FsharpPatternStringLiteral stringValue ]
                        }
                , introducedVariables = FastSet.empty
                }

        ElmSyntaxTypeInfer.PatternInt intValue ->
            Ok
                { pattern = FsharpPatternInt intValue.value
                , introducedVariables = FastSet.empty
                }

        ElmSyntaxTypeInfer.PatternVariable variableName ->
            let
                disambiguatedVariableName : String
                disambiguatedVariableName =
                    variableName |> variableNameDisambiguateFromFsharpKeywords
            in
            Ok
                { pattern =
                    FsharpPatternVariable disambiguatedVariableName
                , introducedVariables =
                    FastSet.singleton disambiguatedVariableName
                }

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            pattern inParens

        ElmSyntaxTypeInfer.PatternTuple parts ->
            Result.map2
                (\part0 part1 ->
                    { pattern =
                        FsharpPatternTuple
                            { part0 = part0.pattern
                            , part1 = part1.pattern
                            , part2Up = []
                            }
                    , introducedVariables =
                        FastSet.union
                            part0.introducedVariables
                            part1.introducedVariables
                    }
                )
                (parts.part0 |> pattern)
                (parts.part1 |> pattern)

        ElmSyntaxTypeInfer.PatternTriple parts ->
            Result.map3
                (\part0 part1 part2 ->
                    { pattern =
                        FsharpPatternTuple
                            { part0 = part0.pattern
                            , part1 = part1.pattern
                            , part2Up = [ part2.pattern ]
                            }
                    , introducedVariables =
                        FastSet.union
                            part0.introducedVariables
                            (FastSet.union
                                part1.introducedVariables
                                part2.introducedVariables
                            )
                    }
                )
                (parts.part0 |> pattern)
                (parts.part1 |> pattern)
                (parts.part2 |> pattern)

        ElmSyntaxTypeInfer.PatternRecord fields ->
            let
                fieldNames :
                    { fields : FastDict.Dict String FsharpPattern
                    , introducedVariables : FastSet.Set String
                    }
                fieldNames =
                    fields
                        |> List.foldl
                            (\fieldTypedNode soFar ->
                                let
                                    introducedVariableName : String
                                    introducedVariableName =
                                        fieldTypedNode.value
                                            |> variableNameDisambiguateFromFsharpKeywords
                                in
                                { fields =
                                    soFar.fields
                                        |> FastDict.insert
                                            (fieldTypedNode.value |> stringFirstCharToUpper)
                                            (FsharpPatternVariable
                                                introducedVariableName
                                            )
                                , introducedVariables =
                                    soFar.introducedVariables
                                        |> FastSet.insert introducedVariableName
                                }
                            )
                            { fields = FastDict.empty
                            , introducedVariables = FastSet.empty
                            }
            in
            Ok
                { pattern = FsharpPatternRecordInexhaustive fieldNames.fields
                , introducedVariables = fieldNames.introducedVariables
                }

        ElmSyntaxTypeInfer.PatternListCons listCons ->
            resultAndThen2
                (\head tail ->
                    let
                        introducedVariables : FastSet.Set String
                        introducedVariables =
                            FastSet.union
                                head.introducedVariables
                                tail.introducedVariables
                    in
                    Ok
                        { pattern =
                            FsharpPatternListCons
                                { head = head.pattern
                                , tail = tail.pattern
                                }
                        , introducedVariables = introducedVariables
                        }
                )
                (listCons.head |> pattern)
                (listCons.tail |> pattern)

        ElmSyntaxTypeInfer.PatternListExact elementPatterns ->
            Result.map
                (\elements ->
                    { pattern =
                        FsharpPatternListExact (elements |> List.map .pattern)
                    , introducedVariables =
                        elements
                            |> listMapToFastSetsAndUnify .introducedVariables
                    }
                )
                (elementPatterns
                    |> listMapAndCombineOk
                        (\element -> element |> pattern)
                )

        ElmSyntaxTypeInfer.PatternVariant variant ->
            Result.map
                (\values ->
                    let
                        reference : { moduleOrigin : Maybe String, name : String }
                        reference =
                            case
                                { moduleOrigin = variant.moduleOrigin
                                , name = variant.name
                                , type_ = patternInferred.type_
                                }
                                    |> referenceToCoreFsharp
                            of
                                Just fsharpReference ->
                                    fsharpReference

                                Nothing ->
                                    { moduleOrigin = Nothing
                                    , name =
                                        referenceToFsharpName
                                            { moduleOrigin = variant.moduleOrigin
                                            , name = variant.name
                                            }
                                    }
                    in
                    { pattern =
                        FsharpPatternVariant
                            { moduleOrigin = reference.moduleOrigin
                            , name = reference.name
                            , values = values |> List.map .pattern
                            }
                    , introducedVariables =
                        values
                            |> listMapToFastSetsAndUnify .introducedVariables
                    }
                )
                (variant.values
                    |> listMapAndCombineOk
                        (\argument -> argument |> pattern)
                )

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            Result.map
                (\aliasedPattern ->
                    let
                        variableDisambiguated : String
                        variableDisambiguated =
                            patternAs.variable.value |> variableNameDisambiguateFromFsharpKeywords
                    in
                    { pattern =
                        FsharpPatternAs
                            { pattern = aliasedPattern.pattern
                            , variable = variableDisambiguated
                            }
                    , introducedVariables =
                        aliasedPattern.introducedVariables
                            |> FastSet.insert variableDisambiguated
                    }
                )
                (patternAs.pattern |> pattern)


okFsharpPatternIgnoreIntroducedVariablesSetEmpty :
    Result
        error_
        { pattern : FsharpPattern
        , introducedVariables : FastSet.Set String
        }
okFsharpPatternIgnoreIntroducedVariablesSetEmpty =
    Ok
        { pattern = FsharpPatternIgnore
        , introducedVariables = FastSet.empty
        }


typedPattern :
    ElmSyntaxTypeInfer.TypedNode
        ElmSyntaxTypeInfer.Pattern
    ->
        Result
            String
            { pattern : FsharpPattern
            , type_ : FsharpType
            , introducedVariables : FastSet.Set String
            }
typedPattern patternTypedNode =
    Result.map
        (\fsharpPattern ->
            { pattern = fsharpPattern.pattern
            , type_ = patternTypedNode.type_ |> type_
            , introducedVariables = fsharpPattern.introducedVariables
            }
        )
        (patternTypedNode |> pattern)


printFsharpPatternListCons :
    { head : FsharpPattern
    , tail : FsharpPattern
    }
    -> Print
printFsharpPatternListCons syntaxCons =
    printFsharpPatternParenthesizedIfSpaceSeparated
        syntaxCons.head
        |> Print.followedBy
            printExactlySpaceColonColonSpace
        |> Print.followedBy
            (printFsharpPatternParenthesizedIfSpaceSeparated
                syntaxCons.tail
            )


printExactlySpaceColonColonSpace : Print
printExactlySpaceColonColonSpace =
    Print.exactly " :: "


typeConstructReferenceToCoreFsharp :
    { moduleOrigin : String
    , name : String
    }
    ->
        Maybe
            { moduleOrigin : Maybe String
            , name : String
            }
typeConstructReferenceToCoreFsharp reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "Order" ->
                    Just { moduleOrigin = Nothing, name = "Basics_Order" }

                "Bool" ->
                    Just { moduleOrigin = Nothing, name = "bool" }

                "Int" ->
                    Just { moduleOrigin = Nothing, name = "int64" }

                "Float" ->
                    Just { moduleOrigin = Nothing, name = "float" }

                "Never" ->
                    Just { moduleOrigin = Nothing, name = "Basics_Never" }

                _ ->
                    Nothing

        "String" ->
            case reference.name of
                "String" ->
                    Just { moduleOrigin = Nothing, name = "StringRope" }

                _ ->
                    Nothing

        "Char" ->
            case reference.name of
                "Char" ->
                    Just { moduleOrigin = Nothing, name = "char" }

                _ ->
                    Nothing

        "List" ->
            case reference.name of
                "List" ->
                    Just { moduleOrigin = Nothing, name = "List" }

                _ ->
                    Nothing

        "Dict" ->
            case reference.name of
                "Dict" ->
                    Just { moduleOrigin = Nothing, name = "Map" }

                _ ->
                    Nothing

        "Set" ->
            case reference.name of
                "Set" ->
                    Just { moduleOrigin = Nothing, name = "Set" }

                _ ->
                    Nothing

        "Array" ->
            case reference.name of
                "Array" ->
                    Just { moduleOrigin = Nothing, name = "array" }

                _ ->
                    Nothing

        "Maybe" ->
            case reference.name of
                "Maybe" ->
                    Just { moduleOrigin = Nothing, name = "ValueOption" }

                _ ->
                    Nothing

        "Result" ->
            case reference.name of
                "Result" ->
                    Just { moduleOrigin = Nothing, name = "Result_Result" }

                _ ->
                    Nothing

        "Json.Encode" ->
            case reference.name of
                "Value" ->
                    Just { moduleOrigin = Just "System.Text.Json.Nodes", name = "JsonNode" }

                _ ->
                    Nothing

        "Json.Decode" ->
            case reference.name of
                "Value" ->
                    Just { moduleOrigin = Just "System.Text.Json.Nodes", name = "JsonNode" }

                "Decoder" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_Decoder" }

                "Error" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_Error" }

                _ ->
                    Nothing

        "Regex" ->
            case reference.name of
                "Regex" ->
                    Just { moduleOrigin = Just "System.Text.RegularExpressions", name = "Regex" }

                "Options" ->
                    Just { moduleOrigin = Nothing, name = "Regex_Options" }

                "Match" ->
                    Just { moduleOrigin = Nothing, name = "Regex_Match" }

                _ ->
                    Nothing

        "Random" ->
            case reference.name of
                "Seed" ->
                    Just { moduleOrigin = Nothing, name = "Random_Seed" }

                "Generator" ->
                    Just { moduleOrigin = Nothing, name = "Random_Generator" }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "Posix" ->
                    Just { moduleOrigin = Nothing, name = "Time_Posix" }

                "Zone" ->
                    Just { moduleOrigin = Nothing, name = "Time_Zone" }

                "Month" ->
                    Just { moduleOrigin = Nothing, name = "Time_Month" }

                "Weekday" ->
                    Just { moduleOrigin = Nothing, name = "Time_Weekday" }

                "Time_ZoneName" ->
                    Just { moduleOrigin = Nothing, name = "Time_ZoneName" }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "Endianness" ->
                    Just { moduleOrigin = Nothing, name = "Bytes_Endianness" }

                "Bytes" ->
                    Just { moduleOrigin = Nothing, name = "Bytes_Bytes" }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "Decoder" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_Decoder" }

                "Step" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_Step" }

                _ ->
                    Nothing

        "Bytes.Encode" ->
            case reference.name of
                "Encoder" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_Encoder" }

                _ ->
                    Nothing

        "VirtualDom" ->
            case reference.name of
                "Node" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_Node" }

                "Attribute" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_Attribute" }

                "Handler" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_Handler" }

                _ ->
                    Nothing

        "Math.Vector2" ->
            case reference.name of
                "Vec2" ->
                    Just { moduleOrigin = Just "System.Numerics", name = "Vector2" }

                _ ->
                    Nothing

        "Math.Vector3" ->
            case reference.name of
                "Vec3" ->
                    Just { moduleOrigin = Just "System.Numerics", name = "Vector3" }

                _ ->
                    Nothing

        "Math.Vector4" ->
            case reference.name of
                "Vec4" ->
                    Just { moduleOrigin = Just "System.Numerics", name = "Vector4" }

                _ ->
                    Nothing

        "Math.Matrix4" ->
            case reference.name of
                "Mat4" ->
                    Just { moduleOrigin = Just "System.Numerics", name = "Matrix4x4" }

                _ ->
                    Nothing

        "Platform" ->
            case reference.name of
                "Program" ->
                    Just { moduleOrigin = Nothing, name = "Platform_Program" }

                _ ->
                    Nothing

        "Platform.Cmd" ->
            case reference.name of
                "Cmd" ->
                    Just { moduleOrigin = Nothing, name = "PlatformCmd_Cmd" }

                _ ->
                    Nothing

        "Platform.Sub" ->
            case reference.name of
                "Sub" ->
                    Just { moduleOrigin = Nothing, name = "PlatformSub_Sub" }

                _ ->
                    Nothing

        _ ->
            Nothing


{-| Use `typeConstructReferenceToCoreFsharp` for types
-}
referenceToCoreFsharp :
    { moduleOrigin : String
    , name : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Maybe
            { moduleOrigin : Maybe String
            , name : String
            }
referenceToCoreFsharp reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "identity" ->
                    Just { moduleOrigin = Nothing, name = "id" }

                "always" ->
                    Just { moduleOrigin = Nothing, name = "Basics_always" }

                "compare" ->
                    Just { moduleOrigin = Nothing, name = "Basics_compare" }

                "max" ->
                    Just { moduleOrigin = Nothing, name = "max" }

                "min" ->
                    Just { moduleOrigin = Nothing, name = "min" }

                "LT" ->
                    Just { moduleOrigin = Just "Basics_Order", name = "LT" }

                "EQ" ->
                    Just { moduleOrigin = Just "Basics_Order", name = "EQ" }

                "GT" ->
                    Just { moduleOrigin = Just "Basics_Order", name = "GT" }

                "True" ->
                    Just { moduleOrigin = Nothing, name = "true" }

                "False" ->
                    Just { moduleOrigin = Nothing, name = "false" }

                "not" ->
                    Just { moduleOrigin = Nothing, name = "not" }

                "xor" ->
                    Just { moduleOrigin = Nothing, name = "Basics_neq" }

                "e" ->
                    Just { moduleOrigin = Just "System.Double", name = "E" }

                "pi" ->
                    Just { moduleOrigin = Just "System.Double", name = "Pi" }

                "ceiling" ->
                    Just { moduleOrigin = Nothing, name = "Basics_ceiling" }

                "floor" ->
                    Just { moduleOrigin = Nothing, name = "Basics_floor" }

                "round" ->
                    Just { moduleOrigin = Nothing, name = "Basics_round" }

                "truncate" ->
                    Just { moduleOrigin = Nothing, name = "int64" }

                "negate" ->
                    case reference.type_ of
                        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                            if typeFunction.input == inferredTypeBasicsFloat then
                                Just { moduleOrigin = Nothing, name = "Basics_fnegate" }

                            else
                                case typeFunction.input of
                                    ElmSyntaxTypeInfer.TypeVariable typeVariable ->
                                        if typeVariable.name |> String.startsWith "number" then
                                            -- assume Float
                                            Just { moduleOrigin = Nothing, name = "Basics_fnegate" }

                                        else
                                            -- assume Int
                                            Just { moduleOrigin = Nothing, name = "Basics_inegate" }

                                    _ ->
                                        -- assume Int
                                        Just { moduleOrigin = Nothing, name = "Basics_inegate" }

                        _ ->
                            -- assume Int
                            Just { moduleOrigin = Nothing, name = "Basics_inegate" }

                "abs" ->
                    case reference.type_ of
                        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                            if typeFunction.input == inferredTypeBasicsFloat then
                                Just { moduleOrigin = Nothing, name = "Basics_fabs" }

                            else
                                case typeFunction.input of
                                    ElmSyntaxTypeInfer.TypeVariable typeVariable ->
                                        if typeVariable.name |> String.startsWith "number" then
                                            -- assume Float
                                            Just { moduleOrigin = Nothing, name = "Basics_fabs" }

                                        else
                                            -- assume Int
                                            Just { moduleOrigin = Nothing, name = "Basics_iabs" }

                                    _ ->
                                        -- assume Int
                                        Just { moduleOrigin = Nothing, name = "Basics_iabs" }

                        _ ->
                            -- assume Int
                            Just { moduleOrigin = Nothing, name = "Basics_iabs" }

                "toFloat" ->
                    Just { moduleOrigin = Nothing, name = "float" }

                "isNaN" ->
                    Just { moduleOrigin = Just "System.Double", name = "IsNaN" }

                "isInfinite" ->
                    Just { moduleOrigin = Just "System.Double", name = "IsInfinity" }

                "remainderBy" ->
                    Just { moduleOrigin = Nothing, name = "Basics_remainderBy" }

                "modBy" ->
                    Just { moduleOrigin = Nothing, name = "Basics_modBy" }

                "sin" ->
                    Just { moduleOrigin = Just "System.Double", name = "Sin" }

                "cos" ->
                    Just { moduleOrigin = Just "System.Double", name = "Cos" }

                "tan" ->
                    Just { moduleOrigin = Just "System.Double", name = "Tan" }

                "asin" ->
                    Just { moduleOrigin = Just "System.Double", name = "Asin" }

                "acos" ->
                    Just { moduleOrigin = Just "System.Double", name = "Acos" }

                "atan" ->
                    Just { moduleOrigin = Just "System.Double", name = "Atan" }

                "atan2" ->
                    Just { moduleOrigin = Nothing, name = "Basics_atan2" }

                "sqrt" ->
                    Just { moduleOrigin = Just "System.Double", name = "Sqrt" }

                "logBase" ->
                    Just { moduleOrigin = Nothing, name = "Basics_logBase" }

                "radians" ->
                    Just { moduleOrigin = Nothing, name = "Basics_radians" }

                "degrees" ->
                    Just { moduleOrigin = Nothing, name = "Basics_degrees" }

                "turns" ->
                    Just { moduleOrigin = Nothing, name = "Basics_turns" }

                "fromPolar" ->
                    Just { moduleOrigin = Nothing, name = "Basics_fromPolar" }

                "toPolar" ->
                    Just { moduleOrigin = Nothing, name = "Basics_toPolar" }

                "clamp" ->
                    case reference.type_ of
                        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                            if typeFunction.input == inferredTypeBasicsFloat then
                                Just { moduleOrigin = Nothing, name = "Basics_fclamp" }

                            else
                                case typeFunction.input of
                                    ElmSyntaxTypeInfer.TypeVariable typeVariable ->
                                        if typeVariable.name |> String.startsWith "number" then
                                            -- assume Float
                                            Just { moduleOrigin = Nothing, name = "Basics_fclamp" }

                                        else
                                            -- assume Int
                                            Just { moduleOrigin = Nothing, name = "Basics_iclamp" }

                                    _ ->
                                        -- assume Int
                                        Just { moduleOrigin = Nothing, name = "Basics_iclamp" }

                        _ ->
                            -- assume Int
                            Just { moduleOrigin = Nothing, name = "Basics_iclamp" }

                "never" ->
                    Just { moduleOrigin = Nothing, name = "Basics_never" }

                _ ->
                    Nothing

        "Bitwise" ->
            case reference.name of
                "complement" ->
                    Just { moduleOrigin = Nothing, name = "(~~~)" }

                "and" ->
                    Just { moduleOrigin = Nothing, name = "(&&&)" }

                "or" ->
                    Just { moduleOrigin = Nothing, name = "(|||)" }

                "xor" ->
                    Just { moduleOrigin = Nothing, name = "(^^^)" }

                "shiftLeftBy" ->
                    Just { moduleOrigin = Nothing, name = "Bitwise_shiftLeftBy" }

                "shiftRightBy" ->
                    Just { moduleOrigin = Nothing, name = "Bitwise_shiftRightBy" }

                "shiftRightZfBy" ->
                    Just { moduleOrigin = Nothing, name = "Bitwise_shiftRightZfBy" }

                _ ->
                    Nothing

        "String" ->
            case reference.name of
                "isEmpty" ->
                    Just { moduleOrigin = Nothing, name = "String_isEmpty" }

                "length" ->
                    Just { moduleOrigin = Nothing, name = "String_length" }

                "append" ->
                    Just { moduleOrigin = Nothing, name = "String_concat" }

                "trim" ->
                    Just { moduleOrigin = Nothing, name = "String_trim" }

                "trimLeft" ->
                    Just { moduleOrigin = Nothing, name = "String_trimLeft" }

                "trimRight" ->
                    Just { moduleOrigin = Nothing, name = "String_trimRight" }

                "left" ->
                    Just { moduleOrigin = Nothing, name = "String_left" }

                "right" ->
                    Just { moduleOrigin = Nothing, name = "String_right" }

                "dropLeft" ->
                    Just { moduleOrigin = Nothing, name = "String_dropLeft" }

                "dropRight" ->
                    Just { moduleOrigin = Nothing, name = "String_dropRight" }

                "padLeft" ->
                    Just { moduleOrigin = Nothing, name = "String_padLeft" }

                "padRight" ->
                    Just { moduleOrigin = Nothing, name = "String_padRight" }

                "replace" ->
                    Just { moduleOrigin = Nothing, name = "String_replace" }

                "toList" ->
                    Just { moduleOrigin = Nothing, name = "String_toList" }

                "foldl" ->
                    Just { moduleOrigin = Nothing, name = "String_foldl" }

                "foldr" ->
                    Just { moduleOrigin = Nothing, name = "String_foldr" }

                "join" ->
                    Just { moduleOrigin = Nothing, name = "String_join" }

                "filter" ->
                    Just { moduleOrigin = Nothing, name = "String_filter" }

                "any" ->
                    Just { moduleOrigin = Nothing, name = "String_any" }

                "all" ->
                    Just { moduleOrigin = Nothing, name = "String_all" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "String_map" }

                "repeat" ->
                    Just { moduleOrigin = Nothing, name = "String_repeat" }

                "split" ->
                    Just { moduleOrigin = Nothing, name = "String_split" }

                "lines" ->
                    Just { moduleOrigin = Nothing, name = "String_lines" }

                "startsWith" ->
                    Just { moduleOrigin = Nothing, name = "String_startsWith" }

                "endsWith" ->
                    Just { moduleOrigin = Nothing, name = "String_endsWith" }

                "toInt" ->
                    Just { moduleOrigin = Nothing, name = "String_toInt" }

                "toFloat" ->
                    Just { moduleOrigin = Nothing, name = "String_toFloat" }

                "fromInt" ->
                    Just { moduleOrigin = Nothing, name = "String_fromInt" }

                "fromFloat" ->
                    Just { moduleOrigin = Nothing, name = "String_fromFloat" }

                "contains" ->
                    Just { moduleOrigin = Nothing, name = "String_contains" }

                "fromChar" ->
                    Just { moduleOrigin = Nothing, name = "String_fromChar" }

                "cons" ->
                    Just { moduleOrigin = Nothing, name = "String_cons" }

                "uncons" ->
                    Just { moduleOrigin = Nothing, name = "String_uncons" }

                "slice" ->
                    Just { moduleOrigin = Nothing, name = "String_slice" }

                "toLower" ->
                    Just { moduleOrigin = Nothing, name = "String_toLower" }

                "toUpper" ->
                    Just { moduleOrigin = Nothing, name = "String_toUpper" }

                _ ->
                    Nothing

        "Char" ->
            case reference.name of
                "toCode" ->
                    Just { moduleOrigin = Nothing, name = "int64" }

                "fromCode" ->
                    Just { moduleOrigin = Nothing, name = "char" }

                "toLower" ->
                    Just { moduleOrigin = Just "System.Char", name = "ToLowerInvariant" }

                "toUpper" ->
                    Just { moduleOrigin = Just "System.Char", name = "ToUpperInvariant" }

                "toLocaleLower" ->
                    Just { moduleOrigin = Just "System.Char", name = "ToLower" }

                "toLocaleUpper" ->
                    Just { moduleOrigin = Just "System.Char", name = "ToUpper" }

                "isLower" ->
                    Just { moduleOrigin = Just "System.Char", name = "IsAsciiLetterLower" }

                "isUpper" ->
                    Just { moduleOrigin = Just "System.Char", name = "IsAsciiLetterUpper" }

                "isHexDigit" ->
                    Just { moduleOrigin = Just "System.Char", name = "IsAsciiHexDigit" }

                "isOctDigit" ->
                    Just { moduleOrigin = Just "System.Char", name = "Char_isOctDigit" }

                "isDigit" ->
                    Just { moduleOrigin = Just "System.Char", name = "IsAsciiDigit" }

                "isAlpha" ->
                    Just { moduleOrigin = Just "System.Char", name = "IsAsciiLetter" }

                "isAlphaNum" ->
                    Just { moduleOrigin = Just "System.Char", name = "IsAsciiLetterOrDigit" }

                _ ->
                    Nothing

        "List" ->
            case reference.name of
                "singleton" ->
                    Just { moduleOrigin = Just "List", name = "singleton" }

                "isEmpty" ->
                    Just { moduleOrigin = Just "List", name = "isEmpty" }

                "length" ->
                    Just { moduleOrigin = Nothing, name = "List_length" }

                "member" ->
                    Just { moduleOrigin = Nothing, name = "List_member" }

                "minimum" ->
                    Just { moduleOrigin = Nothing, name = "List_minimum" }

                "maximum" ->
                    Just { moduleOrigin = Nothing, name = "List_maximum" }

                "sum" ->
                    Just { moduleOrigin = Just "List", name = "sum" }

                "product" ->
                    case reference.type_ of
                        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                            if typeFunction.output == inferredTypeBasicsFloat then
                                Just { moduleOrigin = Nothing, name = "List_fproduct" }

                            else
                                case typeFunction.output of
                                    ElmSyntaxTypeInfer.TypeVariable outputTypeVariable ->
                                        if outputTypeVariable.name |> String.startsWith "number" then
                                            -- assume Float
                                            Just { moduleOrigin = Nothing, name = "List_fproduct" }

                                        else
                                            -- assume Int
                                            Just { moduleOrigin = Nothing, name = "List_iproduct" }

                                    _ ->
                                        -- assume Int
                                        Just { moduleOrigin = Nothing, name = "List_iproduct" }

                        _ ->
                            -- assume Int
                            Just { moduleOrigin = Nothing, name = "List_iproduct" }

                "append" ->
                    Just { moduleOrigin = Just "List", name = "append" }

                "concat" ->
                    Just { moduleOrigin = Just "List", name = "concat" }

                "reverse" ->
                    Just { moduleOrigin = Just "List", name = "rev" }

                "repeat" ->
                    Just { moduleOrigin = Nothing, name = "List_repeat" }

                "head" ->
                    Just { moduleOrigin = Nothing, name = "List_head" }

                "tail" ->
                    Just { moduleOrigin = Nothing, name = "List_tail" }

                "all" ->
                    Just { moduleOrigin = Just "List", name = "forall" }

                "any" ->
                    Just { moduleOrigin = Just "List", name = "exists" }

                "filter" ->
                    Just { moduleOrigin = Just "List", name = "filter" }

                "filterMap" ->
                    Just { moduleOrigin = Nothing, name = "List_filterMap" }

                "map" ->
                    Just { moduleOrigin = Just "List", name = "map" }

                "indexedMap" ->
                    Just { moduleOrigin = Just "List", name = "mapi" }

                "map2" ->
                    Just { moduleOrigin = Just "List", name = "map2" }

                "zip" ->
                    Just { moduleOrigin = Just "List", name = "zip" }

                "map3" ->
                    Just { moduleOrigin = Just "List", name = "map3" }

                "map4" ->
                    Just { moduleOrigin = Nothing, name = "List_map4" }

                "map5" ->
                    Just { moduleOrigin = Nothing, name = "List_map5" }

                "unzip" ->
                    Just { moduleOrigin = Just "List", name = "unzip" }

                "concatMap" ->
                    Just { moduleOrigin = Just "List", name = "collect" }

                "sort" ->
                    Just { moduleOrigin = Just "List", name = "sort" }

                "sortBy" ->
                    Just { moduleOrigin = Just "List", name = "sortBy" }

                "sortWith" ->
                    Just { moduleOrigin = Nothing, name = "List_sortWith" }

                "range" ->
                    Just { moduleOrigin = Nothing, name = "List_range" }

                "take" ->
                    Just { moduleOrigin = Nothing, name = "List_take" }

                "drop" ->
                    Just { moduleOrigin = Nothing, name = "List_drop" }

                "intersperse" ->
                    Just { moduleOrigin = Nothing, name = "List_intersperse" }

                "foldl" ->
                    Just { moduleOrigin = Nothing, name = "List_foldl" }

                "foldr" ->
                    Just { moduleOrigin = Nothing, name = "List_foldr" }

                _ ->
                    Nothing

        "Maybe" ->
            case reference.name of
                "Nothing" ->
                    Just { moduleOrigin = Nothing, name = "ValueNone" }

                "Just" ->
                    Just { moduleOrigin = Nothing, name = "ValueSome" }

                "withDefault" ->
                    Just { moduleOrigin = Just "ValueOption", name = "defaultValue" }

                "map" ->
                    Just { moduleOrigin = Just "ValueOption", name = "map" }

                "map2" ->
                    Just { moduleOrigin = Just "ValueOption", name = "map2" }

                "map3" ->
                    Just { moduleOrigin = Just "ValueOption", name = "map3" }

                "map4" ->
                    Just { moduleOrigin = Nothing, name = "Maybe_map4" }

                "map5" ->
                    Just { moduleOrigin = Nothing, name = "Maybe_map5" }

                "andThen" ->
                    Just { moduleOrigin = Just "ValueOption", name = "bind" }

                _ ->
                    Nothing

        "Result" ->
            case reference.name of
                "Err" ->
                    Just { moduleOrigin = Nothing, name = "Error" }

                "Ok" ->
                    Just { moduleOrigin = Nothing, name = "Ok" }

                "map" ->
                    Just { moduleOrigin = Just "Result", name = "map" }

                "map2" ->
                    Just { moduleOrigin = Nothing, name = "Result_map2" }

                "map3" ->
                    Just { moduleOrigin = Nothing, name = "Result_map3" }

                "map4" ->
                    Just { moduleOrigin = Nothing, name = "Result_map4" }

                "map5" ->
                    Just { moduleOrigin = Nothing, name = "Result_map5" }

                "andThen" ->
                    Just { moduleOrigin = Just "Result", name = "bind" }

                "withDefault" ->
                    Just { moduleOrigin = Just "Result", name = "defaultValue" }

                "toMaybe" ->
                    Just { moduleOrigin = Just "Result", name = "toValueOption" }

                "fromMaybe" ->
                    Just { moduleOrigin = Nothing, name = "Result_fromMaybe" }

                "mapError" ->
                    Just { moduleOrigin = Just "Result", name = "mapError" }

                _ ->
                    Nothing

        "Array" ->
            case reference.name of
                "isEmpty" ->
                    Just { moduleOrigin = Just "Array", name = "iEmpty" }

                "length" ->
                    Just { moduleOrigin = Nothing, name = "Array_length" }

                "get" ->
                    Just { moduleOrigin = Nothing, name = "Array_get" }

                "empty" ->
                    Just { moduleOrigin = Just "Array", name = "empty" }

                "initialize" ->
                    Just { moduleOrigin = Nothing, name = "Array_initialize" }

                "repeat" ->
                    Just { moduleOrigin = Nothing, name = "Array_repeat" }

                "fromList" ->
                    Just { moduleOrigin = Just "Array", name = "ofList" }

                "reverse" ->
                    Just { moduleOrigin = Just "Array", name = "rev" }

                "filter" ->
                    Just { moduleOrigin = Just "Array", name = "filter" }

                "push" ->
                    Just { moduleOrigin = Nothing, name = "Array_push" }

                "set" ->
                    Just { moduleOrigin = Nothing, name = "Array_set" }

                "slice" ->
                    Just { moduleOrigin = Nothing, name = "Array_slice" }

                "map" ->
                    Just { moduleOrigin = Just "Array", name = "map" }

                "indexedMap" ->
                    Just { moduleOrigin = Nothing, name = "Array_indexedMap" }

                "append" ->
                    Just { moduleOrigin = Just "Array", name = "append" }

                "toList" ->
                    Just { moduleOrigin = Just "Array", name = "toList" }

                "toIndexedList" ->
                    Just { moduleOrigin = Nothing, name = "Array_toIndexedList" }

                "foldl" ->
                    Just { moduleOrigin = Nothing, name = "Array_foldl" }

                "foldr" ->
                    Just { moduleOrigin = Nothing, name = "Array_foldr" }

                _ ->
                    Nothing

        "Dict" ->
            case reference.name of
                "size" ->
                    Just { moduleOrigin = Nothing, name = "Dict_size" }

                "empty" ->
                    Just { moduleOrigin = Just "Map", name = "empty" }

                "singleton" ->
                    Just { moduleOrigin = Nothing, name = "Dict_singleton" }

                "fromList" ->
                    Just { moduleOrigin = Nothing, name = "Dict_fromList" }

                "toList" ->
                    Just { moduleOrigin = Nothing, name = "Dict_toList" }

                "keys" ->
                    Just { moduleOrigin = Nothing, name = "Dict_keys" }

                "values" ->
                    Just { moduleOrigin = Nothing, name = "Dict_values" }

                "isEmpty" ->
                    Just { moduleOrigin = Just "Map", name = "isEmpty" }

                "map" ->
                    Just { moduleOrigin = Just "Map", name = "map" }

                "partition" ->
                    Just { moduleOrigin = Just "Map", name = "partition" }

                "foldl" ->
                    Just { moduleOrigin = Nothing, name = "Dict_foldl" }

                "foldr" ->
                    Just { moduleOrigin = Nothing, name = "Dict_foldr" }

                "filter" ->
                    Just { moduleOrigin = Just "Map", name = "filter" }

                "get" ->
                    Just { moduleOrigin = Nothing, name = "Dict_get" }

                "member" ->
                    Just { moduleOrigin = Just "Map", name = "containsKey" }

                "insert" ->
                    Just { moduleOrigin = Just "Map", name = "add" }

                "update" ->
                    Just { moduleOrigin = Nothing, name = "Dict_update" }

                "remove" ->
                    Just { moduleOrigin = Just "Map", name = "remove" }

                "union" ->
                    Just { moduleOrigin = Nothing, name = "Dict_union" }

                "diff" ->
                    Just { moduleOrigin = Nothing, name = "Dict_diff" }

                "intersect" ->
                    Just { moduleOrigin = Nothing, name = "Dict_intersect" }

                "merge" ->
                    Just { moduleOrigin = Nothing, name = "Dict_merge" }

                _ ->
                    Nothing

        "Set" ->
            case reference.name of
                "size" ->
                    Just { moduleOrigin = Nothing, name = "Set_size" }

                "empty" ->
                    Just { moduleOrigin = Just "Set", name = "empty" }

                "singleton" ->
                    Just { moduleOrigin = Just "Set", name = "singleton" }

                "fromList" ->
                    Just { moduleOrigin = Just "Set", name = "ofList" }

                "toList" ->
                    Just { moduleOrigin = Just "Set", name = "toList" }

                "isEmpty" ->
                    Just { moduleOrigin = Just "Set", name = "isEmpty" }

                "insert" ->
                    Just { moduleOrigin = Just "Set", name = "add" }

                "partition" ->
                    Just { moduleOrigin = Just "Set", name = "partition" }

                "foldl" ->
                    Just { moduleOrigin = Nothing, name = "Set_foldl" }

                "foldr" ->
                    Just { moduleOrigin = Nothing, name = "Set_foldr" }

                "filter" ->
                    Just { moduleOrigin = Just "Set", name = "filter" }

                "member" ->
                    Just { moduleOrigin = Just "Set", name = "contains" }

                "remove" ->
                    Just { moduleOrigin = Just "Set", name = "remove" }

                "union" ->
                    Just { moduleOrigin = Just "Set", name = "union" }

                "diff" ->
                    Just { moduleOrigin = Just "Set", name = "difference" }

                "intersect" ->
                    Just { moduleOrigin = Just "Set", name = "intersect" }

                _ ->
                    Nothing

        "Json.Encode" ->
            case reference.name of
                "encode" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_encode" }

                "null" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_null" }

                "bool" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_bool" }

                "string" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_string" }

                "int" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_int" }

                "float" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_float" }

                "list" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_list" }

                "array" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_array" }

                "set" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_set" }

                "object" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_object" }

                "dict" ->
                    Just { moduleOrigin = Nothing, name = "JsonEncode_dict" }

                _ ->
                    Nothing

        "Json.Decode" ->
            case reference.name of
                "Field" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_Field" }

                "Index" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_Index" }

                "OneOf" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_OneOf" }

                "Failure" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_Failure" }

                "string" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_string" }

                "bool" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_bool" }

                "int" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_int" }

                "float" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_float" }

                "nullable" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_nullable" }

                "list" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_list" }

                "array" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_array" }

                "dict" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_dict" }

                "keyValuePairs" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_keyValuePairs" }

                "oneOrMore" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_oneOrMore" }

                "field" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_field" }

                "at" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_at" }

                "index" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_index" }

                "maybe" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_maybe" }

                "oneOf" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_oneOf" }

                "decodeString" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_decodeString" }

                "decodeValue" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_decodeValue" }

                "errorToString" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_errorToString" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map" }

                "map2" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map2" }

                "map3" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map3" }

                "map4" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map4" }

                "map5" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map5" }

                "map6" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map6" }

                "map7" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map7" }

                "map8" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_map8" }

                "lazy" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_lazy" }

                "value" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_value" }

                "null" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_null" }

                "succeed" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_succeed" }

                "fail" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_fail" }

                "andThen" ->
                    Just { moduleOrigin = Nothing, name = "JsonDecode_andThen" }

                _ ->
                    Nothing

        "Regex" ->
            case reference.name of
                "fromString" ->
                    Just { moduleOrigin = Nothing, name = "Regex_fromString" }

                "fromStringWith" ->
                    Just { moduleOrigin = Nothing, name = "Regex_fromStringWith" }

                "never" ->
                    Just { moduleOrigin = Nothing, name = "Regex_never" }

                "contains" ->
                    Just { moduleOrigin = Nothing, name = "Regex_contains" }

                "split" ->
                    Just { moduleOrigin = Nothing, name = "Regex_split" }

                "find" ->
                    Just { moduleOrigin = Nothing, name = "Regex_find" }

                "replace" ->
                    Just { moduleOrigin = Nothing, name = "Regex_replace" }

                "splitAtMost" ->
                    Just { moduleOrigin = Nothing, name = "Regex_splitAtMost" }

                "findAtMost" ->
                    Just { moduleOrigin = Nothing, name = "Regex_findAtMost" }

                "replaceAtMost" ->
                    Just { moduleOrigin = Nothing, name = "Regex_replaceAtMost" }

                _ ->
                    Nothing

        "Random" ->
            case reference.name of
                "int" ->
                    Just { moduleOrigin = Nothing, name = "Random_int" }

                "float" ->
                    Just { moduleOrigin = Nothing, name = "Random_float" }

                "uniform" ->
                    Just { moduleOrigin = Nothing, name = "Random_uniform" }

                "weighted" ->
                    Just { moduleOrigin = Nothing, name = "Random_weighted" }

                "constant" ->
                    Just { moduleOrigin = Nothing, name = "Random_constant" }

                "list" ->
                    Just { moduleOrigin = Nothing, name = "Random_list" }

                "pair" ->
                    Just { moduleOrigin = Nothing, name = "Random_pair" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "Random_map" }

                "map2" ->
                    Just { moduleOrigin = Nothing, name = "Random_map2" }

                "map3" ->
                    Just { moduleOrigin = Nothing, name = "Random_map3" }

                "map4" ->
                    Just { moduleOrigin = Nothing, name = "Random_map4" }

                "map5" ->
                    Just { moduleOrigin = Nothing, name = "Random_map5" }

                "andThen" ->
                    Just { moduleOrigin = Nothing, name = "Random_andThen" }

                "lazy" ->
                    Just { moduleOrigin = Nothing, name = "Random_lazy" }

                "minInt" ->
                    Just { moduleOrigin = Nothing, name = "Random_minInt" }

                "maxInt" ->
                    Just { moduleOrigin = Nothing, name = "Random_maxInt" }

                "step" ->
                    Just { moduleOrigin = Nothing, name = "Random_step" }

                "initialSeed" ->
                    Just { moduleOrigin = Nothing, name = "Random_initialSeed" }

                "independentSeed" ->
                    Just { moduleOrigin = Nothing, name = "Random_independentSeed" }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "posixToMillis" ->
                    Just { moduleOrigin = Nothing, name = "Time_posixToMillis" }

                "millisToPosix" ->
                    Just { moduleOrigin = Nothing, name = "Time_millisToPosix" }

                "utc" ->
                    Just { moduleOrigin = Nothing, name = "Time_utc" }

                "toYear" ->
                    Just { moduleOrigin = Nothing, name = "Time_toYear" }

                "toMonth" ->
                    Just { moduleOrigin = Nothing, name = "Time_toMonth" }

                "toDay" ->
                    Just { moduleOrigin = Nothing, name = "Time_toDay" }

                "toWeekday" ->
                    Just { moduleOrigin = Nothing, name = "Time_toWeekday" }

                "toHour" ->
                    Just { moduleOrigin = Nothing, name = "Time_toHour" }

                "toMinute" ->
                    Just { moduleOrigin = Nothing, name = "Time_toMinute" }

                "toSecond" ->
                    Just { moduleOrigin = Nothing, name = "Time_toSecond" }

                "toMillis" ->
                    Just { moduleOrigin = Nothing, name = "Time_toMillis" }

                "customZone" ->
                    Just { moduleOrigin = Nothing, name = "Time_customZone" }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "LE" ->
                    Just { moduleOrigin = Nothing, name = "Bytes_LE" }

                "BE" ->
                    Just { moduleOrigin = Nothing, name = "Bytes_BE" }

                "width" ->
                    Just { moduleOrigin = Nothing, name = "Bytes_width" }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "Loop" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_Loop" }

                "Done" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_Done" }

                "decode" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_decode" }

                "signedInt8" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_signedInt8" }

                "signedInt16" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_signedInt16" }

                "signedInt32" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_signedInt32" }

                "unsignedInt8" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_unsignedInt8" }

                "unsignedInt16" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_unsignedInt16" }

                "unsignedInt32" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_unsignedInt32" }

                "float32" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_float32" }

                "float64" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_float64" }

                "string" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_string" }

                "bytes" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_bytes" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_map" }

                "map2" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_map2" }

                "map3" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_map3" }

                "map4" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_map4" }

                "map5" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_map5" }

                "andThen" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_andThen" }

                "succeed" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_succeed" }

                "fail" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_fail" }

                "loop" ->
                    Just { moduleOrigin = Nothing, name = "BytesDecode_loop" }

                _ ->
                    Nothing

        "Bytes.Encode" ->
            case reference.name of
                "encode" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_encode" }

                "signedInt8" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_signedInt8" }

                "signedInt16" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_signedInt16" }

                "signedInt32" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_signedInt32" }

                "unsignedInt8" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_unsignedInt8" }

                "unsignedInt16" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_unsignedInt16" }

                "unsignedInt32" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_unsignedInt32" }

                "float32" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_float32" }

                "float64" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_float64" }

                "bytes" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_bytes" }

                "string" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_string" }

                "getStringWidth" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_getStringWidth" }

                "sequence" ->
                    Just { moduleOrigin = Nothing, name = "BytesEncode_sequence" }

                _ ->
                    Nothing

        "Elm.Kernel.VirtualDom" ->
            case reference.name of
                "property" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_property" }

                "attribute" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_attribute" }

                "attributeNS" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_attributeNS" }

                "node" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_node" }

                "nodeNS" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_nodeNS" }

                "noJavaScriptOrHtmlUri" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_noJavaScriptOrHtmlUri" }

                "noJavaScriptUri" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_noJavaScriptUri" }

                _ ->
                    Nothing

        "VirtualDom" ->
            case reference.name of
                "Normal" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_Normal" }

                "MayStopPropagation" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_MayStopPropagation" }

                "MayPreventDefault" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_MayPreventDefault" }

                "Custom" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_Custom" }

                "text" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_text" }

                "node" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_node" }

                "nodeNS" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_nodeNS" }

                "style" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_style" }

                "property" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_property" }

                "attribute" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_attribute" }

                "attributeNS" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_attributeNS" }

                "on" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_on" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_map" }

                "mapAttribute" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_mapAttribute" }

                "keyedNode" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_keyedNode" }

                "keyedNodeNS" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_keyedNodeNS" }

                "lazy" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy" }

                "lazy2" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy2" }

                "lazy3" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy3" }

                "lazy4" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy4" }

                "lazy5" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy5" }

                "lazy6" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy6" }

                "lazy7" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy7" }

                "lazy8" ->
                    Just { moduleOrigin = Nothing, name = "VirtualDom_lazy8" }

                _ ->
                    Nothing

        "Debug" ->
            case reference.name of
                "log" ->
                    Just { moduleOrigin = Nothing, name = "Debug_log" }

                "toString" ->
                    Just { moduleOrigin = Nothing, name = "Debug_toString" }

                "todo" ->
                    Just { moduleOrigin = Nothing, name = "Debug_todo" }

                _ ->
                    Nothing

        "Math.Vector2" ->
            case reference.name of
                "add" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_add" }

                "direction" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_direction" }

                "distance" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_distance" }

                "distanceSquared" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_distanceSquared" }

                "dot" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_dot" }

                "fromRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_fromRecord" }

                "getX" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_getX" }

                "getY" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_getY" }

                "length" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_length" }

                "lengthSquared" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_lengthSquared" }

                "negate" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_negate" }

                "normalize" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_normalize" }

                "scale" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_scale" }

                "setX" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_setX" }

                "setY" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_setY" }

                "sub" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_sub" }

                "toRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_toRecord" }

                "vec2" ->
                    Just { moduleOrigin = Nothing, name = "MathVector2_vec2" }

                _ ->
                    Nothing

        "Math.Vector3" ->
            case reference.name of
                "add" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_add" }

                "cross" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_cross" }

                "direction" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_direction" }

                "distance" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_distance" }

                "distanceSquared" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_distanceSquared" }

                "dot" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_dot" }

                "fromRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_fromRecord" }

                "getX" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_getX" }

                "getY" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_getY" }

                "getZ" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_getZ" }

                "i" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_i" }

                "j" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_j" }

                "k" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_k" }

                "length" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_length" }

                "lengthSquared" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_lengthSquared" }

                "negate" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_negate" }

                "normalize" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_normalize" }

                "scale" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_scale" }

                "setX" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_setX" }

                "setY" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_setY" }

                "setZ" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_setZ" }

                "sub" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_sub" }

                "toRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_toRecord" }

                "vec3" ->
                    Just { moduleOrigin = Nothing, name = "MathVector3_vec3" }

                _ ->
                    Nothing

        "Math.Vector4" ->
            case reference.name of
                "add" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_add" }

                "direction" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_direction" }

                "distance" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_distance" }

                "distanceSquared" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_distanceSquared" }

                "dot" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_dot" }

                "fromRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_fromRecord" }

                "getW" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_getW" }

                "getX" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_getX" }

                "getY" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_getY" }

                "getZ" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_getZ" }

                "length" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_length" }

                "lengthSquared" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_lengthSquared" }

                "negate" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_negate" }

                "normalize" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_normalize" }

                "scale" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_scale" }

                "setW" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_setW" }

                "setX" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_setX" }

                "setY" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_setY" }

                "setZ" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_setZ" }

                "sub" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_sub" }

                "toRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_toRecord" }

                "vec4" ->
                    Just { moduleOrigin = Nothing, name = "MathVector4_vec4" }

                _ ->
                    Nothing

        "Math.Matrix4" ->
            case reference.name of
                "fromRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_fromRecord" }

                "identity" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_identity" }

                "inverse" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_inverse" }

                -- not supported
                -- "inverseOrthonormal" ->
                --     Just { moduleOrigin = Nothing, name = "MathMatrix4_inverseOrthonormal" }
                "makeBasis" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_makeBasis" }

                "makeFrustum" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_makeFrustum" }

                "makeLookAt" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_makeLookAt" }

                "makeOrtho" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_makeOrtho" }

                "makeOrtho2D" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_makeOrtho2D" }

                "makePerspective" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_makePerspective" }

                "makeRotate" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_makeRotate" }

                "makeScale" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_makeScale" }

                "makeScale3" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_makeScale3" }

                "makeTranslate" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_makeTranslate" }

                "makeTranslate3" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_makeTranslate3" }

                "mul" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_mul" }

                -- not supported
                -- "mulAffine" ->
                --     Just { moduleOrigin = Nothing, name = "MathMatrix4_mulAffine" }
                "rotate" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_rotate" }

                "scale" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_scale" }

                "scale3" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_scale3" }

                "toRecord" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_toRecord" }

                "transform" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_transform" }

                "translate" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_translate" }

                "translate3" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_translate3" }

                "transpose" ->
                    Just { moduleOrigin = Nothing, name = "MathMatrix4_transpose" }

                _ ->
                    Nothing

        "Platform" ->
            case reference.name of
                "worker" ->
                    Just { moduleOrigin = Nothing, name = "Platform_worker" }

                _ ->
                    Nothing

        "Platform.Cmd" ->
            case reference.name of
                "none" ->
                    Just { moduleOrigin = Nothing, name = "PlatformCmd_none" }

                "batch" ->
                    Just { moduleOrigin = Nothing, name = "PlatformCmd_batch" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "PlatformCmd_map" }

                _ ->
                    Nothing

        "Platform.Sub" ->
            case reference.name of
                "none" ->
                    Just { moduleOrigin = Nothing, name = "PlatformSub_none" }

                "batch" ->
                    Just { moduleOrigin = Nothing, name = "PlatformSub_batch" }

                "map" ->
                    Just { moduleOrigin = Nothing, name = "PlatformSub_map" }

                _ ->
                    Nothing

        _ ->
            Nothing


referenceToFsharpName :
    { moduleOrigin : String
    , name : String
    }
    -> String
referenceToFsharpName reference =
    case reference.moduleOrigin |> String.replace "." "" of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            moduleOriginNotEmpty
                ++ "_"
                ++ reference.name


printFsharpPatternNotParenthesized : FsharpPattern -> Print
printFsharpPatternNotParenthesized fsharpPattern =
    -- IGNORE TCO
    case fsharpPattern of
        FsharpPatternIgnore ->
            printExactlyUnderscore

        FsharpPatternInt int ->
            Print.exactly (int |> intLiteral)

        FsharpPatternChar charValue ->
            Print.exactly (charLiteral charValue)

        FsharpPatternStringLiteral string ->
            printFsharpStringLiteral string

        FsharpPatternVariable name ->
            Print.exactly name

        FsharpPatternListCons fsharpPatternListCons ->
            printFsharpPatternListCons fsharpPatternListCons

        FsharpPatternListExact elements ->
            printFsharpPatternListExact elements

        FsharpPatternRecordInexhaustive recordInexhaustiveFieldNames ->
            printExactlyCurlyOpeningSpace
                |> Print.followedBy
                    (recordInexhaustiveFieldNames
                        |> FastDict.toList
                        |> Print.listMapAndIntersperseAndFlatten
                            (\( fieldName, fieldValuePattern ) ->
                                Print.exactly
                                    (fieldName ++ " = ")
                                    |> Print.followedBy
                                        (printFsharpPatternNotParenthesized
                                            fieldValuePattern
                                        )
                            )
                            printExactlySemicolonSpace
                    )
                |> Print.followedBy printExactlySpaceCurlyClosing

        FsharpPatternVariant patternVariant ->
            Print.exactly
                (qualifiedReferenceToFsharpName
                    { moduleOrigin = patternVariant.moduleOrigin
                    , name = patternVariant.name
                    }
                )
                |> Print.followedBy
                    (case patternVariant.values of
                        [] ->
                            Print.empty

                        variantValue0 :: variantValue1Up ->
                            printExactlyParenOpening
                                |> Print.followedBy
                                    ((variantValue0 :: variantValue1Up)
                                        |> Print.listMapAndIntersperseAndFlatten
                                            printFsharpPatternNotParenthesized
                                            printExactlyCommaSpace
                                    )
                                |> Print.followedBy printExactlyParenClosing
                    )

        FsharpPatternAs patternAs ->
            printFsharpPatternAs patternAs

        FsharpPatternTuple parts ->
            printExactlyParenOpeningStructParenOpeningSpace
                |> Print.followedBy
                    ((parts.part0 :: parts.part1 :: parts.part2Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printFsharpPatternNotParenthesized
                            printExactlyCommaSpace
                    )
                |> Print.followedBy printExactlySpaceParenClosingParenClosing


printExactlySpaceCurlyClosing : Print
printExactlySpaceCurlyClosing =
    Print.exactly " }"


printExactlySpaceParenClosingParenClosing : Print
printExactlySpaceParenClosingParenClosing =
    Print.exactly " ))"


printExactlyParenOpeningStructParenOpeningSpace : Print
printExactlyParenOpeningStructParenOpeningSpace =
    Print.exactly "(struct( "


printFsharpPatternListExact : List FsharpPattern -> Print
printFsharpPatternListExact elements =
    case elements of
        [] ->
            printFsharpPatternListEmpty

        element0 :: element1Up ->
            printExactlyAngledOpeningSpace
                |> Print.followedBy
                    ((element0 :: element1Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            (\elementNode ->
                                Print.withIndentIncreasedBy 2
                                    (printFsharpPatternNotParenthesized elementNode)
                            )
                            printExactlySemicolonSpace
                    )
                |> Print.followedBy printExactlySpaceAngledClosing


printExactlySpaceAngledClosing : Print
printExactlySpaceAngledClosing =
    Print.exactly " ]"


printExactlySemicolonSpace : Print
printExactlySemicolonSpace =
    Print.exactly "; "


printFsharpPatternListEmpty : Print
printFsharpPatternListEmpty =
    Print.exactly "[]"


printFsharpPatternAs :
    { variable : String
    , pattern : FsharpPattern
    }
    -> Print
printFsharpPatternAs syntaxAs =
    printFsharpPatternParenthesizedIfSpaceSeparated
        syntaxAs.pattern
        |> Print.followedBy
            (Print.exactly (" as " ++ syntaxAs.variable))


printFsharpExpressionRecord : FastDict.Dict String FsharpExpression -> Print
printFsharpExpressionRecord syntaxRecordFields =
    if syntaxRecordFields |> FastDict.isEmpty then
        printExactlyFsharpExpressionRecordEmpty

    else
        let
            fieldsPrint : Print
            fieldsPrint =
                syntaxRecordFields
                    |> FastDict.toList
                    |> Print.listMapAndIntersperseAndFlatten
                        (\( fieldName, fieldValue ) ->
                            let
                                fieldValuePrint : Print
                                fieldValuePrint =
                                    printFsharpExpressionNotParenthesized fieldValue
                            in
                            Print.withIndentIncreasedBy 2
                                (Print.exactly (fieldName ++ " =")
                                    |> Print.followedBy
                                        (Print.withIndentAtNextMultipleOf4
                                            (Print.spaceOrLinebreakIndented
                                                (fieldValuePrint |> Print.lineSpread)
                                                |> Print.followedBy
                                                    fieldValuePrint
                                            )
                                        )
                                )
                        )
                        printLinebreakIndentedSemicolonSpace
        in
        printExactlyCurlyOpeningSpace
            |> Print.followedBy fieldsPrint
            |> Print.followedBy
                (Print.spaceOrLinebreakIndented
                    (fieldsPrint |> Print.lineSpread)
                )
            |> Print.followedBy printExactlyCurlyClosing


printExactlyFsharpExpressionRecordEmpty : Print
printExactlyFsharpExpressionRecordEmpty =
    Print.exactly "{}"


printExactlyCurlyClosing : Print
printExactlyCurlyClosing =
    Print.exactly "}"


{-| (Wrap in parens)
-}
printParenthesized : Print -> Print
printParenthesized inner =
    printExactlyParenOpening
        |> Print.followedBy
            (Print.withIndentIncreasedBy 1
                inner
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented
                (inner |> Print.lineSpread)
            )
        |> Print.followedBy printExactlyParenClosing


printExactlyParenOpening : Print
printExactlyParenOpening =
    Print.exactly "("


printExactlyParenClosing : Print
printExactlyParenClosing =
    Print.exactly ")"


{-| Transpile a list of [`Elm.Syntax.Declaration.Declaration`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Declaration#Declaration)s
across multiple modules to value, function and type declarations.
Declarations that use unsupported stuff like html kernel code (directly or indirectly)
will not be present in the final declarations.
Their errors can be found alongside the valid transpiled declarations.

The given list of files must also include files from used dependencies
including `elm/core`.

-}
modules :
    List Elm.Syntax.File.File
    ->
        { errors : List String
        , declarations :
            { valuesAndFunctions :
                FastDict.Dict
                    String
                    { parameters : List { pattern : FsharpPattern, type_ : FsharpType }
                    , result : FsharpExpression
                    , resultType : FsharpType
                    }
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , type_ : FsharpType
                    }
            , recordTypes : FastSet.Set (List String)
            , choiceTypes :
                FastDict.Dict
                    String
                    { parameters : List String
                    , variants : FastDict.Dict String (Maybe FsharpType)
                    }
            }
        }
modules syntaxDeclarationsIncludingOverwrittenOnes =
    let
        syntaxModules : List Elm.Syntax.File.File
        syntaxModules =
            syntaxDeclarationsIncludingOverwrittenOnes
                |> List.filter
                    (\syntaxModule ->
                        case
                            syntaxModule.moduleDefinition
                                |> Elm.Syntax.Node.value
                                |> moduleHeaderName
                        of
                            "Basics" ->
                                False

                            "Array" ->
                                False

                            -- https://github.com/elm/core/blob/1.0.5/src/Elm/JsArray.elm
                            "Elm.JsArray" ->
                                False

                            "Bitwise" ->
                                False

                            "Debug" ->
                                False

                            "Char" ->
                                False

                            "String" ->
                                False

                            "List" ->
                                False

                            "Maybe" ->
                                False

                            "Result" ->
                                False

                            "Dict" ->
                                False

                            "Set" ->
                                False

                            "Platform" ->
                                False

                            "Platform.Cmd" ->
                                False

                            "Platform.Sub" ->
                                False

                            "Process" ->
                                False

                            "Task" ->
                                False

                            "Json.Decode" ->
                                False

                            "Json.Encode" ->
                                False

                            "Regex" ->
                                False

                            "File" ->
                                False

                            "Bytes" ->
                                False

                            "Bytes.Encode" ->
                                False

                            "Bytes.Decode" ->
                                False

                            "Http" ->
                                False

                            "VirtualDom" ->
                                False

                            "Browser" ->
                                False

                            "Browser.Events" ->
                                False

                            "Browser.Navigation" ->
                                False

                            "Browser.Dom" ->
                                False

                            -- https://github.com/elm/browser/blob/master/src/Browser/AnimationManager.elm
                            "Browser.AnimationManager" ->
                                False

                            -- https://github.com/elm/browser/tree/master/src/Debugger
                            "Debugger.Expando" ->
                                False

                            "Debugger.History" ->
                                False

                            "Debugger.Main" ->
                                False

                            "Debugger.Metadata" ->
                                False

                            "Debugger.Overlay" ->
                                False

                            "Debugger.Report" ->
                                False

                            "Time" ->
                                False

                            "Random" ->
                                False

                            "Markdown" ->
                                False

                            "Benchmark" ->
                                False

                            "WebGL" ->
                                False

                            "WebGL.Settings" ->
                                False

                            "WebGL.Settings.Blend" ->
                                False

                            "WebGL.Settings.DepthTest" ->
                                False

                            "WebGL.Settings.StencilTest" ->
                                False

                            "WebGL.Texture" ->
                                False

                            "Math.Matrix4" ->
                                False

                            "Math.Vector2" ->
                                False

                            "Math.Vector3" ->
                                False

                            "Math.Vector4" ->
                                False

                            _ ->
                                True
                    )

        allFsharpRecords : FastSet.Set (List String)
        allFsharpRecords =
            syntaxModules
                |> listMapToFastSetsAndUnify
                    (\syntaxModule ->
                        syntaxModule.declarations
                            |> listMapToFastSetsAndUnify
                                (\(Elm.Syntax.Node.Node _ syntaxDeclaration) ->
                                    case syntaxDeclaration of
                                        Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                            (syntaxValueOrFunctionDeclaration.declaration
                                                |> Elm.Syntax.Node.value
                                                |> .expression
                                                |> syntaxExpressionContainedConstructedRecords
                                            )
                                                |> FastSet.union
                                                    (case syntaxValueOrFunctionDeclaration.signature of
                                                        Nothing ->
                                                            FastSet.empty

                                                        Just (Elm.Syntax.Node.Node _ signature) ->
                                                            signature.typeAnnotation
                                                                |> typeContainedRecords
                                                    )

                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                            -- invalid syntax
                                            FastSet.empty

                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                            FastSet.empty

                                        Elm.Syntax.Declaration.AliasDeclaration syntaxTypeAliasDeclaration ->
                                            syntaxTypeAliasDeclaration.typeAnnotation
                                                |> typeContainedRecords

                                        Elm.Syntax.Declaration.PortDeclaration syntaxPortDeclaration ->
                                            syntaxPortDeclaration.typeAnnotation
                                                |> typeContainedRecords

                                        Elm.Syntax.Declaration.CustomTypeDeclaration syntaxChoiceTypeDeclaration ->
                                            syntaxChoiceTypeDeclaration.constructors
                                                |> listMapToFastSetsAndUnify
                                                    (\(Elm.Syntax.Node.Node _ variant) ->
                                                        variant.arguments
                                                            |> listMapToFastSetsAndUnify typeContainedRecords
                                                    )
                                )
                    )
                |> FastSet.map
                    (\additionalRecordTypeAlias ->
                        additionalRecordTypeAlias
                            |> List.map stringFirstCharToUpper
                    )

        syntaxModulesFromMostToLeastImported : List Elm.Syntax.File.File
        syntaxModulesFromMostToLeastImported =
            syntaxModules
                |> List.map
                    (\syntaxModule ->
                        ( syntaxModule
                        , syntaxModule.moduleDefinition
                            |> Elm.Syntax.Node.value
                            |> moduleHeaderName
                        , syntaxModule.imports
                            |> List.map
                                (\(Elm.Syntax.Node.Node _ import_) ->
                                    import_.moduleName |> Elm.Syntax.Node.value |> String.join "."
                                )
                        )
                    )
                |> Data.Graph.stronglyConnCompR
                |> List.concatMap
                    (\edge0 ->
                        case edge0 of
                            Data.Graph.AcyclicSCC ( n, _, _ ) ->
                                [ n ]

                            Data.Graph.CyclicSCC triples ->
                                -- we assume the given module do not have cyclic imports
                                List.map (\( n, _, _ ) -> n) triples
                    )

        syntaxModulesInferredOrError :
            Result
                String
                { errors : List String
                , types :
                    FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
                , inferred :
                    List
                        { module_ : Elm.Syntax.File.File
                        , moduleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
                        , declarationsInferred :
                            List
                                { name : String
                                , nameRange : Elm.Syntax.Range.Range
                                , documentation : Maybe { content : String, range : Elm.Syntax.Range.Range }
                                , signature :
                                    Maybe
                                        { range : Elm.Syntax.Range.Range
                                        , nameRange : Elm.Syntax.Range.Range
                                        , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                                        , annotationTypeRange : Elm.Syntax.Range.Range
                                        }
                                , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
                                , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
                                , type_ : ElmSyntaxTypeInfer.Type
                                }
                        }
                }
        syntaxModulesInferredOrError =
            syntaxModulesFromMostToLeastImported
                |> listFoldlWhileOkFrom
                    { errors = []
                    , types = baseElmDeclarationTypes
                    , inferred = []
                    }
                    (\syntaxModule soFar ->
                        let
                            moduleName : String
                            moduleName =
                                syntaxModule.moduleDefinition
                                    |> Elm.Syntax.Node.value
                                    |> moduleHeaderName

                            moduleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
                            moduleOriginLookup =
                                syntaxModule.imports
                                    |> ElmSyntaxTypeInfer.importsToModuleOriginLookup
                                        soFar.types

                            currentModuleDeclarationTypesAndErrors : { types : ElmSyntaxTypeInfer.ModuleTypes, errors : List String }
                            currentModuleDeclarationTypesAndErrors =
                                syntaxModule.declarations
                                    |> ElmSyntaxTypeInfer.moduleDeclarationsToTypes
                                        { moduleName = moduleName
                                        , moduleOriginLookup = moduleOriginLookup
                                        }
                        in
                        syntaxModule.declarations
                            |> List.concatMap
                                (\(Elm.Syntax.Node.Node _ declaration) ->
                                    case declaration of
                                        Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                            case syntaxValueOrFunctionDeclaration.signature of
                                                Nothing ->
                                                    [ syntaxValueOrFunctionDeclaration ]

                                                Just (Elm.Syntax.Node.Node signatureRange signature) ->
                                                    let
                                                        specializedTypes : FastDict.Dict String (List FsharpTypeVariableSpecialization)
                                                        specializedTypes =
                                                            signature.typeAnnotation
                                                                |> syntaxTypeSplitIntoSpecializedFsharpTypes
                                                                    allFsharpRecords
                                                    in
                                                    if specializedTypes |> FastDict.isEmpty then
                                                        [ syntaxValueOrFunctionDeclaration ]

                                                    else
                                                        let
                                                            syntaxValueOrFunctionDeclarationName : String
                                                            syntaxValueOrFunctionDeclarationName =
                                                                syntaxValueOrFunctionDeclaration.declaration
                                                                    |> Elm.Syntax.Node.value
                                                                    |> .name
                                                                    |> Elm.Syntax.Node.value
                                                        in
                                                        specializedTypes
                                                            |> fastDictPermutations
                                                            |> List.map
                                                                (\specialization ->
                                                                    let
                                                                        specializedName : String
                                                                        specializedName =
                                                                            syntaxValueOrFunctionDeclarationName
                                                                                |> fsharpNameWithSpecializedTypes
                                                                                    specialization
                                                                    in
                                                                    { documentation = syntaxValueOrFunctionDeclaration.documentation
                                                                    , signature =
                                                                        Just
                                                                            (Elm.Syntax.Node.Node signatureRange
                                                                                { typeAnnotation =
                                                                                    signature.typeAnnotation
                                                                                        |> syntaxTypeNodeApplySpecialization specialization
                                                                                , name =
                                                                                    Elm.Syntax.Node.Node
                                                                                        (signature.name |> Elm.Syntax.Node.range)
                                                                                        specializedName
                                                                                }
                                                                            )
                                                                    , declaration =
                                                                        let
                                                                            (Elm.Syntax.Node.Node implementationRange implementation) =
                                                                                syntaxValueOrFunctionDeclaration.declaration
                                                                        in
                                                                        Elm.Syntax.Node.Node
                                                                            implementationRange
                                                                            { name =
                                                                                Elm.Syntax.Node.Node
                                                                                    (implementation.name |> Elm.Syntax.Node.range)
                                                                                    specializedName
                                                                            , arguments = implementation.arguments
                                                                            , expression = implementation.expression
                                                                            }
                                                                    }
                                                                )

                                        Elm.Syntax.Declaration.AliasDeclaration _ ->
                                            []

                                        Elm.Syntax.Declaration.CustomTypeDeclaration _ ->
                                            []

                                        Elm.Syntax.Declaration.PortDeclaration _ ->
                                            []

                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                            []

                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                            []
                                )
                            |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
                                { moduleName = moduleName
                                , importedTypes = soFar.types
                                , moduleOriginLookup = moduleOriginLookup
                                , otherModuleDeclaredTypes =
                                    -- also includes signatures because ports need to be known
                                    -- and we sometimes specialize the declaration names
                                    -- before inferring but still reference the old names
                                    -- which get changed to their specialized form only
                                    -- after inferring
                                    currentModuleDeclarationTypesAndErrors.types
                                }
                            |> Result.map
                                (\declarationsInferred ->
                                    { errors =
                                        currentModuleDeclarationTypesAndErrors.errors
                                            ++ soFar.errors
                                    , types =
                                        soFar.types
                                            |> FastDict.insert
                                                moduleName
                                                { typeAliases = currentModuleDeclarationTypesAndErrors.types.typeAliases
                                                , choiceTypes = currentModuleDeclarationTypesAndErrors.types.choiceTypes
                                                , signatures =
                                                    declarationsInferred
                                                        |> List.foldl
                                                            (\declarationInferred moduleTypesSoFar ->
                                                                moduleTypesSoFar
                                                                    |> FastDict.insert declarationInferred.name
                                                                        declarationInferred.type_
                                                            )
                                                            currentModuleDeclarationTypesAndErrors.types.signatures
                                                }
                                    , inferred =
                                        { declarationsInferred = declarationsInferred
                                        , module_ = syntaxModule
                                        , moduleOriginLookup = moduleOriginLookup
                                        }
                                            :: soFar.inferred
                                    }
                                )
                            |> Result.mapError
                                (\error ->
                                    "In module " ++ moduleName ++ ": " ++ error
                                )
                    )
    in
    case syntaxModulesInferredOrError of
        Err error ->
            { errors = [ error ]
            , declarations =
                { valuesAndFunctions = FastDict.empty
                , typeAliases = FastDict.empty
                , choiceTypes = FastDict.empty
                , recordTypes = FastSet.empty
                }
            }

        Ok modulesInferred ->
            let
                allValueAndFunctionAnnotations :
                    FastDict.Dict
                        -- module origin
                        String
                        (FastDict.Dict
                            String
                            Elm.Syntax.TypeAnnotation.TypeAnnotation
                        )
                allValueAndFunctionAnnotations =
                    syntaxModules
                        |> List.foldl
                            (\syntaxModule soFarModules ->
                                soFarModules
                                    |> FastDict.insert
                                        (syntaxModule.moduleDefinition
                                            |> Elm.Syntax.Node.value
                                            |> moduleHeaderName
                                        )
                                        (syntaxModule.declarations
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ syntaxDeclaration) soFar ->
                                                    case syntaxDeclaration of
                                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                                            -- invalid syntax
                                                            soFar

                                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.AliasDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.PortDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.CustomTypeDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                                            case syntaxValueOrFunctionDeclaration.signature of
                                                                Nothing ->
                                                                    soFar

                                                                Just (Elm.Syntax.Node.Node _ signature) ->
                                                                    soFar
                                                                        |> FastDict.insert
                                                                            (syntaxValueOrFunctionDeclaration.declaration
                                                                                |> Elm.Syntax.Node.value
                                                                                |> .name
                                                                                |> Elm.Syntax.Node.value
                                                                            )
                                                                            (signature.typeAnnotation
                                                                                |> Elm.Syntax.Node.value
                                                                            )
                                                )
                                                FastDict.empty
                                        )
                            )
                            FastDict.empty

                moduleMembers :
                    FastDict.Dict
                        String
                        { valueOrFunctionOrTypeAliasNames : FastSet.Set String
                        , choiceTypesExposingVariants :
                            FastDict.Dict String (FastDict.Dict String { valueCount : Int })
                        , recordTypeAliases :
                            FastDict.Dict String (List String)
                        , portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        }
                moduleMembers =
                    syntaxDeclarationsIncludingOverwrittenOnes
                        |> List.filter
                            (\syntaxModule ->
                                -- remove those modules we don't have a replacement for, yet
                                case
                                    syntaxModule.moduleDefinition
                                        |> Elm.Syntax.Node.value
                                        |> moduleHeaderName
                                of
                                    -- https://github.com/elm/core/blob/1.0.5/src/Elm/JsArray.elm
                                    "Elm.JsArray" ->
                                        False

                                    "Process" ->
                                        False

                                    "Task" ->
                                        False

                                    "File" ->
                                        False

                                    "Http" ->
                                        False

                                    "Browser" ->
                                        False

                                    "Browser.Events" ->
                                        False

                                    "Browser.Navigation" ->
                                        False

                                    "Browser.Dom" ->
                                        False

                                    -- https://github.com/elm/browser/blob/master/src/Browser/AnimationManager.elm
                                    "Browser.AnimationManager" ->
                                        False

                                    -- https://github.com/elm/browser/tree/master/src/Debugger
                                    "Debugger.Expando" ->
                                        False

                                    "Debugger.History" ->
                                        False

                                    "Debugger.Main" ->
                                        False

                                    "Debugger.Metadata" ->
                                        False

                                    "Debugger.Overlay" ->
                                        False

                                    "Debugger.Report" ->
                                        False

                                    "Markdown" ->
                                        False

                                    "Benchmark" ->
                                        False

                                    "WebGL" ->
                                        False

                                    "WebGL.Settings" ->
                                        False

                                    "WebGL.Settings.Blend" ->
                                        False

                                    "WebGL.Settings.DepthTest" ->
                                        False

                                    "WebGL.Settings.StencilTest" ->
                                        False

                                    "WebGL.Texture" ->
                                        False

                                    _ ->
                                        True
                            )
                        |> List.foldl
                            (\syntaxModule acrossModulesSoFar ->
                                acrossModulesSoFar
                                    |> FastDict.insert
                                        (syntaxModule.moduleDefinition
                                            |> Elm.Syntax.Node.value
                                            |> moduleHeaderName
                                        )
                                        (syntaxModule.declarations
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ declaration) membersSoFar ->
                                                    case declaration of
                                                        Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                                            { valueOrFunctionOrTypeAliasNames =
                                                                membersSoFar.valueOrFunctionOrTypeAliasNames
                                                                    |> FastSet.insert
                                                                        (syntaxValueOrFunctionDeclaration.declaration
                                                                            |> Elm.Syntax.Node.value
                                                                            |> .name
                                                                            |> Elm.Syntax.Node.value
                                                                        )
                                                            , choiceTypesExposingVariants =
                                                                membersSoFar.choiceTypesExposingVariants
                                                            , recordTypeAliases =
                                                                membersSoFar.recordTypeAliases
                                                            , portsOutgoing = membersSoFar.portsOutgoing
                                                            , portsIncoming = membersSoFar.portsIncoming
                                                            }

                                                        Elm.Syntax.Declaration.CustomTypeDeclaration syntaxChoiceTypeDeclaration ->
                                                            { valueOrFunctionOrTypeAliasNames =
                                                                membersSoFar.valueOrFunctionOrTypeAliasNames
                                                            , choiceTypesExposingVariants =
                                                                membersSoFar.choiceTypesExposingVariants
                                                                    |> FastDict.insert
                                                                        (syntaxChoiceTypeDeclaration.name |> Elm.Syntax.Node.value)
                                                                        (syntaxChoiceTypeDeclaration.constructors
                                                                            |> List.foldl
                                                                                (\(Elm.Syntax.Node.Node _ variant) variantNamesSoFar ->
                                                                                    variantNamesSoFar
                                                                                        |> FastDict.insert
                                                                                            (variant.name
                                                                                                |> Elm.Syntax.Node.value
                                                                                            )
                                                                                            { valueCount =
                                                                                                variant.arguments |> List.length
                                                                                            }
                                                                                )
                                                                                FastDict.empty
                                                                        )
                                                            , recordTypeAliases =
                                                                membersSoFar.recordTypeAliases
                                                            , portsOutgoing = membersSoFar.portsOutgoing
                                                            , portsIncoming = membersSoFar.portsIncoming
                                                            }

                                                        Elm.Syntax.Declaration.AliasDeclaration typeAlias ->
                                                            let
                                                                typeAliasName : String
                                                                typeAliasName =
                                                                    typeAlias.name
                                                                        |> Elm.Syntax.Node.value
                                                            in
                                                            { valueOrFunctionOrTypeAliasNames =
                                                                membersSoFar.valueOrFunctionOrTypeAliasNames
                                                                    |> FastSet.insert typeAliasName
                                                            , choiceTypesExposingVariants =
                                                                membersSoFar.choiceTypesExposingVariants
                                                            , recordTypeAliases =
                                                                case typeAlias.typeAnnotation |> Elm.Syntax.Node.value of
                                                                    Elm.Syntax.TypeAnnotation.Record fields ->
                                                                        membersSoFar.recordTypeAliases
                                                                            |> FastDict.insert typeAliasName
                                                                                (fields
                                                                                    |> List.map
                                                                                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, _ )) ->
                                                                                            fieldName |> stringFirstCharToUpper
                                                                                        )
                                                                                )

                                                                    Elm.Syntax.TypeAnnotation.GenericType _ ->
                                                                        membersSoFar.recordTypeAliases

                                                                    Elm.Syntax.TypeAnnotation.Typed _ _ ->
                                                                        membersSoFar.recordTypeAliases

                                                                    Elm.Syntax.TypeAnnotation.Unit ->
                                                                        membersSoFar.recordTypeAliases

                                                                    Elm.Syntax.TypeAnnotation.Tupled _ ->
                                                                        membersSoFar.recordTypeAliases

                                                                    Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                                                                        membersSoFar.recordTypeAliases

                                                                    Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                                                                        membersSoFar.recordTypeAliases
                                                            , portsOutgoing = membersSoFar.portsOutgoing
                                                            , portsIncoming = membersSoFar.portsIncoming
                                                            }

                                                        Elm.Syntax.Declaration.PortDeclaration portDeclaration ->
                                                            if portDeclaration.typeAnnotation |> portTypeSignifiesOutgoing then
                                                                { valueOrFunctionOrTypeAliasNames =
                                                                    membersSoFar.valueOrFunctionOrTypeAliasNames
                                                                , choiceTypesExposingVariants =
                                                                    membersSoFar.choiceTypesExposingVariants
                                                                , recordTypeAliases =
                                                                    membersSoFar.recordTypeAliases
                                                                , portsOutgoing =
                                                                    membersSoFar.portsOutgoing
                                                                        |> FastSet.insert
                                                                            (portDeclaration.name |> Elm.Syntax.Node.value)
                                                                , portsIncoming = membersSoFar.portsIncoming
                                                                }

                                                            else
                                                                { valueOrFunctionOrTypeAliasNames =
                                                                    membersSoFar.valueOrFunctionOrTypeAliasNames
                                                                , choiceTypesExposingVariants =
                                                                    membersSoFar.choiceTypesExposingVariants
                                                                , recordTypeAliases =
                                                                    membersSoFar.recordTypeAliases
                                                                , portsOutgoing = membersSoFar.portsOutgoing
                                                                , portsIncoming =
                                                                    membersSoFar.portsIncoming
                                                                        |> FastSet.insert
                                                                            (portDeclaration.name |> Elm.Syntax.Node.value)
                                                                }

                                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                                            -- invalid syntax
                                                            membersSoFar
                                                )
                                                { valueOrFunctionOrTypeAliasNames = FastSet.empty
                                                , choiceTypesExposingVariants = FastDict.empty
                                                , recordTypeAliases = FastDict.empty
                                                , portsOutgoing = FastSet.empty
                                                , portsIncoming = FastSet.empty
                                                }
                                        )
                            )
                            FastDict.empty

                fsharpDeclarationsWithoutExtraRecordTypeAliases :
                    { errors : List String
                    , declarations :
                        { valuesAndFunctions :
                            FastDict.Dict
                                String
                                { parameters : List { pattern : FsharpPattern, type_ : FsharpType }
                                , result : FsharpExpression
                                , resultType : FsharpType
                                }
                        , typeAliases :
                            FastDict.Dict
                                String
                                { parameters : List String
                                , type_ : FsharpType
                                }
                        , choiceTypes :
                            FastDict.Dict
                                String
                                { parameters : List String
                                , variants : FastDict.Dict String (Maybe FsharpType)
                                }
                        }
                    }
                fsharpDeclarationsWithoutExtraRecordTypeAliases =
                    modulesInferred.inferred
                        |> List.foldr
                            (\moduleInferred soFarAcrossModules ->
                                let
                                    moduleName : String
                                    moduleName =
                                        moduleInferred.module_.moduleDefinition
                                            |> Elm.Syntax.Node.value
                                            |> moduleHeaderName
                                in
                                case modulesInferred.types |> FastDict.get moduleName of
                                    Nothing ->
                                        { declarations = soFarAcrossModules.declarations
                                        , errors =
                                            "bug in elm-syntax-to-fsharp: couldn't find declaration types"
                                                :: soFarAcrossModules.errors
                                        }

                                    Just currentModuleDeclarationTypes ->
                                        let
                                            createdModuleContext : ModuleContext
                                            createdModuleContext =
                                                moduleContextMerge
                                                    (moduleInferred.module_.imports
                                                        |> importsToModuleContext moduleMembers
                                                    )
                                                    (case moduleMembers |> FastDict.get moduleName of
                                                        Nothing ->
                                                            moduleContextEmpty

                                                        Just moduleLocalNames ->
                                                            { recordTypeAliases =
                                                                FastDict.singleton moduleName
                                                                    (moduleLocalNames.recordTypeAliases
                                                                        |> FastDict.foldl
                                                                            (\name fieldOrder soFar ->
                                                                                soFar
                                                                                    |> FastDict.insert name
                                                                                        fieldOrder
                                                                            )
                                                                            FastDict.empty
                                                                    )
                                                            , portIncomingLookup =
                                                                moduleLocalNames.portsIncoming
                                                                    |> FastSet.map (\portName -> ( moduleName, portName ))
                                                            , portOutgoingLookup =
                                                                moduleLocalNames.portsOutgoing
                                                                    |> FastSet.map (\portName -> ( moduleName, portName ))
                                                            }
                                                    )
                                        in
                                        moduleInferred.module_.declarations
                                            |> List.foldr
                                                (\(Elm.Syntax.Node.Node _ declaration) soFar ->
                                                    case declaration of
                                                        Elm.Syntax.Declaration.FunctionDeclaration _ ->
                                                            -- handled below
                                                            soFar

                                                        Elm.Syntax.Declaration.AliasDeclaration syntaxTypeAliasDeclaration ->
                                                            let
                                                                typeAliasName : String
                                                                typeAliasName =
                                                                    syntaxTypeAliasDeclaration.name |> Elm.Syntax.Node.value
                                                            in
                                                            case currentModuleDeclarationTypes.typeAliases |> FastDict.get typeAliasName of
                                                                Nothing ->
                                                                    { declarations = soFar.declarations
                                                                    , errors =
                                                                        ("bug in elm-syntax-to-fsharp: failed to find transformed type alias declaration "
                                                                            ++ moduleName
                                                                            ++ "."
                                                                            ++ typeAliasName
                                                                        )
                                                                            :: soFar.errors
                                                                    }

                                                                Just inferredTypeAliasDeclaration ->
                                                                    let
                                                                        fsharpTypeAliasDeclaration :
                                                                            { name : String
                                                                            , parameters : List String
                                                                            , type_ : FsharpType
                                                                            }
                                                                        fsharpTypeAliasDeclaration =
                                                                            typeAliasDeclaration
                                                                                { name = typeAliasName
                                                                                , parameters = inferredTypeAliasDeclaration.parameters
                                                                                , type_ = inferredTypeAliasDeclaration.type_
                                                                                }
                                                                    in
                                                                    { errors = soFar.errors
                                                                    , declarations =
                                                                        { valuesAndFunctions = soFar.declarations.valuesAndFunctions
                                                                        , choiceTypes = soFar.declarations.choiceTypes
                                                                        , typeAliases =
                                                                            soFar.declarations.typeAliases
                                                                                |> FastDict.insert
                                                                                    ({ moduleOrigin = moduleName
                                                                                     , name = fsharpTypeAliasDeclaration.name
                                                                                     }
                                                                                        |> referenceToFsharpName
                                                                                    )
                                                                                    { parameters = fsharpTypeAliasDeclaration.parameters
                                                                                    , type_ = fsharpTypeAliasDeclaration.type_
                                                                                    }
                                                                        }
                                                                    }

                                                        Elm.Syntax.Declaration.CustomTypeDeclaration syntaxChoiceTypeDeclaration ->
                                                            let
                                                                choiceTypeName : String
                                                                choiceTypeName =
                                                                    syntaxChoiceTypeDeclaration.name |> Elm.Syntax.Node.value
                                                            in
                                                            case currentModuleDeclarationTypes.choiceTypes |> FastDict.get choiceTypeName of
                                                                Nothing ->
                                                                    { declarations = soFar.declarations
                                                                    , errors =
                                                                        ("bug in elm-syntax-to-fsharp: failed to find transformed choice type declaration "
                                                                            ++ moduleName
                                                                            ++ "."
                                                                            ++ choiceTypeName
                                                                        )
                                                                            :: soFar.errors
                                                                    }

                                                                Just inferredChoiceAliasDeclaration ->
                                                                    let
                                                                        fsharpTypeAliasDeclaration :
                                                                            { name : String
                                                                            , parameters : List String
                                                                            , variants : FastDict.Dict String (Maybe FsharpType)
                                                                            }
                                                                        fsharpTypeAliasDeclaration =
                                                                            choiceTypeDeclaration
                                                                                { name = choiceTypeName
                                                                                , parameters = inferredChoiceAliasDeclaration.parameters
                                                                                , variants = inferredChoiceAliasDeclaration.variants
                                                                                }
                                                                    in
                                                                    { errors = soFar.errors
                                                                    , declarations =
                                                                        { valuesAndFunctions = soFar.declarations.valuesAndFunctions
                                                                        , typeAliases = soFar.declarations.typeAliases
                                                                        , choiceTypes =
                                                                            soFar.declarations.choiceTypes
                                                                                |> FastDict.insert
                                                                                    ({ moduleOrigin = moduleName
                                                                                     , name = fsharpTypeAliasDeclaration.name
                                                                                     }
                                                                                        |> referenceToFsharpName
                                                                                    )
                                                                                    { parameters = fsharpTypeAliasDeclaration.parameters
                                                                                    , variants =
                                                                                        fsharpTypeAliasDeclaration.variants
                                                                                            |> FastDict.foldl
                                                                                                (\variantName maybeValue variantsSoFar ->
                                                                                                    variantsSoFar
                                                                                                        |> FastDict.insert
                                                                                                            ({ moduleOrigin = moduleName
                                                                                                             , name = variantName
                                                                                                             }
                                                                                                                |> referenceToFsharpName
                                                                                                            )
                                                                                                            maybeValue
                                                                                                )
                                                                                                FastDict.empty
                                                                                    }
                                                                        }
                                                                    }

                                                        Elm.Syntax.Declaration.PortDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                                            soFar
                                                )
                                                (moduleInferred.declarationsInferred
                                                    |> List.foldl
                                                        (\valueOrFunctionDeclarationInferred soFarAcrossModulesWithInferredValeAndFunctionDeclarations ->
                                                            case
                                                                valueOrFunctionDeclarationInferred
                                                                    |> valueOrFunctionDeclaration
                                                                        { valueAndFunctionAnnotations = allValueAndFunctionAnnotations
                                                                        , recordTypeAliases = createdModuleContext.recordTypeAliases
                                                                        , portIncomingLookup = createdModuleContext.portIncomingLookup
                                                                        , portOutgoingLookup = createdModuleContext.portOutgoingLookup
                                                                        }
                                                            of
                                                                Ok fsharpValueOrFunctionDeclaration ->
                                                                    { errors = soFarAcrossModulesWithInferredValeAndFunctionDeclarations.errors
                                                                    , declarations =
                                                                        { typeAliases = soFarAcrossModulesWithInferredValeAndFunctionDeclarations.declarations.typeAliases
                                                                        , choiceTypes = soFarAcrossModulesWithInferredValeAndFunctionDeclarations.declarations.choiceTypes
                                                                        , valuesAndFunctions =
                                                                            soFarAcrossModulesWithInferredValeAndFunctionDeclarations.declarations.valuesAndFunctions
                                                                                |> FastDict.insert
                                                                                    ({ moduleOrigin = moduleName
                                                                                     , name = valueOrFunctionDeclarationInferred.name
                                                                                     }
                                                                                        |> referenceToFsharpName
                                                                                    )
                                                                                    fsharpValueOrFunctionDeclaration
                                                                        }
                                                                    }

                                                                Err error ->
                                                                    { declarations = soFarAcrossModulesWithInferredValeAndFunctionDeclarations.declarations
                                                                    , errors =
                                                                        ("in value/function declaration "
                                                                            ++ moduleName
                                                                            ++ "."
                                                                            ++ valueOrFunctionDeclarationInferred.name
                                                                            ++ ": "
                                                                            ++ error
                                                                        )
                                                                            :: soFarAcrossModulesWithInferredValeAndFunctionDeclarations.errors
                                                                    }
                                                        )
                                                        soFarAcrossModules
                                                )
                            )
                            { errors = []
                            , declarations =
                                { valuesAndFunctions = FastDict.empty
                                , typeAliases = FastDict.empty
                                , choiceTypes = FastDict.empty
                                }
                            }
            in
            { declarations =
                { valuesAndFunctions =
                    fsharpDeclarationsWithoutExtraRecordTypeAliases.declarations.valuesAndFunctions
                        |> FastDict.map
                            (\_ valueOrFunctionInfo ->
                                { parameters = valueOrFunctionInfo.parameters
                                , result = valueOrFunctionInfo.result
                                , resultType = valueOrFunctionInfo.resultType
                                }
                            )
                , choiceTypes =
                    fsharpDeclarationsWithoutExtraRecordTypeAliases.declarations.choiceTypes
                        |> FastDict.map
                            (\_ typeAliasInfo ->
                                { parameters = typeAliasInfo.parameters
                                , variants = typeAliasInfo.variants
                                }
                            )
                , recordTypes =
                    allFsharpRecords
                        |> -- skip those that are already in the default declarations
                           FastSet.remove
                            [ "Message", "PreventDefault", "StopPropagation" ]
                , typeAliases =
                    fsharpDeclarationsWithoutExtraRecordTypeAliases.declarations.typeAliases
                        |> FastDict.map
                            (\_ typeAliasInfo ->
                                { parameters = typeAliasInfo.parameters
                                , type_ = typeAliasInfo.type_
                                }
                            )
                }
            , errors =
                (modulesInferred.errors |> List.reverse)
                    ++ (fsharpDeclarationsWithoutExtraRecordTypeAliases.errors
                            |> List.reverse
                       )
            }


listFoldlWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFrom initialOkFolded reduceOnOk list =
    case list of
        [] ->
            Ok initialOkFolded

        head :: tail ->
            case initialOkFolded |> reduceOnOk head of
                Err error ->
                    Err error

                Ok okFoldedWithHead ->
                    listFoldlWhileOkFrom okFoldedWithHead reduceOnOk tail


baseElmDeclarationTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
baseElmDeclarationTypes =
    ElmSyntaxTypeInfer.elmCoreTypes
        |> FastDict.union elmJsonTypes
        |> FastDict.union elmBytesTypes
        |> FastDict.union elmVirtualDomTypes
        |> FastDict.union elmKernelVirtualDomTypes
        |> FastDict.union elmRandomTypes
        |> FastDict.union elmRegexTypes
        |> FastDict.union elmTimeTypes
        |> FastDict.union elmExplorationsLinearAlgebraTypes
        |> FastDict.union elmKernelParserTypes
        |> FastDict.union elmKernelUrlTypes


portTypeSignifiesOutgoing :
    Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Bool
portTypeSignifiesOutgoing (Elm.Syntax.Node.Node _ syntaxType) =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ (Elm.Syntax.Node.Node _ output) ->
            case output of
                Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( _, name )) _ ->
                    name |> String.toLower |> String.contains "cmd"

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    False

                Elm.Syntax.TypeAnnotation.Unit ->
                    False

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    False

                Elm.Syntax.TypeAnnotation.Record _ ->
                    False

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    False

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    False

        Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( _, name )) _ ->
            name |> String.toLower |> String.contains "cmd"

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            False

        Elm.Syntax.TypeAnnotation.Unit ->
            False

        Elm.Syntax.TypeAnnotation.Tupled _ ->
            False

        Elm.Syntax.TypeAnnotation.Record _ ->
            False

        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
            False


patternTypedNodeIntroducedVariables :
    ElmSyntaxTypeInfer.TypedNode
        ElmSyntaxTypeInfer.Pattern
    -> FastSet.Set String
patternTypedNodeIntroducedVariables patternTypedNode =
    patternTypedNode.value
        |> patternIntroducedVariables


patternIntroducedVariables :
    ElmSyntaxTypeInfer.Pattern
    -> FastSet.Set String
patternIntroducedVariables inferredPattern =
    case inferredPattern of
        ElmSyntaxTypeInfer.PatternIgnored ->
            FastSet.empty

        ElmSyntaxTypeInfer.PatternUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.PatternChar _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.PatternString _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.PatternInt _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.PatternVariable variable ->
            FastSet.singleton variable

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            patternTypedNodeIntroducedVariables
                inParens

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            FastSet.insert patternAs.variable.value
                (patternAs.pattern
                    |> patternTypedNodeIntroducedVariables
                )

        ElmSyntaxTypeInfer.PatternTuple parts ->
            FastSet.union
                (parts.part0
                    |> patternTypedNodeIntroducedVariables
                )
                (parts.part1
                    |> patternTypedNodeIntroducedVariables
                )

        ElmSyntaxTypeInfer.PatternTriple parts ->
            FastSet.union
                (parts.part0
                    |> patternTypedNodeIntroducedVariables
                )
                (FastSet.union
                    (parts.part1
                        |> patternTypedNodeIntroducedVariables
                    )
                    (parts.part2
                        |> patternTypedNodeIntroducedVariables
                    )
                )

        ElmSyntaxTypeInfer.PatternListCons patternListCons ->
            FastSet.union
                (patternListCons.head
                    |> patternTypedNodeIntroducedVariables
                )
                (patternListCons.tail
                    |> patternTypedNodeIntroducedVariables
                )

        ElmSyntaxTypeInfer.PatternListExact elements ->
            elements
                |> listMapToFastSetsAndUnify
                    (\element ->
                        element
                            |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternVariant patternVariant ->
            patternVariant.values
                |> listMapToFastSetsAndUnify
                    (\value ->
                        value
                            |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternRecord fields ->
            fields
                |> List.foldl
                    (\fieldTypedNode soFar ->
                        soFar |> FastSet.insert fieldTypedNode.value
                    )
                    FastSet.empty


generatedFsharpRecordTypeAliasName : List String -> String
generatedFsharpRecordTypeAliasName recordFields =
    "Generated_" ++ (recordFields |> String.join "_")


moduleHeaderName : Elm.Syntax.Module.Module -> String
moduleHeaderName moduleHeader =
    (case moduleHeader of
        Elm.Syntax.Module.NormalModule header ->
            header.moduleName

        Elm.Syntax.Module.PortModule header ->
            header.moduleName

        Elm.Syntax.Module.EffectModule header ->
            header.moduleName
    )
        |> Elm.Syntax.Node.value
        |> String.join "."


valueOrFunctionDeclaration :
    { valueAndFunctionAnnotations :
        FastDict.Dict
            -- module origin
            String
            (FastDict.Dict
                String
                Elm.Syntax.TypeAnnotation.TypeAnnotation
            )
    , recordTypeAliases :
        FastDict.Dict
            String
            (FastDict.Dict
                String
                (List String)
            )
    , portIncomingLookup : FastSet.Set ( String, String )
    , portOutgoingLookup : FastSet.Set ( String, String )
    }
    ->
        { name : String
        , nameRange : Elm.Syntax.Range.Range
        , documentation : Maybe { content : String, range : Elm.Syntax.Range.Range }
        , signature :
            Maybe
                { range : Elm.Syntax.Range.Range
                , nameRange : Elm.Syntax.Range.Range
                , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                , annotationTypeRange : Elm.Syntax.Range.Range
                }
        , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
        , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
        , type_ : ElmSyntaxTypeInfer.Type
        }
    ->
        Result
            String
            { parameters : List { pattern : FsharpPattern, type_ : FsharpType }
            , result : FsharpExpression
            , resultType : FsharpType
            }
valueOrFunctionDeclaration moduleContext syntaxDeclarationValueOrFunction =
    Result.andThen
        (\parameters ->
            Result.map
                (\result ->
                    { parameters =
                        parameters
                            |> List.map
                                (\param ->
                                    { type_ = param.type_, pattern = param.pattern }
                                )
                    , resultType =
                        case syntaxDeclarationValueOrFunction.parameters of
                            [] ->
                                syntaxDeclarationValueOrFunction.type_ |> type_

                            _ :: _ ->
                                syntaxDeclarationValueOrFunction.result.type_ |> type_
                    , result = result
                    }
                )
                (syntaxDeclarationValueOrFunction.result
                    |> expression
                        { valueAndFunctionAnnotations = moduleContext.valueAndFunctionAnnotations
                        , recordTypeAliases = moduleContext.recordTypeAliases
                        , portIncomingLookup = moduleContext.portIncomingLookup
                        , portOutgoingLookup = moduleContext.portOutgoingLookup
                        , variablesFromWithinDeclarationInScope =
                            parameters
                                |> listMapToFastSetsAndUnify .introducedVariables
                        }
                )
        )
        (syntaxDeclarationValueOrFunction.parameters
            |> listMapAndCombineOk
                (\parameter -> parameter |> typedPattern)
        )


variableNameDisambiguateFromFsharpKeywords : String -> String
variableNameDisambiguateFromFsharpKeywords variableName =
    -- TODO consider also adding _ when (variableName |> String.endsWith "_")
    -- to avoid accidental overlaps
    if fsharpKeywords |> FastSet.member variableName then
        variableName ++ "_"

    else
        variableName


fsharpKeywords : FastSet.Set String
fsharpKeywords =
    -- https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/keyword-reference
    FastSet.fromList
        [ "abstract"
        , "and"
        , "as"
        , "assert"
        , "base"
        , "begin"
        , "class"
        , "default"
        , "delegate"
        , "do"
        , "done"
        , "downcast"
        , "downto"
        , "elif"
        , "else"
        , "end"
        , "extern"
        , "false"
        , "finally"
        , "fixed"
        , "for"
        , "fun"
        , "function"
        , "global"
        , "if"
        , "in"
        , "inherit"
        , "inline"
        , "interface"
        , "lazy"
        , "let"
        , "match"
        , "member"
        , "mod"
        , "sig"
        , "module"
        , "mutable"
        , "namespace"
        , "new"
        , "not"
        , "null"
        , "of"
        , "open"
        , "or"
        , "override"
        , "private"
        , "public"
        , "rec"
        , "return"
        , "select"
        , "static"
        , "struct"
        , "then"
        , "to"
        , "true"
        , "try"
        , "type"
        , "upcast"
        , "use"
        , "val"
        , "void"
        , "when"
        , "while"
        , "with"
        , "yield"
        , "const"
        , -- some exposed names
          "float"
        , "single"
        , "double"
        , "decimal"
        , "int"
        , "byte"
        , "char"
        , "string"
        , "unit"
        , "option"
        , "voption"
        , "list"
        ]


expressionContextAddVariablesInScope :
    FastSet.Set String
    ->
        { valueAndFunctionAnnotations :
            FastDict.Dict
                -- module origin
                String
                (FastDict.Dict
                    String
                    Elm.Syntax.TypeAnnotation.TypeAnnotation
                )
        , recordTypeAliases :
            FastDict.Dict
                String
                (FastDict.Dict
                    String
                    (List String)
                )
        , portIncomingLookup : FastSet.Set ( String, String )
        , portOutgoingLookup : FastSet.Set ( String, String )
        , variablesFromWithinDeclarationInScope : FastSet.Set String
        }
    ->
        { valueAndFunctionAnnotations :
            FastDict.Dict
                -- module origin
                String
                (FastDict.Dict
                    String
                    Elm.Syntax.TypeAnnotation.TypeAnnotation
                )
        , recordTypeAliases :
            FastDict.Dict
                String
                (FastDict.Dict
                    String
                    (List String)
                )
        , portIncomingLookup : FastSet.Set ( String, String )
        , portOutgoingLookup : FastSet.Set ( String, String )
        , variablesFromWithinDeclarationInScope : FastSet.Set String
        }
expressionContextAddVariablesInScope additionalVariablesInScope context =
    { valueAndFunctionAnnotations = context.valueAndFunctionAnnotations
    , recordTypeAliases = context.recordTypeAliases
    , portIncomingLookup = context.portIncomingLookup
    , portOutgoingLookup = context.portOutgoingLookup
    , variablesFromWithinDeclarationInScope =
        FastSet.union
            additionalVariablesInScope
            context.variablesFromWithinDeclarationInScope
    }


expression :
    { valueAndFunctionAnnotations :
        FastDict.Dict
            -- module origin
            String
            (FastDict.Dict
                String
                Elm.Syntax.TypeAnnotation.TypeAnnotation
            )
    , recordTypeAliases :
        FastDict.Dict
            String
            (FastDict.Dict
                String
                (List String)
            )
    , portIncomingLookup : FastSet.Set ( String, String )
    , portOutgoingLookup : FastSet.Set ( String, String )
    , variablesFromWithinDeclarationInScope : FastSet.Set String
    }
    ->
        ElmSyntaxTypeInfer.TypedNode
            ElmSyntaxTypeInfer.Expression
    -> Result String FsharpExpression
expression context expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            Ok FsharpExpressionUnit

        ElmSyntaxTypeInfer.ExpressionInteger intValue ->
            if expressionTypedNode.type_ == inferredTypeBasicsFloat then
                Ok (FsharpExpressionFloat (intValue.value |> Basics.toFloat))

            else
                case expressionTypedNode.type_ of
                    ElmSyntaxTypeInfer.TypeVariable variable ->
                        if variable.name |> String.startsWith "number" then
                            -- assume Float
                            Ok (FsharpExpressionFloat (intValue.value |> Basics.toFloat))

                        else
                            -- assume Int
                            Ok (FsharpExpressionInt64 intValue.value)

                    _ ->
                        -- assume Int
                        Ok (FsharpExpressionInt64 intValue.value)

        ElmSyntaxTypeInfer.ExpressionFloat floatValue ->
            Ok (FsharpExpressionFloat floatValue)

        ElmSyntaxTypeInfer.ExpressionChar charValue ->
            Ok (FsharpExpressionChar charValue)

        ElmSyntaxTypeInfer.ExpressionString stringValue ->
            Ok
                (createFsharpExpressionCalStringRopeOne
                    (FsharpExpressionStringLiteral stringValue)
                )

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction fieldName ->
            case expressionTypedNode.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                    let
                        recordVariableName : String
                        recordVariableName =
                            "generated_record"
                    in
                    Ok
                        (FsharpExpressionLambda
                            { parameters =
                                [ { pattern = FsharpPatternVariable recordVariableName
                                  , type_ = typeFunction.input |> type_
                                  }
                                ]
                            , result =
                                FsharpExpressionRecordAccess
                                    { record =
                                        FsharpExpressionReference
                                            { moduleOrigin = Nothing
                                            , name = recordVariableName
                                            }
                                    , field =
                                        fieldName
                                            |> String.replace "." ""
                                            |> stringFirstCharToUpper
                                    }
                            }
                        )

                _ ->
                    Err "record access function has an inferred type that wasn't a function"

        ElmSyntaxTypeInfer.ExpressionOperatorFunction operator ->
            Result.map
                FsharpExpressionReference
                (expressionOperatorToFsharpFunctionReference
                    { moduleOrigin = operator.moduleOrigin
                    , symbol = operator.symbol
                    , type_ = expressionTypedNode.type_
                    }
                )

        ElmSyntaxTypeInfer.ExpressionCall call ->
            Result.map3
                (\called argument0 argument1Up ->
                    condenseExpressionCall
                        { called = called
                        , argument0 = argument0
                        , argument1Up = argument1Up
                        }
                )
                (call.called |> expression context)
                (call.argument0 |> expression context)
                (call.argument1Up
                    |> listMapAndCombineOk
                        (\argument -> argument |> expression context)
                )

        ElmSyntaxTypeInfer.ExpressionInfixOperation infixOperation ->
            case infixOperation.operator.symbol of
                "|>" ->
                    Result.map2
                        (\argument called ->
                            condenseExpressionCall
                                { called = called
                                , argument0 = argument
                                , argument1Up = []
                                }
                        )
                        (infixOperation.left |> expression context)
                        (infixOperation.right |> expression context)

                "<|" ->
                    Result.map2
                        (\called argument ->
                            condenseExpressionCall
                                { called = called
                                , argument0 = argument
                                , argument1Up = []
                                }
                        )
                        (infixOperation.left |> expression context)
                        (infixOperation.right |> expression context)

                "++" ->
                    Result.map2
                        (\left right ->
                            if infixOperation.left.type_ == inferredTypeString then
                                if left |> fsharpExpressionIsEmptyString then
                                    right

                                else if right |> fsharpExpressionIsEmptyString then
                                    left

                                else
                                    FsharpExpressionCall
                                        { called = fsharpExpressionReferenceStringAppend
                                        , arguments = [ left, right ]
                                        }

                            else
                                FsharpExpressionCall
                                    { called = fsharpExpressionReferenceListAppend
                                    , arguments = [ left, right ]
                                    }
                        )
                        (infixOperation.left |> expression context)
                        (infixOperation.right |> expression context)

                _ ->
                    Result.map3
                        (\operationFunctionReference left right ->
                            FsharpExpressionCall
                                { called =
                                    FsharpExpressionReference operationFunctionReference
                                , arguments = [ left, right ]
                                }
                        )
                        (expressionOperatorToFsharpFunctionReference
                            infixOperation.operator
                        )
                        (infixOperation.left |> expression context)
                        (infixOperation.right |> expression context)

        ElmSyntaxTypeInfer.ExpressionReferenceVariant reference ->
            let
                fsharpReference : { moduleOrigin : Maybe String, name : String }
                fsharpReference =
                    case
                        { moduleOrigin = reference.moduleOrigin
                        , name = reference.name
                        , type_ = expressionTypedNode.type_
                        }
                            |> referenceToCoreFsharp
                    of
                        Just fsharpCoreReference ->
                            fsharpCoreReference

                        Nothing ->
                            { moduleOrigin = Nothing
                            , name =
                                referenceToFsharpName
                                    { moduleOrigin = reference.moduleOrigin
                                    , name = reference.name
                                    }
                            }
            in
            case expressionTypedNode.type_ |> inferredTypeExpandFunction |> .inputs |> List.map type_ of
                [] ->
                    Ok (FsharpExpressionReference fsharpReference)

                valueType0 :: valueType1Up ->
                    let
                        generatedValueVariableReference : Int -> FsharpExpression
                        generatedValueVariableReference valueIndex =
                            FsharpExpressionReference
                                { moduleOrigin = Nothing
                                , name =
                                    "generated_"
                                        ++ (valueIndex |> String.fromInt)
                                }

                        generatedValueTypedPattern : Int -> FsharpPattern
                        generatedValueTypedPattern valueIndex =
                            FsharpPatternVariable
                                ("generated_"
                                    ++ (valueIndex |> String.fromInt)
                                )
                    in
                    Ok
                        (FsharpExpressionLambda
                            { parameters =
                                { pattern = generatedValueTypedPattern 0
                                , type_ = valueType0
                                }
                                    :: (valueType1Up
                                            |> List.indexedMap
                                                (\i valueType ->
                                                    { pattern = generatedValueTypedPattern (i + 1)
                                                    , type_ = valueType
                                                    }
                                                )
                                       )
                            , result =
                                FsharpExpressionCall
                                    { called = FsharpExpressionReference fsharpReference
                                    , arguments =
                                        [ case valueType1Up of
                                            [] ->
                                                generatedValueVariableReference 0

                                            _ :: valueType2Up ->
                                                FsharpExpressionTuple
                                                    { part0 = generatedValueVariableReference 0
                                                    , part1 = generatedValueVariableReference 1
                                                    , part2Up =
                                                        valueType2Up
                                                            |> List.indexedMap
                                                                (\i _ -> generatedValueVariableReference (i + 2))
                                                    }
                                        ]
                                    }
                            }
                        )

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction reference ->
            case
                context.recordTypeAliases
                    |> FastDict.get reference.moduleOrigin
                    |> Maybe.andThen (\byName -> byName |> FastDict.get reference.name)
            of
                Just fieldOrder ->
                    case fieldOrder of
                        [] ->
                            okFsharpExpressionRecordEmpty

                        fieldName0 :: fieldName1Up ->
                            let
                                parameterTypes : List FsharpType
                                parameterTypes =
                                    fsharpTypeExpandFunctionIntoReverse []
                                        (expressionTypedNode.type_ |> type_)
                                        |> List.drop 1
                                        |> List.reverse
                            in
                            Ok
                                (FsharpExpressionLambda
                                    { parameters =
                                        List.map2
                                            (\fieldName fieldType ->
                                                { pattern = FsharpPatternVariable ("generated_" ++ fieldName)
                                                , type_ = fieldType
                                                }
                                            )
                                            (fieldName0 :: fieldName1Up)
                                            parameterTypes
                                    , result =
                                        FsharpExpressionRecord
                                            ((fieldName0 :: fieldName1Up)
                                                |> List.foldl
                                                    (\fieldName soFar ->
                                                        soFar
                                                            |> FastDict.insert fieldName
                                                                (FsharpExpressionReference
                                                                    { moduleOrigin = Nothing
                                                                    , name = "generated_" ++ fieldName
                                                                    }
                                                                )
                                                    )
                                                    FastDict.empty
                                            )
                                    }
                                )

                Nothing ->
                    Err
                        ("could not find declaration for the record type alias constructor "
                            ++ inferredReferenceToInfoString reference
                        )

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            let
                asVariableFromWithinDeclaration : Maybe String
                asVariableFromWithinDeclaration =
                    case reference.moduleOrigin of
                        "" ->
                            let
                                fsharpName : String
                                fsharpName =
                                    reference.name |> variableNameDisambiguateFromFsharpKeywords
                            in
                            if
                                context.variablesFromWithinDeclarationInScope
                                    |> FastSet.member fsharpName
                            then
                                Just fsharpName

                            else
                                Nothing

                        _ ->
                            Nothing
            in
            case asVariableFromWithinDeclaration of
                Just variableFromWithinDeclaration ->
                    Ok
                        (FsharpExpressionReference
                            { moduleOrigin = Nothing
                            , name = variableFromWithinDeclaration
                            }
                        )

                Nothing ->
                    if context.portOutgoingLookup |> FastSet.member ( reference.qualification, reference.name ) then
                        Ok
                            (FsharpExpressionCall
                                { called =
                                    FsharpExpressionReference
                                        { moduleOrigin = Nothing
                                        , name = "PlatformCmd_portOutgoingWithName"
                                        }
                                , arguments =
                                    [ createFsharpExpressionCalStringRopeOne
                                        (FsharpExpressionStringLiteral reference.name)
                                    ]
                                }
                            )

                    else if context.portIncomingLookup |> FastSet.member ( reference.qualification, reference.name ) then
                        Ok
                            (FsharpExpressionCall
                                { called =
                                    FsharpExpressionReference
                                        { moduleOrigin = Nothing
                                        , name = "PlatformSub_portIncomingWithName"
                                        }
                                , arguments =
                                    [ createFsharpExpressionCalStringRopeOne
                                        (FsharpExpressionStringLiteral reference.name)
                                    ]
                                }
                            )

                    else
                        case
                            { moduleOrigin = reference.moduleOrigin
                            , name = reference.name
                            , type_ = expressionTypedNode.type_
                            }
                                |> referenceToCoreFsharp
                        of
                            Just fsharpReference ->
                                Ok (FsharpExpressionReference fsharpReference)

                            Nothing ->
                                case
                                    context.valueAndFunctionAnnotations
                                        |> FastDict.get reference.moduleOrigin
                                        |> Maybe.andThen (\byName -> byName |> FastDict.get reference.name)
                                of
                                    Just annotation ->
                                        Ok
                                            (FsharpExpressionReference
                                                { moduleOrigin = Nothing
                                                , name =
                                                    referenceToFsharpName
                                                        { moduleOrigin = reference.moduleOrigin
                                                        , name = reference.name
                                                        }
                                                        |> fsharpNameWithSpecializedTypes
                                                            (inferredTypeSpecializedVariablesFrom
                                                                annotation
                                                                expressionTypedNode.type_
                                                            )
                                                }
                                            )

                                    Nothing ->
                                        Ok
                                            (FsharpExpressionReference
                                                { moduleOrigin = Nothing
                                                , name =
                                                    referenceToFsharpName
                                                        { moduleOrigin = reference.moduleOrigin
                                                        , name = reference.name
                                                        }
                                                }
                                            )

        ElmSyntaxTypeInfer.ExpressionIfThenElse ifThenElse ->
            Result.map3
                (\condition onTrue onFalse ->
                    FsharpExpressionIfElse
                        { condition = condition
                        , onTrue = onTrue
                        , onFalse = onFalse
                        }
                )
                (ifThenElse.condition |> expression context)
                (ifThenElse.onTrue |> expression context)
                (ifThenElse.onFalse |> expression context)

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            inParens |> expression context

        ElmSyntaxTypeInfer.ExpressionNegation inNegationNode ->
            Result.map
                (\inNegation ->
                    case inNegation of
                        FsharpExpressionInt64 int64 ->
                            FsharpExpressionInt64 -int64

                        FsharpExpressionFloat float ->
                            FsharpExpressionFloat -float

                        nonLiteralNumberInNegation ->
                            FsharpExpressionCall
                                { called =
                                    FsharpExpressionReference
                                        (if inNegationNode.type_ == inferredTypeBasicsFloat then
                                            referenceBasicsFnegate

                                         else
                                            case inNegationNode.type_ of
                                                ElmSyntaxTypeInfer.TypeVariable typeVariable ->
                                                    if typeVariable.name |> String.startsWith "number" then
                                                        -- assume Float
                                                        referenceBasicsFnegate

                                                    else
                                                        -- assume Int
                                                        referenceBasicsInegate

                                                _ ->
                                                    -- assume Int
                                                    referenceBasicsInegate
                                        )
                                , arguments = [ nonLiteralNumberInNegation ]
                                }
                )
                (inNegationNode |> expression context)

        ElmSyntaxTypeInfer.ExpressionRecordAccess recordAccess ->
            Result.map
                (\record ->
                    FsharpExpressionRecordAccess
                        { record = record
                        , field =
                            recordAccess.fieldName
                                |> String.replace "." ""
                                |> stringFirstCharToUpper
                        }
                )
                (recordAccess.record |> expression context)

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            Result.map2
                (\part0 part1 ->
                    FsharpExpressionTuple
                        { part0 = part0
                        , part1 = part1
                        , part2Up = []
                        }
                )
                (parts.part0 |> expression context)
                (parts.part1 |> expression context)

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            Result.map3
                (\part0 part1 part2 ->
                    FsharpExpressionTuple
                        { part0 = part0
                        , part1 = part1
                        , part2Up = [ part2 ]
                        }
                )
                (parts.part0 |> expression context)
                (parts.part1 |> expression context)
                (parts.part2 |> expression context)

        ElmSyntaxTypeInfer.ExpressionList elementNodes ->
            Result.map (\elements -> FsharpExpressionListLiteral elements)
                (elementNodes
                    |> listMapAndCombineOk
                        (\element -> element |> expression context)
                )

        ElmSyntaxTypeInfer.ExpressionRecord fieldNodes ->
            Result.map (\fields -> FsharpExpressionRecord fields)
                (fieldNodes
                    |> listMapAndCombineOk
                        (\field ->
                            Result.map
                                (\fieldValue ->
                                    ( field.name
                                        |> stringFirstCharToUpper
                                    , fieldValue
                                    )
                                )
                                (field.value |> expression context)
                        )
                    |> Result.map FastDict.fromList
                )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate recordUpdate ->
            Result.map
                (\fields ->
                    FsharpExpressionRecordUpdate
                        { originalRecordVariable =
                            referenceToFsharpName
                                { moduleOrigin = recordUpdate.recordVariable.value.moduleOrigin
                                , name =
                                    recordUpdate.recordVariable.value.name
                                }
                                |> variableNameDisambiguateFromFsharpKeywords
                        , fields = fields
                        }
                )
                ((recordUpdate.field0 :: recordUpdate.field1Up)
                    |> listMapAndCombineOk
                        (\field ->
                            Result.map
                                (\fieldValue ->
                                    ( field.name |> stringFirstCharToUpper
                                    , fieldValue
                                    )
                                )
                                (field.value |> expression context)
                        )
                    |> Result.map FastDict.fromList
                )

        ElmSyntaxTypeInfer.ExpressionLambda lambda ->
            resultAndThen2
                (\parameter0 parameter1Up ->
                    Result.map
                        (\result ->
                            FsharpExpressionLambda
                                { parameters =
                                    { pattern = parameter0.pattern
                                    , type_ = parameter0.type_
                                    }
                                        :: (parameter1Up
                                                |> List.map
                                                    (\fsharpParameter ->
                                                        { pattern = fsharpParameter.pattern
                                                        , type_ = fsharpParameter.type_
                                                        }
                                                    )
                                           )
                                , result = result
                                }
                        )
                        (lambda.result
                            |> expression
                                (context
                                    |> expressionContextAddVariablesInScope
                                        (FastSet.union
                                            parameter0.introducedVariables
                                            (parameter1Up
                                                |> listMapToFastSetsAndUnify .introducedVariables
                                            )
                                        )
                                )
                        )
                )
                (lambda.parameter0 |> typedPattern)
                (lambda.parameter1Up
                    |> listMapAndCombineOk
                        (\parameter -> parameter |> typedPattern)
                )

        ElmSyntaxTypeInfer.ExpressionCaseOf caseOf ->
            Result.map3
                (\matched case0 case1Up ->
                    FsharpExpressionMatchWith
                        { matched = matched
                        , case0 = case0
                        , case1Up = case1Up
                        }
                )
                (caseOf.matched |> expression context)
                (caseOf.case0 |> case_ context)
                (caseOf.case1Up
                    |> listMapAndCombineOk
                        (\parameter ->
                            parameter |> case_ context
                        )
                )

        ElmSyntaxTypeInfer.ExpressionLetIn letIn ->
            let
                variablesForWholeLetIn : FastSet.Set String
                variablesForWholeLetIn =
                    (letIn.declaration0 :: letIn.declaration1Up)
                        |> listMapToFastSetsAndUnify
                            (\syntaxLetDeclarationAndRange ->
                                case syntaxLetDeclarationAndRange.declaration of
                                    ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration syntaxLetValueOrFunction ->
                                        FastSet.singleton
                                            (syntaxLetValueOrFunction.name
                                                |> variableNameDisambiguateFromFsharpKeywords
                                            )

                                    ElmSyntaxTypeInfer.LetDestructuring syntaxLetDestructuring ->
                                        syntaxLetDestructuring.pattern
                                            |> patternBindings
                                            |> listMapAndToFastSet
                                                variableNameDisambiguateFromFsharpKeywords
                            )
            in
            Result.map3
                (\declaration0 declaration1Up result ->
                    FsharpExpressionWithLetDeclarations
                        { declaration0 = declaration0
                        , declaration1Up = declaration1Up
                        , result = result
                        }
                )
                (letIn.declaration0.declaration
                    |> letDeclaration
                        (context
                            |> expressionContextAddVariablesInScope
                                variablesForWholeLetIn
                        )
                )
                (letIn.declaration1Up
                    |> listMapAndCombineOk
                        (\letDecl ->
                            letDecl.declaration
                                |> letDeclaration
                                    (context
                                        |> expressionContextAddVariablesInScope
                                            variablesForWholeLetIn
                                    )
                        )
                )
                (letIn.result
                    |> expression
                        (context
                            |> expressionContextAddVariablesInScope
                                variablesForWholeLetIn
                        )
                )


okFsharpExpressionRecordEmpty : Result error_ FsharpExpression
okFsharpExpressionRecordEmpty =
    Ok (FsharpExpressionRecord FastDict.empty)


referenceBasicsInegate : { moduleOrigin : Maybe String, name : String }
referenceBasicsInegate =
    { moduleOrigin = Nothing, name = "Basics_inegate" }


referenceBasicsFnegate : { moduleOrigin : Maybe String, name : String }
referenceBasicsFnegate =
    { moduleOrigin = Nothing, name = "Basics_fnegate" }


fsharpExpressionReferenceListAppend : FsharpExpression
fsharpExpressionReferenceListAppend =
    FsharpExpressionReference
        { moduleOrigin = Just "List"
        , name = "append"
        }


fsharpExpressionReferenceStringAppend : FsharpExpression
fsharpExpressionReferenceStringAppend =
    FsharpExpressionReference
        { moduleOrigin = Nothing
        , name = "String_append"
        }


inferredReferenceToInfoString :
    { qualification : String, moduleOrigin : String, name : String }
    -> String
inferredReferenceToInfoString reference =
    case reference.moduleOrigin of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            moduleOriginNotEmpty
                ++ "."
                ++ reference.name


createFsharpExpressionCalStringRopeOne : FsharpExpression -> FsharpExpression
createFsharpExpressionCalStringRopeOne argument =
    FsharpExpressionCall
        { called = fsharpExpressionReferenceStringRopeOne
        , arguments = [ argument ]
        }


fsharpExpressionReferenceStringRopeOne : FsharpExpression
fsharpExpressionReferenceStringRopeOne =
    FsharpExpressionReference
        { moduleOrigin = Nothing
        , name = "StringRopeOne"
        }


fsharpExpressionIsEmptyString : FsharpExpression -> Bool
fsharpExpressionIsEmptyString fsharpExpression =
    fsharpExpression == fsharpExpressionStringRopeEmpty


fsharpExpressionStringRopeEmpty : FsharpExpression
fsharpExpressionStringRopeEmpty =
    createFsharpExpressionCalStringRopeOne
        (FsharpExpressionStringLiteral "")


inferredTypeExpandFunction :
    ElmSyntaxTypeInfer.Type
    ->
        { inputs : List ElmSyntaxTypeInfer.Type
        , output : ElmSyntaxTypeInfer.Type
        }
inferredTypeExpandFunction inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
            let
                outputExpanded :
                    { inputs : List ElmSyntaxTypeInfer.Type
                    , output : ElmSyntaxTypeInfer.Type
                    }
                outputExpanded =
                    typeFunction.output |> inferredTypeExpandFunction
            in
            { inputs = typeFunction.input :: outputExpanded.inputs
            , output = outputExpanded.output
            }

        typeNotFunction ->
            { inputs = [], output = typeNotFunction }


{-| Recursively find all introduced variables
in the [pattern](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Pattern)
(like `a` and `b` in `( Just a, { b } )`)
-}
patternBindings :
    ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
    -> List String
patternBindings syntaxPattern =
    -- IGNORE TCO
    case syntaxPattern.value of
        ElmSyntaxTypeInfer.PatternVariable name ->
            [ name ]

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            patternAs.variable.value
                :: (patternAs.pattern |> patternBindings)

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            inParens |> patternBindings

        ElmSyntaxTypeInfer.PatternListExact elements ->
            elements |> List.concatMap patternBindings

        ElmSyntaxTypeInfer.PatternTuple parts ->
            (parts.part0 |> patternBindings)
                ++ (parts.part1 |> patternBindings)

        ElmSyntaxTypeInfer.PatternTriple parts ->
            (parts.part0 |> patternBindings)
                ++ (parts.part1 |> patternBindings)
                ++ (parts.part2 |> patternBindings)

        ElmSyntaxTypeInfer.PatternRecord fields ->
            fields |> List.map .value

        ElmSyntaxTypeInfer.PatternVariant patternVariant ->
            patternVariant.values |> List.concatMap patternBindings

        ElmSyntaxTypeInfer.PatternListCons listCons ->
            (listCons.head |> patternBindings) ++ (listCons.head |> patternBindings)

        ElmSyntaxTypeInfer.PatternIgnored ->
            []

        ElmSyntaxTypeInfer.PatternUnit ->
            []

        ElmSyntaxTypeInfer.PatternChar _ ->
            []

        ElmSyntaxTypeInfer.PatternString _ ->
            []

        ElmSyntaxTypeInfer.PatternInt _ ->
            []


resultAndThen2 :
    (a -> b -> Result error c)
    -> Result error a
    -> Result error b
    -> Result error c
resultAndThen2 abToResult aResult bResult =
    case aResult of
        Err error ->
            Err error

        Ok a ->
            case bResult of
                Err error ->
                    Err error

                Ok b ->
                    abToResult a b


listOfFastDictsUnify :
    List (FastDict.Dict comparableKey value)
    -> FastDict.Dict comparableKey value
listOfFastDictsUnify list =
    list
        |> List.foldl
            FastDict.union
            FastDict.empty


listMapToFastDictsAndUnify :
    (element -> FastDict.Dict comparableKey value)
    -> List element
    -> FastDict.Dict comparableKey value
listMapToFastDictsAndUnify elementToFastDict list =
    list
        |> List.foldl
            (\element soFar ->
                FastDict.union soFar (element |> elementToFastDict)
            )
            FastDict.empty


listMapToFastSetsAndUnify :
    (listElement -> FastSet.Set comparableFastSetElement)
    -> List listElement
    -> FastSet.Set comparableFastSetElement
listMapToFastSetsAndUnify elementToSet list =
    list
        |> List.foldl
            (\element soFar ->
                FastSet.union
                    (element |> elementToSet)
                    soFar
            )
            FastSet.empty


listMapAndToFastSet :
    (a -> comparable)
    -> List a
    -> FastSet.Set comparable
listMapAndToFastSet elementToSetElement list =
    list
        |> List.foldl
            (\element soFar ->
                soFar
                    |> FastSet.insert
                        (element |> elementToSetElement)
            )
            FastSet.empty


condenseExpressionCall :
    { called : FsharpExpression
    , argument0 : FsharpExpression
    , argument1Up : List FsharpExpression
    }
    -> FsharpExpression
condenseExpressionCall call =
    case call.called of
        FsharpExpressionCall calledCall ->
            case calledCall.arguments of
                [] ->
                    FsharpExpressionCall
                        { called = call.called
                        , arguments = call.argument0 :: call.argument1Up
                        }

                calledCallArgument0 :: calledCallArgument1Up ->
                    condenseExpressionCall
                        { called = calledCall.called
                        , argument0 = calledCallArgument0
                        , argument1Up =
                            calledCallArgument1Up
                                ++ (call.argument0 :: call.argument1Up)
                        }

        FsharpExpressionLambda calledLambda ->
            case ( calledLambda.parameters |> List.map .pattern, calledLambda.result ) of
                ( (FsharpPatternVariable "generated_record") :: _, FsharpExpressionRecordAccess recordAccess ) ->
                    case call.argument1Up of
                        [] ->
                            FsharpExpressionRecordAccess
                                { record = call.argument0
                                , field = recordAccess.field
                                }

                        argument1 :: argument2Up ->
                            FsharpExpressionCall
                                { called =
                                    FsharpExpressionRecordAccess
                                        { record = call.argument0
                                        , field = recordAccess.field
                                        }
                                , arguments = argument1 :: argument2Up
                                }

                ( (FsharpPatternVariable "generated_0") :: lambdaParameter1Up, FsharpExpressionCall variantCall ) ->
                    if (lambdaParameter1Up |> List.length) == (call.argument1Up |> List.length) then
                        FsharpExpressionCall
                            { called = variantCall.called
                            , arguments =
                                [ case call.argument1Up of
                                    [] ->
                                        call.argument0

                                    callArgument1 :: callArgument2Up ->
                                        FsharpExpressionTuple
                                            { part0 = call.argument0
                                            , part1 = callArgument1
                                            , part2Up = callArgument2Up
                                            }
                                ]
                            }

                    else
                        FsharpExpressionCall
                            { called = FsharpExpressionLambda calledLambda
                            , arguments = call.argument0 :: call.argument1Up
                            }

                _ ->
                    FsharpExpressionCall
                        { called = FsharpExpressionLambda calledLambda
                        , arguments = call.argument0 :: call.argument1Up
                        }

        FsharpExpressionReference reference ->
            case callAsArrayFromList reference call.argument0 of
                Just elements ->
                    FsharpExpressionArrayLiteral elements

                Nothing ->
                    FsharpExpressionCall
                        { called = FsharpExpressionReference reference
                        , arguments = call.argument0 :: call.argument1Up
                        }

        calledNotCall ->
            FsharpExpressionCall
                { called = calledNotCall
                , arguments = call.argument0 :: call.argument1Up
                }


callAsArrayFromList :
    { moduleOrigin : Maybe String, name : String }
    -> FsharpExpression
    -> Maybe (List FsharpExpression)
callAsArrayFromList reference argument =
    case reference.name of
        "fromList" ->
            case reference.moduleOrigin of
                Nothing ->
                    Nothing

                Just moduleOrigin ->
                    case moduleOrigin of
                        "Array" ->
                            case argument of
                                FsharpExpressionListLiteral elements ->
                                    Just elements

                                FsharpExpressionArrayLiteral _ ->
                                    Nothing

                                FsharpExpressionUnit ->
                                    Nothing

                                FsharpExpressionFloat _ ->
                                    Nothing

                                FsharpExpressionInt64 _ ->
                                    Nothing

                                FsharpExpressionChar _ ->
                                    Nothing

                                FsharpExpressionStringLiteral _ ->
                                    Nothing

                                FsharpExpressionReference _ ->
                                    Nothing

                                FsharpExpressionRecordAccess _ ->
                                    Nothing

                                FsharpExpressionTuple _ ->
                                    Nothing

                                FsharpExpressionIfElse _ ->
                                    Nothing

                                FsharpExpressionRecord _ ->
                                    Nothing

                                FsharpExpressionRecordUpdate _ ->
                                    Nothing

                                FsharpExpressionCall _ ->
                                    Nothing

                                FsharpExpressionLambda _ ->
                                    Nothing

                                FsharpExpressionMatchWith _ ->
                                    Nothing

                                FsharpExpressionWithLetDeclarations _ ->
                                    Nothing

                        _ ->
                            Nothing

        _ ->
            Nothing


case_ :
    { valueAndFunctionAnnotations :
        FastDict.Dict
            -- module origin
            String
            (FastDict.Dict
                String
                Elm.Syntax.TypeAnnotation.TypeAnnotation
            )
    , recordTypeAliases :
        FastDict.Dict
            String
            (FastDict.Dict
                String
                (List String)
            )
    , portIncomingLookup : FastSet.Set ( String, String )
    , portOutgoingLookup : FastSet.Set ( String, String )
    , variablesFromWithinDeclarationInScope : FastSet.Set String
    }
    ->
        { pattern :
            ElmSyntaxTypeInfer.TypedNode
                ElmSyntaxTypeInfer.Pattern
        , result :
            ElmSyntaxTypeInfer.TypedNode
                ElmSyntaxTypeInfer.Expression
        }
    ->
        Result
            String
            { pattern : FsharpPattern
            , patternType : FsharpType
            , result : FsharpExpression
            }
case_ context syntaxCase =
    Result.andThen
        (\casePattern ->
            Result.map
                (\result ->
                    { pattern = casePattern.pattern
                    , patternType = casePattern.type_
                    , result = result
                    }
                )
                (syntaxCase.result
                    |> expression
                        (context
                            |> expressionContextAddVariablesInScope
                                casePattern.introducedVariables
                        )
                )
        )
        (syntaxCase.pattern |> typedPattern)


letDeclaration :
    { valueAndFunctionAnnotations :
        FastDict.Dict
            -- module origin
            String
            (FastDict.Dict
                String
                Elm.Syntax.TypeAnnotation.TypeAnnotation
            )
    , recordTypeAliases :
        FastDict.Dict
            String
            (FastDict.Dict
                String
                (List String)
            )
    , portIncomingLookup : FastSet.Set ( String, String )
    , portOutgoingLookup : FastSet.Set ( String, String )
    , variablesFromWithinDeclarationInScope : FastSet.Set String
    }
    -> ElmSyntaxTypeInfer.LetDeclaration
    -> Result String FsharpLetDeclaration
letDeclaration context syntaxLetDeclaration =
    case syntaxLetDeclaration of
        ElmSyntaxTypeInfer.LetDestructuring letDestructuring ->
            Result.map2
                (\destructuringPattern destructuringExpression ->
                    FsharpLetDestructuring
                        { pattern = destructuringPattern.pattern
                        , patternType = destructuringPattern.type_
                        , expression = destructuringExpression
                        }
                )
                (letDestructuring.pattern |> typedPattern)
                (letDestructuring.expression |> expression context)

        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration letValueOrFunction ->
            Result.map
                FsharpLetDeclarationValueOrFunction
                (letValueOrFunction
                    |> letValueOrFunctionDeclaration context
                )


letValueOrFunctionDeclaration :
    { valueAndFunctionAnnotations :
        FastDict.Dict
            -- module origin
            String
            (FastDict.Dict
                String
                Elm.Syntax.TypeAnnotation.TypeAnnotation
            )
    , recordTypeAliases :
        FastDict.Dict
            String
            (FastDict.Dict
                String
                (List String)
            )
    , portIncomingLookup : FastSet.Set ( String, String )
    , portOutgoingLookup : FastSet.Set ( String, String )
    , variablesFromWithinDeclarationInScope : FastSet.Set String
    }
    ->
        { signature :
            Maybe
                { range : Elm.Syntax.Range.Range
                , nameRange : Elm.Syntax.Range.Range
                , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                , annotationTypeRange : Elm.Syntax.Range.Range
                }
        , nameRange : Elm.Syntax.Range.Range
        , name : String
        , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
        , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
        , type_ : ElmSyntaxTypeInfer.Type
        }
    ->
        Result
            String
            { name : String
            , parameters : List { pattern : FsharpPattern, type_ : FsharpType }
            , result : FsharpExpression
            , resultType : FsharpType
            }
letValueOrFunctionDeclaration context syntaxLetDeclarationValueOrFunction =
    Result.andThen
        (\parameters ->
            Result.map
                (\result ->
                    { name =
                        syntaxLetDeclarationValueOrFunction.name
                            |> variableNameDisambiguateFromFsharpKeywords
                    , parameters =
                        parameters
                            |> List.map
                                (\parameter ->
                                    { pattern = parameter.pattern
                                    , type_ = parameter.type_
                                    }
                                )
                    , result = result
                    , resultType =
                        case syntaxLetDeclarationValueOrFunction.parameters of
                            [] ->
                                syntaxLetDeclarationValueOrFunction.type_ |> type_

                            _ :: _ ->
                                syntaxLetDeclarationValueOrFunction.result.type_ |> type_
                    }
                )
                (syntaxLetDeclarationValueOrFunction.result
                    |> expression
                        (context
                            |> expressionContextAddVariablesInScope
                                (parameters
                                    |> listMapToFastSetsAndUnify .introducedVariables
                                )
                        )
                )
        )
        (syntaxLetDeclarationValueOrFunction.parameters
            |> listMapAndCombineOk
                (\p -> p |> typedPattern)
        )


expressionOperatorToFsharpFunctionReference :
    { symbol : String
    , moduleOrigin : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    -> Result String { moduleOrigin : Maybe String, name : String }
expressionOperatorToFsharpFunctionReference operator =
    case operator.symbol of
        "+" ->
            okReferenceAdd

        "-" ->
            okReferenceSub

        "*" ->
            okReferenceMul

        "/" ->
            okReferenceDivIntOrFloat

        "//" ->
            okReferenceDivIntOrFloat

        "^" ->
            case operator.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                    if typeFunction.input == inferredTypeBasicsFloat then
                        okReferenceFpow

                    else
                        case typeFunction.input of
                            ElmSyntaxTypeInfer.TypeVariable inputTypeVariable ->
                                if inputTypeVariable.name |> String.startsWith "number" then
                                    -- assume Float
                                    okReferenceFpow

                                else
                                    -- assume Int
                                    okReferenceIpow

                            _ ->
                                -- assume Int
                                okReferenceIpow

                _ ->
                    -- assume Int
                    okReferenceIpow

        "==" ->
            okReferenceEq

        "/=" ->
            okReferenceNeq

        "||" ->
            okReferenceOr

        "&&" ->
            okReferenceAnd

        "<" ->
            okReferenceLt

        ">" ->
            okReferenceGt

        "<=" ->
            okReferenceLe

        ">=" ->
            okReferenceGe

        "::" ->
            okReferenceListCons

        "++" ->
            case operator.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                    if typeFunction.input == inferredTypeString then
                        okReferenceStringAppend

                    else
                        -- assume List
                        okReferenceListAppend

                _ ->
                    -- assume List
                    okReferenceListAppend

        "|>" ->
            okReferenceApR

        "<|" ->
            okReferenceApL

        ">>" ->
            okReferenceComposeR

        "<<" ->
            okReferenceComposeL

        "|=" ->
            okReferenceParserAdvancedKeeper

        "|." ->
            okReferenceParserAdvancedIgnorer

        "</>" ->
            okReferenceUrlParserSlash

        "<?>" ->
            okReferenceUrlParserQuestionMark

        unknownOrUnsupportedOperator ->
            Err ("unknown/unsupported operator " ++ unknownOrUnsupportedOperator)


okReferenceIpow : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceIpow =
    Ok { moduleOrigin = Nothing, name = "Basics_ipow" }


okReferenceFpow : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceFpow =
    Ok { moduleOrigin = Nothing, name = "Basics_fpow" }


okReferenceNeq : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceNeq =
    Ok { moduleOrigin = Nothing, name = "Basics_neq" }


okReferenceEq : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceEq =
    Ok { moduleOrigin = Nothing, name = "Basics_eq" }


okReferenceOr : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceOr =
    Ok { moduleOrigin = Nothing, name = "Basics_or" }


okReferenceAnd : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceAnd =
    Ok { moduleOrigin = Nothing, name = "Basics_and" }


okReferenceLt : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceLt =
    Ok { moduleOrigin = Nothing, name = "(<)" }


okReferenceGt : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceGt =
    Ok { moduleOrigin = Nothing, name = "(>)" }


okReferenceLe : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceLe =
    Ok { moduleOrigin = Nothing, name = "(<=)" }


okReferenceGe : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceGe =
    Ok { moduleOrigin = Nothing, name = "(>=)" }


okReferenceMul : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceMul =
    Ok { moduleOrigin = Nothing, name = "(*)" }


okReferenceDivIntOrFloat : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceDivIntOrFloat =
    Ok { moduleOrigin = Nothing, name = "(/)" }


okReferenceSub : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceSub =
    Ok { moduleOrigin = Nothing, name = "(-)" }


okReferenceAdd : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceAdd =
    Ok { moduleOrigin = Nothing, name = "(+)" }


okReferenceApR : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceApR =
    Ok { moduleOrigin = Nothing, name = "(|>)" }


okReferenceApL : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceApL =
    Ok { moduleOrigin = Nothing, name = "(<|)" }


okReferenceComposeR : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceComposeR =
    Ok { moduleOrigin = Nothing, name = "(>>)" }


okReferenceComposeL : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceComposeL =
    Ok { moduleOrigin = Nothing, name = "(<<)" }


okReferenceParserAdvancedKeeper : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceParserAdvancedKeeper =
    Ok { moduleOrigin = Nothing, name = "ParserAdvanced_keeper" }


okReferenceParserAdvancedIgnorer : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceParserAdvancedIgnorer =
    Ok { moduleOrigin = Nothing, name = "ParserAdvanced_ignorer" }


okReferenceUrlParserSlash : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceUrlParserSlash =
    Ok { moduleOrigin = Nothing, name = "UrlParser_slash" }


okReferenceUrlParserQuestionMark : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceUrlParserQuestionMark =
    Ok { moduleOrigin = Nothing, name = "UrlParser_questionMark" }


okReferenceListCons : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceListCons =
    Ok { moduleOrigin = Nothing, name = "List_cons" }


okReferenceStringAppend : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceStringAppend =
    Ok { moduleOrigin = Nothing, name = "String_append" }


okReferenceListAppend : Result error_ { moduleOrigin : Maybe String, name : String }
okReferenceListAppend =
    Ok { moduleOrigin = Just "List", name = "append" }


inferredTypeString : ElmSyntaxTypeInfer.Type
inferredTypeString =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "String"
            , name = "String"
            , arguments = []
            }
        )


{-| Print a fsharp value/function declaration
-}
printFsharpValueOrFunctionDeclaration :
    { name : String
    , parameters : List { pattern : FsharpPattern, type_ : FsharpType }
    , result : FsharpExpression
    , resultType : FsharpType
    }
    -> Print
printFsharpValueOrFunctionDeclaration fsharpValueOrFunctionDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printFsharpTypeNotParenthesized
                fsharpValueOrFunctionDeclaration.resultType
    in
    case fsharpValueOrFunctionDeclaration.parameters of
        parameter0 :: parameter1Up ->
            let
                parameterPrints : List Print
                parameterPrints =
                    (parameter0 :: parameter1Up)
                        |> List.map
                            (\parameter ->
                                let
                                    parameterTypePrint : Print
                                    parameterTypePrint =
                                        printFsharpTypeNotParenthesized
                                            parameter.type_
                                in
                                printParenthesized
                                    ((parameter.pattern
                                        |> printFsharpPatternParenthesizedIfSpaceSeparated
                                     )
                                        |> Print.followedBy printExactlyColon
                                        |> Print.followedBy
                                            (Print.withIndentIncreasedBy 1
                                                (Print.withIndentAtNextMultipleOf4
                                                    (Print.spaceOrLinebreakIndented
                                                        (parameterTypePrint |> Print.lineSpread)
                                                        |> Print.followedBy
                                                            parameterTypePrint
                                                    )
                                                )
                                            )
                                    )
                            )

                headerLineSpread : Print.LineSpread
                headerLineSpread =
                    resultTypePrint
                        |> Print.lineSpread
                        |> Print.lineSpreadMergeWith
                            (\() ->
                                parameterPrints
                                    |> Print.lineSpreadListMapAndCombine
                                        Print.lineSpread
                            )
            in
            Print.exactly
                fsharpValueOrFunctionDeclaration.name
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 4
                        (parameterPrints
                            |> Print.listMapAndIntersperseAndFlatten
                                (\parameterPrint ->
                                    Print.spaceOrLinebreakIndented headerLineSpread
                                        |> Print.followedBy parameterPrint
                                )
                                Print.empty
                            |> Print.followedBy
                                (Print.spaceOrLinebreakIndented headerLineSpread)
                            |> Print.followedBy printExactlyColonSpace
                            |> Print.followedBy
                                (Print.withIndentIncreasedBy 2
                                    resultTypePrint
                                )
                            |> Print.followedBy printExactlySpaceEquals
                            |> Print.followedBy
                                (Print.linebreakIndented
                                    |> Print.followedBy
                                        (printFsharpExpressionNotParenthesized
                                            fsharpValueOrFunctionDeclaration.result
                                        )
                                )
                        )
                    )

        [] ->
            let
                typeVariablesToDeclare : List String
                typeVariablesToDeclare =
                    fsharpValueOrFunctionDeclaration.resultType
                        |> fsharpTypeContainedVariables
                        |> FastSet.toList
            in
            Print.exactly
                (fsharpValueOrFunctionDeclaration.name
                    ++ (case typeVariablesToDeclare of
                            [] ->
                                ""

                            parameter0 :: parameter1Up ->
                                "<"
                                    ++ ((parameter0 :: parameter1Up)
                                            |> List.map
                                                (\parameter -> "'" ++ parameter)
                                            |> String.join ", "
                                       )
                                    ++ (case
                                            (parameter0 :: parameter1Up)
                                                |> List.filter (\parameter -> parameter |> String.startsWith "comparable")
                                        of
                                            [] ->
                                                ""

                                            comparableParameter0 :: comparableParameter1Up ->
                                                " when "
                                                    ++ ((comparableParameter0 :: comparableParameter1Up)
                                                            |> List.map
                                                                (\parameter ->
                                                                    "'" ++ parameter ++ ": comparison"
                                                                )
                                                            |> String.join ", "
                                                       )
                                       )
                                    ++ ">"
                       )
                    ++ ""
                )
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        ((let
                            fullLineSpread : Print.LineSpread
                            fullLineSpread =
                                resultTypePrint |> Print.lineSpread
                          in
                          printExactlyColon
                            |> Print.followedBy
                                (Print.withIndentAtNextMultipleOf4
                                    (Print.spaceOrLinebreakIndented fullLineSpread
                                        |> Print.followedBy resultTypePrint
                                    )
                                )
                         )
                            |> Print.followedBy
                                printExactlySpaceEquals
                            |> Print.followedBy
                                (Print.linebreakIndented
                                    |> Print.followedBy
                                        (printFsharpExpressionParenthesizedIfWithLetDeclarations
                                            fsharpValueOrFunctionDeclaration.result
                                        )
                                )
                        )
                    )


fsharpTypeContainedVariables : FsharpType -> FastSet.Set String
fsharpTypeContainedVariables fsharpType =
    -- IGNORE TCO
    case fsharpType of
        FsharpTypeVariable variable ->
            FastSet.singleton variable

        FsharpTypeTuple parts ->
            FastSet.union
                (parts.part0 |> fsharpTypeContainedVariables)
                (FastSet.union
                    (parts.part1 |> fsharpTypeContainedVariables)
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify
                            fsharpTypeContainedVariables
                    )
                )

        FsharpTypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastSetsAndUnify fsharpTypeContainedVariables

        FsharpTypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input |> fsharpTypeContainedVariables)
                (typeFunction.output |> fsharpTypeContainedVariables)


printFsharpLocalLetValueOrFunctionDeclaration :
    { name : String
    , parameters : List { pattern : FsharpPattern, type_ : FsharpType }
    , result : FsharpExpression
    , resultType : FsharpType
    }
    -> Print
printFsharpLocalLetValueOrFunctionDeclaration fsharpValueOrFunctionDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printFsharpTypeNotParenthesized
                fsharpValueOrFunctionDeclaration.resultType
    in
    case fsharpValueOrFunctionDeclaration.parameters of
        parameter0 :: parameter1Up ->
            let
                parameterPrints : List Print
                parameterPrints =
                    (parameter0 :: parameter1Up)
                        |> List.map
                            (\parameter ->
                                let
                                    parameterTypePrint : Print
                                    parameterTypePrint =
                                        printFsharpTypeNotParenthesized
                                            parameter.type_
                                in
                                printParenthesized
                                    ((parameter.pattern
                                        |> printFsharpPatternParenthesizedIfSpaceSeparated
                                     )
                                        |> Print.followedBy printExactlyColon
                                        |> Print.followedBy
                                            (Print.withIndentIncreasedBy 1
                                                (Print.withIndentAtNextMultipleOf4
                                                    (Print.spaceOrLinebreakIndented
                                                        (parameterTypePrint |> Print.lineSpread)
                                                        |> Print.followedBy
                                                            parameterTypePrint
                                                    )
                                                )
                                            )
                                    )
                            )

                headerLineSpread : Print.LineSpread
                headerLineSpread =
                    resultTypePrint
                        |> Print.lineSpread
                        |> Print.lineSpreadMergeWith
                            (\() ->
                                parameterPrints
                                    |> Print.lineSpreadListMapAndCombine
                                        Print.lineSpread
                            )
            in
            Print.exactly
                fsharpValueOrFunctionDeclaration.name
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 4
                        (parameterPrints
                            |> Print.listMapAndIntersperseAndFlatten
                                (\parameterPrint ->
                                    Print.spaceOrLinebreakIndented headerLineSpread
                                        |> Print.followedBy parameterPrint
                                )
                                Print.empty
                            |> Print.followedBy
                                (Print.spaceOrLinebreakIndented headerLineSpread)
                            |> Print.followedBy printExactlyColonSpace
                            |> Print.followedBy
                                (Print.withIndentIncreasedBy 2
                                    resultTypePrint
                                )
                            |> Print.followedBy printExactlySpaceEquals
                            |> Print.followedBy
                                (Print.linebreakIndented
                                    |> Print.followedBy
                                        (printFsharpExpressionNotParenthesized
                                            fsharpValueOrFunctionDeclaration.result
                                        )
                                )
                        )
                    )

        [] ->
            Print.exactly
                fsharpValueOrFunctionDeclaration.name
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        ((printExactlyColon
                            |> Print.followedBy
                                (Print.withIndentAtNextMultipleOf4
                                    (Print.spaceOrLinebreakIndented
                                        (resultTypePrint |> Print.lineSpread)
                                        |> Print.followedBy resultTypePrint
                                    )
                                )
                         )
                            |> Print.followedBy printExactlySpaceEqualsLinebreakIndented
                            |> Print.followedBy
                                (printFsharpExpressionParenthesizedIfWithLetDeclarations
                                    fsharpValueOrFunctionDeclaration.result
                                )
                        )
                    )


printExactlySpaceEqualsLinebreakIndented : Print
printExactlySpaceEqualsLinebreakIndented =
    printExactlySpaceEquals
        |> Print.followedBy Print.linebreakIndented


printExactlyColonSpace : Print
printExactlyColonSpace =
    Print.exactly ": "


type FsharpValueOrFunctionDependencyBucket element
    = FsharpValueOrFunctionDependencySingle element
    | FsharpValueOrFunctionDependencyRecursiveBucket (List element)


fsharpValueOrFunctionDeclarationsGroupByDependencies :
    List
        { name : String
        , parameters : List { pattern : FsharpPattern, type_ : FsharpType }
        , result : FsharpExpression
        , resultType : FsharpType
        }
    ->
        { mostToLeastDependedOn :
            List
                (FsharpValueOrFunctionDependencyBucket
                    { name : String
                    , parameters : List { pattern : FsharpPattern, type_ : FsharpType }
                    , result : FsharpExpression
                    , resultType : FsharpType
                    }
                )
        }
fsharpValueOrFunctionDeclarationsGroupByDependencies fsharpValueOrFunctionDeclarations =
    { mostToLeastDependedOn =
        fsharpValueOrFunctionDeclarations
            |> List.map
                (\fsharpValueOrFunctionDeclaration ->
                    ( fsharpValueOrFunctionDeclaration
                    , fsharpValueOrFunctionDeclaration.name
                    , fsharpValueOrFunctionDeclaration.result
                        |> fsharpExpressionUsedLocalReferences
                        |> FastSet.toList
                    )
                )
            |> Data.Graph.stronglyConnCompR
            |> List.map
                (\edge0 ->
                    case edge0 of
                        Data.Graph.AcyclicSCC ( n, _, _ ) ->
                            FsharpValueOrFunctionDependencySingle n

                        Data.Graph.CyclicSCC triples ->
                            FsharpValueOrFunctionDependencyRecursiveBucket
                                (List.map (\( n, _, _ ) -> n) triples)
                )
    }


type FsharpChoiceTypeOrTypeAliasDeclaration
    = FsharpChoiceTypeDeclaration
        { name : String
        , parameters : List String
        , variants : FastDict.Dict String (Maybe FsharpType)
        }
    | FsharpTypeAliasDeclaration
        { name : String
        , parameters : List String
        , type_ : FsharpType
        }


fsharpTypeDeclarationsGroupByDependencies :
    { typeAliases :
        List
            { name : String
            , parameters : List String
            , type_ : FsharpType
            }
    , enums :
        List
            { name : String
            , parameters : List String
            , variants : FastDict.Dict String (Maybe FsharpType)
            }
    }
    ->
        { mostToLeastDependedOn :
            List
                (FsharpValueOrFunctionDependencyBucket
                    FsharpChoiceTypeOrTypeAliasDeclaration
                )
        }
fsharpTypeDeclarationsGroupByDependencies fsharpTypeDeclarations =
    { mostToLeastDependedOn =
        fsharpTypeDeclarations.typeAliases
            |> List.foldl
                (\aliasDeclaration soFar ->
                    ( FsharpTypeAliasDeclaration aliasDeclaration
                    , aliasDeclaration.name
                    , aliasDeclaration.type_
                        |> fsharpTypeContainedLocalReferences
                        |> FastSet.toList
                    )
                        :: soFar
                )
                (fsharpTypeDeclarations.enums
                    |> List.map
                        (\enumDeclaration ->
                            ( FsharpChoiceTypeDeclaration enumDeclaration
                            , enumDeclaration.name
                            , enumDeclaration.variants
                                |> FastDict.foldl
                                    (\_ maybeVariantValue soFar ->
                                        case maybeVariantValue of
                                            Nothing ->
                                                soFar

                                            Just variantValue ->
                                                FastSet.union soFar
                                                    (variantValue
                                                        |> fsharpTypeContainedLocalReferences
                                                    )
                                    )
                                    FastSet.empty
                                |> FastSet.toList
                            )
                        )
                )
            |> Data.Graph.stronglyConnCompR
            |> List.map
                (\edge0 ->
                    case edge0 of
                        Data.Graph.AcyclicSCC ( n, _, _ ) ->
                            FsharpValueOrFunctionDependencySingle n

                        Data.Graph.CyclicSCC triples ->
                            FsharpValueOrFunctionDependencyRecursiveBucket
                                (List.map (\( n, _, _ ) -> n) triples)
                )
    }


fsharpTypeContainedLocalReferences : FsharpType -> FastSet.Set String
fsharpTypeContainedLocalReferences fsharpType =
    -- IGNORE TCO
    case fsharpType of
        FsharpTypeVariable _ ->
            FastSet.empty

        FsharpTypeTuple parts ->
            FastSet.union
                (parts.part0 |> fsharpTypeContainedLocalReferences)
                (FastSet.union
                    (parts.part1 |> fsharpTypeContainedLocalReferences)
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify
                            fsharpTypeContainedLocalReferences
                    )
                )

        FsharpTypeConstruct typeConstruct ->
            FastSet.union
                (case typeConstruct.moduleOrigin of
                    Nothing ->
                        FastSet.singleton typeConstruct.name

                    Just _ ->
                        FastSet.empty
                )
                (typeConstruct.arguments
                    |> listMapToFastSetsAndUnify fsharpTypeContainedLocalReferences
                )

        FsharpTypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input |> fsharpTypeContainedLocalReferences)
                (typeFunction.output |> fsharpTypeContainedLocalReferences)


{-| Choose one element in the list for each key.
List all possibilities
-}
fastDictPermutations :
    FastDict.Dict comparableKey (List option)
    -> List (FastDict.Dict comparableKey option)
fastDictPermutations specializations =
    specializations
        |> FastDict.foldl
            (\variable variableSpecializations soFar ->
                variableSpecializations
                    |> List.concatMap
                        (\variableSpecialization ->
                            soFar
                                |> List.map
                                    (\permutationSoFar ->
                                        permutationSoFar
                                            |> FastDict.insert variable variableSpecialization
                                    )
                        )
            )
            [ FastDict.empty ]


type FsharpTypeVariableSpecialization
    = FsharpTypeVariableSpecializationToInt
    | FsharpTypeVariableSpecializationToFloat
    | FsharpTypeVariableSpecializationToRecord (List String)


syntaxTypeSplitIntoSpecializedFsharpTypes :
    FastSet.Set (List String)
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> FastDict.Dict String (List FsharpTypeVariableSpecialization)
syntaxTypeSplitIntoSpecializedFsharpTypes allFsharpRecords (Elm.Syntax.Node.Node _ syntaxType) =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            FastDict.empty

        Elm.Syntax.TypeAnnotation.GenericType variable ->
            if variable |> String.startsWith "number" then
                FastDict.singleton variable
                    [ FsharpTypeVariableSpecializationToInt
                    , FsharpTypeVariableSpecializationToFloat
                    ]

            else
                FastDict.empty

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            parts
                |> listMapToFastDictsAndUnify
                    (\part ->
                        part |> syntaxTypeSplitIntoSpecializedFsharpTypes allFsharpRecords
                    )

        Elm.Syntax.TypeAnnotation.Typed _ arguments ->
            arguments
                |> listMapToFastDictsAndUnify
                    (\argument ->
                        argument |> syntaxTypeSplitIntoSpecializedFsharpTypes allFsharpRecords
                    )

        Elm.Syntax.TypeAnnotation.Record fields ->
            fields
                |> listMapToFastDictsAndUnify
                    (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                        value |> syntaxTypeSplitIntoSpecializedFsharpTypes allFsharpRecords
                    )

        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ recordVariable) (Elm.Syntax.Node.Node _ fields) ->
            fields
                |> listMapToFastDictsAndUnify
                    (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                        value |> syntaxTypeSplitIntoSpecializedFsharpTypes allFsharpRecords
                    )
                |> FastDict.insert recordVariable
                    (allFsharpRecords
                        |> FastSet.foldl
                            (\fsharpRecord fsharpRecordsThatContainAllSyntaxFieldsSoFar ->
                                if
                                    fields
                                        |> List.all
                                            (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ syntaxFieldName, _ )) ->
                                                fsharpRecord
                                                    |> List.member
                                                        (syntaxFieldName |> stringFirstCharToUpper)
                                            )
                                then
                                    FsharpTypeVariableSpecializationToRecord
                                        fsharpRecord
                                        :: fsharpRecordsThatContainAllSyntaxFieldsSoFar

                                else
                                    fsharpRecordsThatContainAllSyntaxFieldsSoFar
                            )
                            []
                    )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            FastDict.union
                (inType |> syntaxTypeSplitIntoSpecializedFsharpTypes allFsharpRecords)
                (outType |> syntaxTypeSplitIntoSpecializedFsharpTypes allFsharpRecords)


syntaxTypeNodeApplySpecialization :
    FastDict.Dict String FsharpTypeVariableSpecialization
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeNodeApplySpecialization specialization syntaxTypeNode =
    syntaxTypeNode
        |> Elm.Syntax.Node.map
            (\syntaxType ->
                syntaxType
                    |> syntaxTypeApplySpecialization
                        specialization
            )


syntaxTypeApplySpecialization :
    FastDict.Dict String FsharpTypeVariableSpecialization
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeApplySpecialization specialization syntaxType =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType variable ->
            case specialization |> FastDict.get variable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericType variable

                Just specificSpecialization ->
                    case specificSpecialization of
                        FsharpTypeVariableSpecializationToInt ->
                            Elm.Syntax.TypeAnnotation.Typed
                                (Elm.Syntax.Node.empty ( [ "Basics" ], "Int" ))
                                []

                        FsharpTypeVariableSpecializationToFloat ->
                            Elm.Syntax.TypeAnnotation.Typed
                                (Elm.Syntax.Node.empty ( [ "Basics" ], "Float" ))
                                []

                        FsharpTypeVariableSpecializationToRecord fields ->
                            Elm.Syntax.TypeAnnotation.Record
                                (fields
                                    |> List.map
                                        (\fieldName ->
                                            Elm.Syntax.Node.empty
                                                ( Elm.Syntax.Node.empty fieldName
                                                , Elm.Syntax.Node.empty
                                                    (Elm.Syntax.TypeAnnotation.GenericType
                                                        (variable ++ "_" ++ fieldName)
                                                    )
                                                )
                                        )
                                )

        Elm.Syntax.TypeAnnotation.Typed reference arguments ->
            Elm.Syntax.TypeAnnotation.Typed reference
                (arguments
                    |> List.map
                        (\argument ->
                            argument |> syntaxTypeNodeApplySpecialization specialization
                        )
                )

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                (parts
                    |> List.map
                        (\part ->
                            part |> syntaxTypeNodeApplySpecialization specialization
                        )
                )

        Elm.Syntax.TypeAnnotation.Record fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> List.map
                        (\fieldNode ->
                            fieldNode
                                |> Elm.Syntax.Node.map
                                    (\( nameNode, valueNode ) ->
                                        ( nameNode
                                        , valueNode
                                            |> syntaxTypeNodeApplySpecialization specialization
                                        )
                                    )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node recordVariableRange recordVariableName) (Elm.Syntax.Node.Node fieldsRange fields) ->
            let
                fieldsSpecialized : List (Elm.Syntax.Node.Node ( Elm.Syntax.Node.Node String, Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation ))
                fieldsSpecialized =
                    fields
                        |> List.map
                            (\fieldNode ->
                                fieldNode
                                    |> Elm.Syntax.Node.map
                                        (\( nameNode, valueNode ) ->
                                            ( nameNode
                                            , valueNode
                                                |> syntaxTypeNodeApplySpecialization specialization
                                            )
                                        )
                            )
            in
            case specialization |> FastDict.get recordVariableName of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericRecord
                        (Elm.Syntax.Node.Node recordVariableRange recordVariableName)
                        (Elm.Syntax.Node.Node fieldsRange fieldsSpecialized)

                Just specificSpecialization ->
                    case specificSpecialization of
                        FsharpTypeVariableSpecializationToInt ->
                            Elm.Syntax.TypeAnnotation.Typed
                                (Elm.Syntax.Node.empty ( [ "Basics" ], "Int" ))
                                []

                        FsharpTypeVariableSpecializationToFloat ->
                            Elm.Syntax.TypeAnnotation.Typed
                                (Elm.Syntax.Node.empty ( [ "Basics" ], "Float" ))
                                []

                        FsharpTypeVariableSpecializationToRecord allFields ->
                            let
                                additionalFields :
                                    List
                                        (Elm.Syntax.Node.Node
                                            ( Elm.Syntax.Node.Node String
                                            , Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
                                            )
                                        )
                                additionalFields =
                                    allFields
                                        |> List.filterMap
                                            (\specializationFieldName ->
                                                if
                                                    fields
                                                        |> List.any
                                                            (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, _ )) ->
                                                                fieldName == specializationFieldName
                                                            )
                                                then
                                                    Nothing

                                                else
                                                    Just
                                                        (Elm.Syntax.Node.empty
                                                            ( Elm.Syntax.Node.empty specializationFieldName
                                                            , Elm.Syntax.Node.empty
                                                                (Elm.Syntax.TypeAnnotation.GenericType
                                                                    (recordVariableName ++ "_" ++ specializationFieldName)
                                                                )
                                                            )
                                                        )
                                            )
                            in
                            Elm.Syntax.TypeAnnotation.Record
                                (fieldsSpecialized
                                    ++ additionalFields
                                )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (inType |> syntaxTypeNodeApplySpecialization specialization)
                (outType |> syntaxTypeNodeApplySpecialization specialization)


{-| F# does not have a concept of the following elm types:

  - `number` type variable
  - `{ extendedRecord | some : field }' extended record

to accommodate, we split elm values/functions that use these in their annotation
into specialized F# functions. For example

    Array.Extra.sum : Array number -> number

will be split into and used as

    let ArrayExtra_sum__number_Int : array<int64> -> int64
    let ArrayExtra_sum__number_Float : array<float> -> float

and similarly

    Fields.setX : x -> { p | x : x } -> { p | x : x }
    --
    type alias Point = { x : Int, y : Int }
    someOtherUsage = Fields.setX 3.0 { x = 0, y = 0, z = 0 }

will be split into and used as

    let Fields_setX__p_X_Y : 'x -> Generated_X_Y<'x, 'p_Y> -> Generated_X_Y<'x, 'p_Y>
    let Fields_setX__p_X_Y_Z : x -> Generated_X_Y_Z<'x, 'p_Y, 'p_Z> -> Generated_X_Y_Z<'x, 'p_Y, 'p_Z>

for all elm records in types and expressions that contain the field `x`

These specializations can also stack.

-}
fsharpNameWithSpecializedTypes :
    FastDict.Dict String FsharpTypeVariableSpecialization
    -> String
    -> String
fsharpNameWithSpecializedTypes specializedTypes name =
    specializedTypes
        |> FastDict.foldl
            (\variable specializedType nameSoFar ->
                nameSoFar
                    ++ "__"
                    ++ variable
                    ++ "_"
                    ++ (case specializedType of
                            FsharpTypeVariableSpecializationToRecord specializedTypeRecordFields ->
                                specializedTypeRecordFields
                                    |> List.map stringFirstCharToUpper
                                    |> String.join "_"

                            FsharpTypeVariableSpecializationToInt ->
                                "Int"

                            FsharpTypeVariableSpecializationToFloat ->
                                "Float"
                       )
            )
            name


{-| Which variables of a type are more concrete in the inferred type
-}
inferredTypeSpecializedVariablesFromNode :
    Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String FsharpTypeVariableSpecialization
inferredTypeSpecializedVariablesFromNode (Elm.Syntax.Node.Node _ syntaxType) inferredType =
    inferredTypeSpecializedVariablesFrom syntaxType inferredType


inferredTypeSpecializedVariablesFrom :
    Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String FsharpTypeVariableSpecialization
inferredTypeSpecializedVariablesFrom syntaxType inferredType =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            FastDict.empty

        Elm.Syntax.TypeAnnotation.GenericType syntaxVariable ->
            case inferredType of
                ElmSyntaxTypeInfer.TypeVariable _ ->
                    FastDict.empty

                ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                    case inferredTypeNotVariable_ of
                        ElmSyntaxTypeInfer.TypeConstruct specializedTypeConstruct ->
                            if syntaxVariable |> String.startsWith "number" then
                                case specializedTypeConstruct.moduleOrigin of
                                    "Basics" ->
                                        case specializedTypeConstruct.name of
                                            "Int" ->
                                                FastDict.singleton syntaxVariable
                                                    FsharpTypeVariableSpecializationToInt

                                            "Float" ->
                                                FastDict.singleton syntaxVariable
                                                    FsharpTypeVariableSpecializationToFloat

                                            _ ->
                                                FastDict.empty

                                    _ ->
                                        FastDict.empty

                            else
                                FastDict.empty

                        _ ->
                            FastDict.empty

        Elm.Syntax.TypeAnnotation.Typed _ syntaxArguments ->
            case inferredType of
                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- incorrectly inferred
                    FastDict.empty

                ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                    case inferredTypeNotVariable_ of
                        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
                            List.map2 inferredTypeSpecializedVariablesFromNode
                                syntaxArguments
                                inferredTypeConstruct.arguments
                                |> listOfFastDictsUnify

                        ElmSyntaxTypeInfer.TypeUnit ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTuple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTriple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecord _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeFunction _ ->
                            FastDict.empty

        Elm.Syntax.TypeAnnotation.Tupled syntaxParts ->
            case syntaxParts of
                [] ->
                    FastDict.empty

                [ inParens ] ->
                    inferredTypeSpecializedVariablesFromNode inParens inferredType

                [ syntaxPart0, syntaxPart1 ] ->
                    case inferredType of
                        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeTuple inferredTuple) ->
                            inferredTypeSpecializedVariablesFromNode syntaxPart0 inferredTuple.part0
                                |> FastDict.union
                                    (inferredTypeSpecializedVariablesFromNode syntaxPart1 inferredTuple.part1)

                        _ ->
                            -- incorrectly inferred
                            FastDict.empty

                [ syntaxPart0, syntaxPart1, syntaxPart2 ] ->
                    case inferredType of
                        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeTriple inferredTriple) ->
                            inferredTypeSpecializedVariablesFromNode syntaxPart0 inferredTriple.part0
                                |> FastDict.union
                                    (inferredTypeSpecializedVariablesFromNode syntaxPart1 inferredTriple.part1)
                                |> FastDict.union
                                    (inferredTypeSpecializedVariablesFromNode syntaxPart2 inferredTriple.part2)

                        _ ->
                            -- incorrectly inferred
                            FastDict.empty

                _ :: _ :: _ :: _ :: _ ->
                    FastDict.empty

        Elm.Syntax.TypeAnnotation.Record syntaxFields ->
            case inferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord inferredRecord) ->
                    List.map2 inferredTypeSpecializedVariablesFromNode
                        (syntaxFields
                            |> List.map (\(Elm.Syntax.Node.Node _ ( _, value )) -> value)
                        )
                        (inferredRecord |> FastDict.values)
                        |> listOfFastDictsUnify

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ syntaxRecordVariable) (Elm.Syntax.Node.Node _ syntaxFields) ->
            case inferredType of
                ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                    case inferredTypeNotVariable_ of
                        ElmSyntaxTypeInfer.TypeRecordExtension inferredRecordExtension ->
                            List.map2 inferredTypeSpecializedVariablesFromNode
                                (syntaxFields
                                    |> List.sortBy
                                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                                            name
                                        )
                                    |> List.map (\(Elm.Syntax.Node.Node _ ( _, value )) -> value)
                                )
                                (inferredRecordExtension.fields |> FastDict.values)
                                |> listOfFastDictsUnify

                        ElmSyntaxTypeInfer.TypeRecord inferredRecord ->
                            syntaxFields
                                |> listMapToFastDictsAndUnify
                                    (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ syntaxFieldName, syntaxFieldValue )) ->
                                        case inferredRecord |> FastDict.get syntaxFieldName of
                                            Nothing ->
                                                FastDict.empty

                                            Just inferredFieldValue ->
                                                inferredTypeSpecializedVariablesFromNode syntaxFieldValue inferredFieldValue
                                    )
                                |> FastDict.insert syntaxRecordVariable
                                    (FsharpTypeVariableSpecializationToRecord
                                        (inferredRecord |> FastDict.keys)
                                    )

                        ElmSyntaxTypeInfer.TypeUnit ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeConstruct _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTuple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTriple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeFunction _ ->
                            FastDict.empty

                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- incorrectly inferred
                    FastDict.empty

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation syntaxIn syntaxOut ->
            case inferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction inferredFunction) ->
                    inferredTypeSpecializedVariablesFromNode syntaxIn inferredFunction.input
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFromNode syntaxOut inferredFunction.output)

                _ ->
                    -- incorrectly inferred
                    FastDict.empty


qualifiedReferenceToFsharpName :
    { moduleOrigin : Maybe String
    , name : String
    }
    -> String
qualifiedReferenceToFsharpName reference =
    case reference.moduleOrigin of
        Nothing ->
            reference.name

        Just moduleOrigin ->
            moduleOrigin
                ++ "."
                ++ reference.name


printFsharpExpressionParenthesizedIfSpaceSeparated : FsharpExpression -> Print
printFsharpExpressionParenthesizedIfSpaceSeparated fsharpExpression =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            printFsharpExpressionNotParenthesized fsharpExpression
    in
    if fsharpExpression |> fsharpExpressionIsSpaceSeparated then
        printParenthesized notParenthesizedPrint

    else
        notParenthesizedPrint


printFsharpExpressionParenthesizedIfWithLetDeclarations : FsharpExpression -> Print
printFsharpExpressionParenthesizedIfWithLetDeclarations fsharpExpression =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            printFsharpExpressionNotParenthesized fsharpExpression
    in
    case fsharpExpression of
        FsharpExpressionWithLetDeclarations _ ->
            printParenthesized notParenthesizedPrint

        FsharpExpressionUnit ->
            notParenthesizedPrint

        FsharpExpressionFloat _ ->
            notParenthesizedPrint

        FsharpExpressionInt64 _ ->
            notParenthesizedPrint

        FsharpExpressionChar _ ->
            notParenthesizedPrint

        FsharpExpressionStringLiteral _ ->
            notParenthesizedPrint

        FsharpExpressionReference _ ->
            notParenthesizedPrint

        FsharpExpressionRecordAccess _ ->
            notParenthesizedPrint

        FsharpExpressionTuple _ ->
            notParenthesizedPrint

        FsharpExpressionIfElse _ ->
            notParenthesizedPrint

        FsharpExpressionListLiteral _ ->
            notParenthesizedPrint

        FsharpExpressionArrayLiteral _ ->
            notParenthesizedPrint

        FsharpExpressionRecord _ ->
            notParenthesizedPrint

        FsharpExpressionRecordUpdate _ ->
            notParenthesizedPrint

        FsharpExpressionCall _ ->
            notParenthesizedPrint

        FsharpExpressionLambda _ ->
            notParenthesizedPrint

        FsharpExpressionMatchWith _ ->
            notParenthesizedPrint


fsharpExpressionIsSpaceSeparated : FsharpExpression -> Bool
fsharpExpressionIsSpaceSeparated fsharpExpression =
    case fsharpExpression of
        FsharpExpressionUnit ->
            False

        FsharpExpressionChar _ ->
            False

        FsharpExpressionInt64 _ ->
            False

        FsharpExpressionFloat _ ->
            False

        FsharpExpressionStringLiteral _ ->
            False

        FsharpExpressionReference _ ->
            False

        FsharpExpressionRecordAccess _ ->
            False

        FsharpExpressionTuple _ ->
            False

        FsharpExpressionIfElse _ ->
            True

        FsharpExpressionListLiteral _ ->
            False

        FsharpExpressionArrayLiteral _ ->
            False

        FsharpExpressionRecord _ ->
            False

        FsharpExpressionRecordUpdate _ ->
            False

        FsharpExpressionCall _ ->
            True

        FsharpExpressionLambda _ ->
            True

        FsharpExpressionMatchWith _ ->
            True

        FsharpExpressionWithLetDeclarations _ ->
            True


{-| Print a [`FsharpExpression`](#FsharpExpression)
-}
printFsharpExpressionNotParenthesized : FsharpExpression -> Print
printFsharpExpressionNotParenthesized fsharpExpression =
    -- IGNORE TCO
    case fsharpExpression of
        FsharpExpressionUnit ->
            printFsharpExpressionUnit

        FsharpExpressionCall call ->
            printFsharpExpressionCall call

        FsharpExpressionReference reference ->
            Print.exactly
                (reference |> qualifiedReferenceToFsharpName)

        FsharpExpressionIfElse ifElse ->
            printFsharpExpressionIfElse ifElse

        FsharpExpressionChar charValue ->
            Print.exactly (charLiteral charValue)

        FsharpExpressionInt64 int ->
            Print.exactly (int |> intLiteral)

        FsharpExpressionFloat float ->
            Print.exactly (float |> floatLiteral)

        FsharpExpressionStringLiteral string ->
            printFsharpStringLiteral string

        FsharpExpressionTuple parts ->
            printFsharpExpressionTuple parts

        FsharpExpressionWithLetDeclarations expressionWithLetDeclarations ->
            printFsharpExpressionWithLetDeclarations expressionWithLetDeclarations

        FsharpExpressionMatchWith syntaxMatch ->
            printFsharpExpressionMatchWith syntaxMatch

        FsharpExpressionLambda syntaxLambda ->
            printFsharpExpressionLambda syntaxLambda

        FsharpExpressionRecord fields ->
            printFsharpExpressionRecord fields

        FsharpExpressionListLiteral elements ->
            printFsharpExpressionListLiteral elements

        FsharpExpressionArrayLiteral elements ->
            printFsharpExpressionArrayLiteral elements

        FsharpExpressionRecordAccess syntaxRecordAccess ->
            printFsharpExpressionParenthesizedIfSpaceSeparated
                syntaxRecordAccess.record
                |> Print.followedBy
                    (Print.exactly
                        ("." ++ syntaxRecordAccess.field)
                    )

        FsharpExpressionRecordUpdate syntaxRecordUpdate ->
            printFsharpExpressionRecordUpdate syntaxRecordUpdate


printFsharpExpressionUnit : Print
printFsharpExpressionUnit =
    Print.exactly "()"


printFsharpExpressionTuple :
    { part0 : FsharpExpression
    , part1 : FsharpExpression
    , part2Up : List FsharpExpression
    }
    -> Print
printFsharpExpressionTuple parts =
    let
        part0Print : Print
        part0Print =
            printFsharpExpressionNotParenthesized
                parts.part0

        part1Print : Print
        part1Print =
            printFsharpExpressionNotParenthesized
                parts.part1

        part2UpPrints : List Print
        part2UpPrints =
            parts.part2Up
                |> List.map printFsharpExpressionNotParenthesized

        lineSpread : Print.LineSpread
        lineSpread =
            part0Print
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> part1Print |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part2UpPrints
                            |> Print.lineSpreadListMapAndCombine
                                Print.lineSpread
                    )
    in
    printExactlyParenOpeningStructParenOpening
        |> Print.followedBy
            (Print.withIndentIncreasedBy 2
                (Print.spaceOrLinebreakIndented lineSpread)
            )
        |> Print.followedBy
            ((part0Print :: part1Print :: part2UpPrints)
                |> Print.listMapAndIntersperseAndFlatten
                    (\partPrint ->
                        Print.withIndentIncreasedBy 2 partPrint
                    )
                    (Print.emptyOrLinebreakIndented lineSpread
                        |> Print.followedBy
                            printExactlyCommaSpace
                    )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented lineSpread)
        |> Print.followedBy
            printExactlyParenClosingParenClosing


printExactlyParenOpeningStructParenOpening : Print
printExactlyParenOpeningStructParenOpening =
    Print.exactly "(struct("


printExactlyCommaSpace : Print
printExactlyCommaSpace =
    Print.exactly ", "


printExactlyParenClosingParenClosing : Print
printExactlyParenClosingParenClosing =
    Print.exactly "))"


printFsharpExpressionCall :
    { called : FsharpExpression
    , arguments : List FsharpExpression
    }
    -> Print
printFsharpExpressionCall call =
    let
        calledPrint : Print
        calledPrint =
            printFsharpExpressionParenthesizedIfSpaceSeparated
                call.called

        argumentPrints : List Print
        argumentPrints =
            call.arguments
                |> List.map
                    printFsharpExpressionParenthesizedIfSpaceSeparated

        fullLineSpread : Print.LineSpread
        fullLineSpread =
            argumentPrints
                |> Print.lineSpreadListMapAndCombine Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> calledPrint |> Print.lineSpread)
    in
    calledPrint
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented fullLineSpread
                    |> Print.followedBy
                        (argumentPrints
                            |> Print.listIntersperseAndFlatten
                                (Print.spaceOrLinebreakIndented fullLineSpread)
                        )
                )
            )


printFsharpExpressionListLiteral : List FsharpExpression -> Print
printFsharpExpressionListLiteral listElements =
    case listElements of
        [] ->
            printFsharpExpressionListLiteralEmpty

        element0 :: element1Up ->
            let
                elementsPrint : Print
                elementsPrint =
                    (element0 :: element1Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printFsharpExpressionNotParenthesized
                            printExactlySemicolonLinebreakIndented
            in
            printExactlyAngledOpeningSpace
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 2
                        elementsPrint
                    )
                |> Print.followedBy
                    (Print.spaceOrLinebreakIndented
                        (elementsPrint |> Print.lineSpread)
                    )
                |> Print.followedBy printExactlyAngledClosing


printExactlySemicolonLinebreakIndented : Print
printExactlySemicolonLinebreakIndented =
    Print.exactly ";"
        |> Print.followedBy Print.linebreakIndented


printFsharpExpressionListLiteralEmpty : Print
printFsharpExpressionListLiteralEmpty =
    Print.exactly "[]"


printExactlyAngledOpeningSpace : Print
printExactlyAngledOpeningSpace =
    Print.exactly "[ "


printExactlyAngledClosing : Print
printExactlyAngledClosing =
    Print.exactly "]"


printFsharpExpressionArrayLiteral : List FsharpExpression -> Print
printFsharpExpressionArrayLiteral elements =
    case elements of
        [] ->
            printFsharpExpressionArrayLiteralEmpty

        element0 :: element1Up ->
            let
                elementsPrint : Print
                elementsPrint =
                    (element0 :: element1Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printFsharpExpressionNotParenthesized
                            printExactlySemicolonLinebreakIndented
            in
            printExactlyAngledOpeningVerticalBarSpace
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 2
                        elementsPrint
                    )
                |> Print.followedBy
                    (Print.spaceOrLinebreakIndented
                        (elementsPrint |> Print.lineSpread)
                    )
                |> Print.followedBy
                    printExactlyVerticalBarAngledClosing


printFsharpExpressionArrayLiteralEmpty : Print
printFsharpExpressionArrayLiteralEmpty =
    Print.exactly "[||]"


printExactlyAngledOpeningVerticalBarSpace : Print
printExactlyAngledOpeningVerticalBarSpace =
    Print.exactly "[| "


printExactlyVerticalBarAngledClosing : Print
printExactlyVerticalBarAngledClosing =
    Print.exactly "|]"


printFsharpExpressionRecordUpdate :
    { originalRecordVariable : String
    , fields : FastDict.Dict String FsharpExpression
    }
    -> Print
printFsharpExpressionRecordUpdate syntaxRecordUpdate =
    printExactlyCurlyOpeningSpace
        |> Print.followedBy
            (Print.withIndentIncreasedBy 2
                (Print.exactly syntaxRecordUpdate.originalRecordVariable)
            )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (printLinebreakIndentedSpaceWith
                    |> Print.followedBy
                        (Print.withIndentAtNextMultipleOf4
                            (Print.linebreakIndented
                                |> Print.followedBy
                                    (syntaxRecordUpdate.fields
                                        |> FastDict.toList
                                        |> Print.listMapAndIntersperseAndFlatten
                                            (\( fieldName, fieldValue ) ->
                                                Print.exactly (fieldName ++ " =")
                                                    |> Print.followedBy
                                                        (Print.withIndentAtNextMultipleOf4
                                                            (Print.linebreakIndented
                                                                |> Print.followedBy
                                                                    (printFsharpExpressionNotParenthesized fieldValue)
                                                            )
                                                        )
                                            )
                                            printLinebreakIndentedSemicolonSpace
                                    )
                            )
                        )
                )
            )
        |> Print.followedBy printLinebreakIndentedCurlyClosing


printExactlyCurlyOpeningSpace : Print
printExactlyCurlyOpeningSpace =
    Print.exactly "{ "


printLinebreakIndentedSpaceWith : Print
printLinebreakIndentedSpaceWith =
    Print.linebreakIndented
        |> Print.followedBy
            (Print.exactly " with")


printLinebreakIndentedSemicolonSpace : Print
printLinebreakIndentedSemicolonSpace =
    Print.linebreakIndented
        |> Print.followedBy
            (Print.exactly "; ")


printLinebreakIndentedCurlyClosing : Print
printLinebreakIndentedCurlyClosing =
    Print.linebreakIndented
        |> Print.followedBy
            (Print.exactly "}")


patternIsSpaceSeparated : FsharpPattern -> Bool
patternIsSpaceSeparated fsharpPattern =
    case fsharpPattern of
        FsharpPatternIgnore ->
            False

        FsharpPatternInt _ ->
            False

        FsharpPatternChar _ ->
            False

        FsharpPatternStringLiteral _ ->
            False

        FsharpPatternVariable _ ->
            False

        FsharpPatternAs _ ->
            True

        FsharpPatternListCons _ ->
            True

        FsharpPatternListExact _ ->
            False

        FsharpPatternRecordInexhaustive _ ->
            False

        FsharpPatternVariant _ ->
            False

        FsharpPatternTuple _ ->
            False


printFsharpPatternParenthesizedIfSpaceSeparated : FsharpPattern -> Print
printFsharpPatternParenthesizedIfSpaceSeparated fsharpPattern =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            fsharpPattern |> printFsharpPatternNotParenthesized
    in
    if fsharpPattern |> patternIsSpaceSeparated then
        printParenthesized notParenthesizedPrint

    else
        notParenthesizedPrint


printFsharpExpressionLambda :
    { parameters : List { pattern : FsharpPattern, type_ : FsharpType }
    , result : FsharpExpression
    }
    -> Print
printFsharpExpressionLambda syntaxLambda =
    let
        parameterPrints : List Print
        parameterPrints =
            syntaxLambda.parameters
                |> List.map
                    (\parameter ->
                        let
                            parameterTypePrint : Print
                            parameterTypePrint =
                                printFsharpTypeNotParenthesized
                                    parameter.type_
                        in
                        printParenthesized
                            ((parameter.pattern
                                |> printFsharpPatternParenthesizedIfSpaceSeparated
                             )
                                |> Print.followedBy printExactlyColon
                                |> Print.followedBy
                                    (Print.withIndentIncreasedBy 1
                                        (Print.withIndentAtNextMultipleOf4
                                            (Print.spaceOrLinebreakIndented
                                                (parameterTypePrint |> Print.lineSpread)
                                                |> Print.followedBy
                                                    parameterTypePrint
                                            )
                                        )
                                    )
                            )
                    )

        parametersLineSpread : Print.LineSpread
        parametersLineSpread =
            parameterPrints
                |> Print.lineSpreadListMapAndCombine
                    Print.lineSpread
    in
    printExactlyFunSpace
        |> Print.followedBy
            (Print.withIndentIncreasedBy 4
                (parameterPrints
                    |> Print.listIntersperseAndFlatten
                        (Print.spaceOrLinebreakIndented parametersLineSpread)
                )
            )
        |> Print.followedBy printExactlySpaceMinusGreaterThan
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printFsharpExpressionNotParenthesized
                            syntaxLambda.result
                        )
                )
            )


printExactlySpaceMinusGreaterThan : Print
printExactlySpaceMinusGreaterThan =
    Print.exactly " ->"


printExactlyFunSpace : Print
printExactlyFunSpace =
    Print.exactly "fun "


printFsharpExpressionIfElse :
    { condition : FsharpExpression
    , onTrue : FsharpExpression
    , onFalse : FsharpExpression
    }
    -> Print
printFsharpExpressionIfElse syntaxIfElse =
    let
        conditionPrint : Print
        conditionPrint =
            printFsharpExpressionNotParenthesized syntaxIfElse.condition

        conditionLineSpread : Print.LineSpread
        conditionLineSpread =
            conditionPrint |> Print.lineSpread
    in
    printExactlyIf
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented conditionLineSpread
                    |> Print.followedBy conditionPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented conditionLineSpread)
        |> Print.followedBy printExactlyThen
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printFsharpExpressionNotParenthesized syntaxIfElse.onTrue)
                    |> Print.followedBy Print.linebreak
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyElse
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printFsharpExpressionNotParenthesized syntaxIfElse.onFalse)
                )
            )


printExactlyIf : Print
printExactlyIf =
    Print.exactly "if"


printExactlyThen : Print
printExactlyThen =
    Print.exactly "then"


printExactlyElse : Print
printExactlyElse =
    Print.exactly "else"


printFsharpExpressionMatchWith :
    { matched : FsharpExpression
    , case0 :
        { pattern : FsharpPattern
        , patternType : FsharpType
        , result : FsharpExpression
        }
    , case1Up :
        List
            { pattern : FsharpPattern
            , patternType : FsharpType
            , result : FsharpExpression
            }
    }
    -> Print
printFsharpExpressionMatchWith matchWith =
    let
        matchedPrint : Print
        matchedPrint =
            printFsharpExpressionNotParenthesized matchWith.matched

        matchedPrintLineSpread : Print.LineSpread
        matchedPrintLineSpread =
            matchedPrint |> Print.lineSpread
    in
    printExactlyMatch
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented matchedPrintLineSpread
                    |> Print.followedBy matchedPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented matchedPrintLineSpread)
        |> Print.followedBy printExactlyWith
        |> Print.followedBy
            (Print.linebreakIndented
                |> Print.followedBy
                    ((matchWith.case0 :: matchWith.case1Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printFsharpExpressionMatchWithCase
                            printLinebreakLinebreakIndented
                    )
            )


printExactlyMatch : Print
printExactlyMatch =
    Print.exactly "match"


printExactlyWith : Print
printExactlyWith =
    Print.exactly "with"


printFsharpExpressionMatchWithCase :
    { pattern : FsharpPattern
    , patternType : FsharpType
    , result : FsharpExpression
    }
    -> Print
printFsharpExpressionMatchWithCase branch =
    let
        patternPrint : Print
        patternPrint =
            printFsharpPatternNotParenthesized branch.pattern
    in
    printExactlyVerticalBarSpace
        |> Print.followedBy
            (Print.withIndentIncreasedBy 2
                patternPrint
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented
                (patternPrint |> Print.lineSpread)
            )
        |> Print.followedBy printExactlyMinusGreaterThan
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printFsharpExpressionNotParenthesized branch.result)
                )
            )


printExactlyVerticalBarSpace : Print
printExactlyVerticalBarSpace =
    Print.exactly "| "


printExactlyMinusGreaterThan : Print
printExactlyMinusGreaterThan =
    Print.exactly "->"


printFsharpExpressionWithLetDeclarations :
    { declaration0 : FsharpLetDeclaration
    , declaration1Up : List FsharpLetDeclaration
    , result : FsharpExpression
    }
    -> Print
printFsharpExpressionWithLetDeclarations syntaxLetIn =
    let
        letDestructurings :
            List
                { pattern : FsharpPattern
                , patternType : FsharpType
                , expression : FsharpExpression
                }
        letDestructurings =
            (syntaxLetIn.declaration0 :: syntaxLetIn.declaration1Up)
                |> List.filterMap
                    (\declaration ->
                        case declaration of
                            FsharpLetDestructuring letDestructuring ->
                                Just letDestructuring

                            FsharpLetDeclarationValueOrFunction _ ->
                                Nothing
                    )

        letValueOrFunctions :
            List
                { name : String
                , parameters : List { pattern : FsharpPattern, type_ : FsharpType }
                , result : FsharpExpression
                , resultType : FsharpType
                }
        letValueOrFunctions =
            (syntaxLetIn.declaration0 :: syntaxLetIn.declaration1Up)
                |> List.filterMap
                    (\declaration ->
                        case declaration of
                            FsharpLetDeclarationValueOrFunction letValueOrFunction ->
                                Just letValueOrFunction

                            FsharpLetDestructuring _ ->
                                Nothing
                    )

        ordered :
            { mostToLeastDependedOn :
                List (FsharpValueOrFunctionDependencyBucket FsharpLetDeclaration)
            }
        ordered =
            { mostToLeastDependedOn =
                letValueOrFunctions
                    |> fsharpValueOrFunctionDeclarationsGroupByDependencies
                    |> .mostToLeastDependedOn
                    |> List.map
                        (\fsharpValueOrFunctionDependencyBucket ->
                            case fsharpValueOrFunctionDependencyBucket of
                                FsharpValueOrFunctionDependencySingle fsharpValueOrFunction ->
                                    FsharpValueOrFunctionDependencySingle
                                        (FsharpLetDeclarationValueOrFunction fsharpValueOrFunction)

                                FsharpValueOrFunctionDependencyRecursiveBucket recursiveBucket ->
                                    FsharpValueOrFunctionDependencyRecursiveBucket
                                        (recursiveBucket
                                            |> List.map FsharpLetDeclarationValueOrFunction
                                        )
                        )
            }
                |> fsharpLetDeclarationsInsertFsharpLetDestructurings
                    letDestructurings
    in
    (ordered.mostToLeastDependedOn
        |> Print.listMapAndIntersperseAndFlatten
            (\dependencyGroup ->
                case dependencyGroup of
                    FsharpValueOrFunctionDependencySingle fsharpLetDeclaration ->
                        printExactlyLetSpace
                            |> Print.followedBy
                                (case fsharpLetDeclaration of
                                    FsharpLetDestructuring letDestructuring ->
                                        letDestructuring |> printFsharpLetDestructuring

                                    FsharpLetDeclarationValueOrFunction letValueOrFunction ->
                                        letValueOrFunction |> printFsharpLocalLetValueOrFunctionDeclaration
                                )
                            |> Print.followedBy printLinebreakIndentedLinebreakIndented

                    FsharpValueOrFunctionDependencyRecursiveBucket recursiveGroup ->
                        printExactlyLetSpaceRecSpace
                            |> Print.followedBy
                                (recursiveGroup
                                    |> Print.listMapAndIntersperseAndFlatten
                                        (\fsharpLetDeclaration ->
                                            (case fsharpLetDeclaration of
                                                FsharpLetDestructuring letDestructuring ->
                                                    letDestructuring |> printFsharpLetDestructuring

                                                FsharpLetDeclarationValueOrFunction letValueOrFunction ->
                                                    letValueOrFunction |> printFsharpLocalLetValueOrFunctionDeclaration
                                            )
                                                |> Print.followedBy Print.linebreakIndented
                                        )
                                        printExactlyAndSpace
                                )
            )
            Print.empty
    )
        |> Print.followedBy
            (printFsharpExpressionNotParenthesized syntaxLetIn.result)


printLinebreakIndentedLinebreakIndented : Print
printLinebreakIndentedLinebreakIndented =
    Print.linebreakIndented
        |> Print.followedBy Print.linebreakIndented


fsharpLetDeclarationsInsertFsharpLetDestructurings :
    List
        { pattern : FsharpPattern
        , patternType : FsharpType
        , expression : FsharpExpression
        }
    ->
        { mostToLeastDependedOn :
            List (FsharpValueOrFunctionDependencyBucket FsharpLetDeclaration)
        }
    ->
        { mostToLeastDependedOn :
            List (FsharpValueOrFunctionDependencyBucket FsharpLetDeclaration)
        }
fsharpLetDeclarationsInsertFsharpLetDestructurings fsharpLetDestructuringsToInsert existingLetDeclarations =
    fsharpLetDestructuringsToInsert
        |> List.foldl
            (\fsharpLetDestructuringToInsert soFar ->
                soFar
                    |> fsharpLetDeclarationsInsertFsharpLetDestructuring
                        fsharpLetDestructuringToInsert
            )
            existingLetDeclarations


fsharpLetDeclarationsInsertFsharpLetDestructuring :
    { pattern : FsharpPattern
    , patternType : FsharpType
    , expression : FsharpExpression
    }
    ->
        { mostToLeastDependedOn :
            List (FsharpValueOrFunctionDependencyBucket FsharpLetDeclaration)
        }
    ->
        { mostToLeastDependedOn :
            List (FsharpValueOrFunctionDependencyBucket FsharpLetDeclaration)
        }
fsharpLetDeclarationsInsertFsharpLetDestructuring fsharpLetDestructuringToInsert existingLetDeclarations =
    let
        variablesIntroducedInDestructuringPattern : FastSet.Set String
        variablesIntroducedInDestructuringPattern =
            fsharpLetDestructuringToInsert.pattern
                |> fsharpPatternContainedVariables

        withLetDestructuring :
            { destructuringHasBeenInserted : Bool
            , leastToMostDependedOn :
                List (FsharpValueOrFunctionDependencyBucket FsharpLetDeclaration)
            }
        withLetDestructuring =
            existingLetDeclarations.mostToLeastDependedOn
                |> List.foldl
                    (\existingLetDeclarationDependencyBucket soFar ->
                        if soFar.destructuringHasBeenInserted then
                            { destructuringHasBeenInserted = True
                            , leastToMostDependedOn =
                                existingLetDeclarationDependencyBucket
                                    :: soFar.leastToMostDependedOn
                            }

                        else
                            let
                                existingLetDeclarationUsedLocalReferences : FastSet.Set String
                                existingLetDeclarationUsedLocalReferences =
                                    case existingLetDeclarationDependencyBucket of
                                        FsharpValueOrFunctionDependencySingle existingLetDeclaration ->
                                            existingLetDeclaration
                                                |> fsharpLetDeclarationUsedLocalReferences

                                        FsharpValueOrFunctionDependencyRecursiveBucket recursiveBucketMembers ->
                                            recursiveBucketMembers
                                                |> listMapToFastSetsAndUnify
                                                    fsharpLetDeclarationUsedLocalReferences
                            in
                            if fastSetsIntersect variablesIntroducedInDestructuringPattern existingLetDeclarationUsedLocalReferences then
                                { destructuringHasBeenInserted = True
                                , leastToMostDependedOn =
                                    existingLetDeclarationDependencyBucket
                                        :: FsharpValueOrFunctionDependencySingle
                                            (FsharpLetDestructuring fsharpLetDestructuringToInsert)
                                        :: soFar.leastToMostDependedOn
                                }

                            else
                                { destructuringHasBeenInserted = False
                                , leastToMostDependedOn =
                                    existingLetDeclarationDependencyBucket
                                        :: soFar.leastToMostDependedOn
                                }
                    )
                    destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty
    in
    { mostToLeastDependedOn =
        if withLetDestructuring.destructuringHasBeenInserted then
            withLetDestructuring.leastToMostDependedOn |> List.reverse

        else
            FsharpValueOrFunctionDependencySingle
                (FsharpLetDestructuring fsharpLetDestructuringToInsert)
                :: withLetDestructuring.leastToMostDependedOn
                |> List.reverse
    }


destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty :
    { destructuringHasBeenInserted : Bool
    , leastToMostDependedOn : List a_
    }
destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty =
    { destructuringHasBeenInserted = False
    , leastToMostDependedOn = []
    }


fastSetsIntersect : FastSet.Set comparable -> FastSet.Set comparable -> Bool
fastSetsIntersect aSet bSet =
    aSet
        |> fastSetAny
            (\aElement ->
                bSet |> FastSet.member aElement
            )


fastSetAny : (a -> Bool) -> FastSet.Set a -> Bool
fastSetAny isFound fastSet =
    fastSet
        |> FastSet.foldl
            (\element soFar ->
                soFar || (element |> isFound)
            )
            False


fsharpLetDeclarationUsedLocalReferences : FsharpLetDeclaration -> FastSet.Set String
fsharpLetDeclarationUsedLocalReferences fsharpLetDeclaration =
    case fsharpLetDeclaration of
        FsharpLetDestructuring fsharpLetDestructuring ->
            fsharpLetDestructuring.expression
                |> fsharpExpressionUsedLocalReferences

        FsharpLetDeclarationValueOrFunction fsharpLetValueOrFunction ->
            fsharpLetValueOrFunction.result
                |> fsharpExpressionUsedLocalReferences


fsharpPatternContainedVariables : FsharpPattern -> FastSet.Set String
fsharpPatternContainedVariables fsharpPattern =
    -- IGNORE TCO
    case fsharpPattern of
        FsharpPatternIgnore ->
            FastSet.empty

        FsharpPatternInt _ ->
            FastSet.empty

        FsharpPatternChar _ ->
            FastSet.empty

        FsharpPatternStringLiteral _ ->
            FastSet.empty

        FsharpPatternVariable variable ->
            FastSet.singleton variable

        FsharpPatternAs fsharpPatternAs ->
            FastSet.insert fsharpPatternAs.variable
                (fsharpPatternAs.pattern |> fsharpPatternContainedVariables)

        FsharpPatternListExact elementPatterns ->
            elementPatterns
                |> listMapToFastSetsAndUnify fsharpPatternContainedVariables

        FsharpPatternTuple partPatterns ->
            FastSet.union
                (partPatterns.part0 |> fsharpPatternContainedVariables)
                (FastSet.union
                    (partPatterns.part1 |> fsharpPatternContainedVariables)
                    (partPatterns.part2Up
                        |> listMapToFastSetsAndUnify fsharpPatternContainedVariables
                    )
                )

        FsharpPatternListCons patternListCons ->
            FastSet.union
                (patternListCons.head |> fsharpPatternContainedVariables)
                (patternListCons.tail |> fsharpPatternContainedVariables)

        FsharpPatternVariant patternVariant ->
            patternVariant.values
                |> listMapToFastSetsAndUnify fsharpPatternContainedVariables

        FsharpPatternRecordInexhaustive recordPatternInexhaustiveFieldNames ->
            recordPatternInexhaustiveFieldNames
                |> FastDict.values
                |> listMapToFastSetsAndUnify fsharpPatternContainedVariables


printFsharpLetDestructuring :
    { pattern : FsharpPattern
    , patternType : FsharpType
    , expression : FsharpExpression
    }
    -> Print
printFsharpLetDestructuring letDestructuring =
    let
        patternTypePrint : Print
        patternTypePrint =
            letDestructuring.patternType
                |> printFsharpTypeParenthesizedIfSpaceSeparated
    in
    Print.withIndentAtNextMultipleOf4
        (printParenthesized
            (letDestructuring.pattern
                |> printFsharpPatternNotParenthesized
                |> Print.followedBy
                    printExactlyColon
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented
                            (patternTypePrint |> Print.lineSpread)
                            |> Print.followedBy patternTypePrint
                        )
                    )
            )
            |> Print.followedBy printExactlySpaceEquals
            |> Print.followedBy
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printFsharpExpressionNotParenthesized letDestructuring.expression)
                )
        )


printExactlyColon : Print
printExactlyColon =
    Print.exactly ":"


printExactlySpaceEquals : Print
printExactlySpaceEquals =
    Print.exactly " ="


fsharpTypeUnit : FsharpType
fsharpTypeUnit =
    FsharpTypeConstruct
        { moduleOrigin = Nothing
        , name = "unit"
        , arguments = []
        }


{-| Print value/function declarations into
an fsharp module called `Elm` in the global namespace that exposes all members.
Will also add some internal wrapper declarations.
-}
fsharpDeclarationsToModuleString :
    { valuesAndFunctions :
        FastDict.Dict
            String
            { parameters : List { pattern : FsharpPattern, type_ : FsharpType }
            , result : FsharpExpression
            , resultType : FsharpType
            }
    , typeAliases :
        FastDict.Dict
            String
            { parameters : List String
            , type_ : FsharpType
            }
    , recordTypes : FastSet.Set (List String)
    , choiceTypes :
        FastDict.Dict
            String
            { parameters : List String
            , variants : FastDict.Dict String (Maybe FsharpType)
            }
    }
    -> String
fsharpDeclarationsToModuleString fsharpDeclarations =
    let
        valueAndFunctionDeclarationsOrdered :
            { mostToLeastDependedOn :
                List
                    (FsharpValueOrFunctionDependencyBucket
                        { name : String
                        , parameters : List { pattern : FsharpPattern, type_ : FsharpType }
                        , result : FsharpExpression
                        , resultType : FsharpType
                        }
                    )
            }
        valueAndFunctionDeclarationsOrdered =
            fsharpDeclarations.valuesAndFunctions
                |> fastDictMapAndToList
                    (\name valueOrFunctionInfo ->
                        { name = name
                        , parameters = valueOrFunctionInfo.parameters
                        , result = valueOrFunctionInfo.result
                        , resultType = valueOrFunctionInfo.resultType
                        }
                    )
                |> fsharpValueOrFunctionDeclarationsGroupByDependencies

        typeDeclarationsOrdered :
            { mostToLeastDependedOn :
                List
                    (FsharpValueOrFunctionDependencyBucket
                        FsharpChoiceTypeOrTypeAliasDeclaration
                    )
            }
        typeDeclarationsOrdered =
            fsharpTypeDeclarationsGroupByDependencies
                { typeAliases =
                    fsharpDeclarations.typeAliases
                        |> fastDictMapAndToList
                            (\name info ->
                                { name = name
                                , parameters = info.parameters
                                , type_ = info.type_
                                }
                            )
                , enums =
                    fsharpDeclarations.choiceTypes
                        |> fastDictMapAndToList
                            (\name info ->
                                { name = name
                                , parameters = info.parameters
                                , variants = info.variants
                                }
                            )
                }
    in
    """namespace global

module Elm =
"""
        ++ defaultDeclarations
        ++ """

    """
        ++ (Print.withIndentAtNextMultipleOf4
                (fsharpDeclarations.recordTypes
                    |> FastSet.foldr
                        (\recordTypeFields soFar ->
                            printFsharpRecordTypeDeclaration recordTypeFields
                                :: soFar
                        )
                        []
                    |> Print.listIntersperseAndFlatten
                        printLinebreakLinebreakIndented
                )
                |> Print.toString
           )
        ++ """

    """
        ++ (Print.withIndentAtNextMultipleOf4
                (typeDeclarationsOrdered.mostToLeastDependedOn
                    |> Print.listMapAndIntersperseAndFlatten
                        (\typeAliasDeclarationGroup ->
                            case typeAliasDeclarationGroup of
                                FsharpValueOrFunctionDependencySingle single ->
                                    case single of
                                        FsharpChoiceTypeDeclaration fsharpChoiceTypeDeclaration ->
                                            structLinebreakIndentedTypeSpace
                                                |> Print.followedBy
                                                    (printFsharpChoiceTypeDeclaration
                                                        fsharpChoiceTypeDeclaration
                                                    )

                                        FsharpTypeAliasDeclaration aliasDeclaration ->
                                            printExactlyTypeSpace
                                                |> Print.followedBy
                                                    (printFsharpTypeAliasDeclaration aliasDeclaration)

                                FsharpValueOrFunctionDependencyRecursiveBucket recursiveBucket ->
                                    case recursiveBucket of
                                        [] ->
                                            Print.empty

                                        recursiveBucketMember0 :: recursiveBucketMember1Up ->
                                            printExactlyTypeSpace
                                                |> Print.followedBy
                                                    (case recursiveBucketMember0 of
                                                        FsharpChoiceTypeDeclaration fsharpChoiceTypeDeclaration ->
                                                            printFsharpChoiceTypeDeclaration
                                                                fsharpChoiceTypeDeclaration

                                                        FsharpTypeAliasDeclaration aliasDeclaration ->
                                                            printFsharpTypeAliasDeclaration aliasDeclaration
                                                    )
                                                |> Print.followedBy
                                                    (recursiveBucketMember1Up
                                                        |> Print.listMapAndIntersperseAndFlatten
                                                            (\typeDeclaration ->
                                                                printLinebreakLinebreakIndentedAndSpace
                                                                    |> Print.followedBy
                                                                        (case typeDeclaration of
                                                                            FsharpChoiceTypeDeclaration enumDeclaration ->
                                                                                printFsharpChoiceTypeDeclaration enumDeclaration

                                                                            FsharpTypeAliasDeclaration aliasDeclaration ->
                                                                                printFsharpTypeAliasDeclaration aliasDeclaration
                                                                        )
                                                            )
                                                            Print.empty
                                                    )
                        )
                        printLinebreakLinebreakIndented
                )
                |> Print.toString
           )
        ++ """


    """
        ++ (Print.withIndentAtNextMultipleOf4
                (valueAndFunctionDeclarationsOrdered.mostToLeastDependedOn
                    |> Print.listMapAndIntersperseAndFlatten
                        (\dependencyGroup ->
                            case dependencyGroup of
                                FsharpValueOrFunctionDependencySingle fsharpValueOrFunction ->
                                    printExactlyLetSpace
                                        |> Print.followedBy
                                            (fsharpValueOrFunction |> printFsharpValueOrFunctionDeclaration)
                                        |> Print.followedBy printLinebreakLinebreakIndented

                                FsharpValueOrFunctionDependencyRecursiveBucket recursiveGroup ->
                                    case recursiveGroup of
                                        [] ->
                                            Print.empty

                                        fsharpValueOrFunctionDeclaration0 :: fsharpValueOrFunctionDeclaration1Up ->
                                            printExactlyLetSpaceRecSpace
                                                |> Print.followedBy
                                                    ((fsharpValueOrFunctionDeclaration0 |> printFsharpValueOrFunctionDeclaration)
                                                        |> Print.followedBy printLinebreakLinebreakIndented
                                                    )
                                                |> Print.followedBy
                                                    (fsharpValueOrFunctionDeclaration1Up
                                                        |> Print.listMapAndIntersperseAndFlatten
                                                            (\letValueOrFunction ->
                                                                printExactlyAndSpace
                                                                    |> Print.followedBy
                                                                        (letValueOrFunction |> printFsharpValueOrFunctionDeclaration)
                                                                    |> Print.followedBy printLinebreakLinebreakIndented
                                                            )
                                                            Print.empty
                                                    )
                        )
                        Print.empty
                )
                |> Print.toString
           )
        ++ """
"""


printLinebreakLinebreakIndentedAndSpace : Print
printLinebreakLinebreakIndentedAndSpace =
    printLinebreakLinebreakIndented
        |> Print.followedBy printExactlyAndSpace


structLinebreakIndentedTypeSpace : Print
structLinebreakIndentedTypeSpace =
    Print.exactly "[<Struct>]"
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyTypeSpace


printExactlyTypeSpace : Print
printExactlyTypeSpace =
    Print.exactly "type "


printExactlyLetSpace : Print
printExactlyLetSpace =
    Print.exactly "let "


printExactlyLetSpaceRecSpace : Print
printExactlyLetSpaceRecSpace =
    Print.exactly "let rec "


printExactlyAndSpace : Print
printExactlyAndSpace =
    Print.exactly "and "


defaultDeclarations : String
defaultDeclarations =
    """
    let inline Basics_always (result: 'result) (_: '_ignored) : 'result = result

    let inline Basics_eq (a: 'a) (b: 'a) : bool = a = b
    let inline Basics_neq (a: 'a) (b: 'a) : bool = a <> b
    let inline Basics_flt (a: float) (b: float) : bool = a < b
    let inline Basics_ilt (a: int64) (b: int64) : bool = a < b
    let inline Basics_fle (a: float) (b: float) : bool = a <= b
    let inline Basics_ile (a: int64) (b: int64) : bool = a <= b
    let inline Basics_fgt (a: float) (b: float) : bool = a > b
    let inline Basics_igt (a: int64) (b: int64) : bool = a > b
    let inline Basics_fge (a: float) (b: float) : bool = a >= b
    let inline Basics_ige (a: int64) (b: int64) : bool = a >= b

    [<Struct>]
    type Basics_Order =
        | LT = -1
        | EQ = 0
        | GT = 1

    let inline Basics_compare (a: 'a) (b: 'a) : Basics_Order =
        let comparisonMagnitude = compare a b

        if comparisonMagnitude = 0 then Basics_Order.EQ
        else if comparisonMagnitude < 0 then Basics_Order.LT
        else Basics_Order.GT

    let inline Basics_ceiling (n: float) : int64 = int64 (System.Math.Ceiling(n))
    let inline Basics_floor (n: float) : int64 = int64 (System.Math.Floor(n))
    let inline Basics_round (n: float) : int64 = int64 (System.Math.Round(n))
    let inline Basics_fabs (n: float) : float = System.Double.Abs(n)
    let inline Basics_iabs (n: int64) : int64 = System.Int64.Abs(n)
    let inline Basics_fnegate (n: float) : float = -n
    let inline Basics_inegate (n: int64) : int64 = -n
    let inline Basics_fadd (a: float) (b: float) : float = a + b
    let inline Basics_iadd (a: int64) (b: int64) : int64 = a + b
    let inline Basics_fsub (a: float) (b: float) : float = a - b
    let inline Basics_isub (a: int64) (b: int64) : int64 = a - b
    let inline Basics_fmul (a: float) (b: float) : float = a * b
    let inline Basics_imul (a: int64) (b: int64) : int64 = a * b
    let inline Basics_fdiv (a: float) (b: float) : float = a / b
    let inline Basics_idiv (a: int64) (b: int64) : int64 = a / b

    let inline Basics_remainderBy (divisor: int64) (toDivide: int64) : int64 =
        toDivide % divisor

    let Basics_modBy (divisor: int64) (toDivide: int64) : int64 =
        let remainder = toDivide % divisor

        if (remainder > 0 && divisor < 0) || (remainder < 0 && divisor > 0) then
            remainder + toDivide

        else
            remainder

    let inline Basics_fpow (a: float) (b: float) : float = a ** b

    let inline Basics_ipow (a: int64) (b: int64) : int64 =
        int64 (float a ** float b)

    let inline Basics_iclamp (minimum: int64) (maximum: int64) (n: int64) : int64 =
        System.Math.Clamp(value = n, min = minimum, max = maximum)

    let inline Basics_fclamp (minimum: float) (maximum: float) (n: float) : float =
        System.Math.Clamp(value = n, min = minimum, max = maximum)

    let inline Basics_logBase (newBase: float) (n: float) : float =
        System.Math.Log(n, newBase = newBase)

    let inline Basics_atan2 (y: float) (x: float) : float =
        System.Double.Atan2(y, x)

    let inline Basics_radians (radians: float) : float = radians

    let inline Basics_degrees (angleInDegrees: float) : float =
        (angleInDegrees * System.Math.PI) / 180.0

    let inline Basics_turns (angleInTurns: float) : float =
        (System.Math.PI * 2.0) * angleInTurns

    let Basics_fromPolar
        (struct (radius: float, theta: float))
        : struct (float * float) =
        struct (radius * (System.Double.Cos(theta)),
                radius * (System.Double.Sin(theta)))

    let Basics_toPolar (struct (x: float, y: float)) : struct (float * float) =
        struct (System.Double.Sqrt((x * x) + (y * y)), System.Double.Atan2(y, x))

    let inline Bitwise_shiftLeftBy
        (bitPositionsToShiftBy: int64)
        (n: int64)
        : int64 =
        n <<< int32 bitPositionsToShiftBy

    let inline Bitwise_shiftRightBy
        (bitPositionsToShiftBy: int64)
        (n: int64)
        : int64 =
        n >>> int32 bitPositionsToShiftBy

    let inline Bitwise_shiftRightZfBy
        (bitPositionsToShiftBy: int64)
        (n: int64)
        : int64 =
        int64 (int64 n >>> int32 bitPositionsToShiftBy)

    let inline Basics_and (a: bool) (b: bool) : bool = a && b
    let inline Basics_or (a: bool) (b: bool) : bool = a || b

    type Result_Result<'error, 'value> = Result<'value, 'error>

    type Basics_Never = JustOneMore of Basics_Never
    let rec Basics_never (JustOneMore ever: Basics_Never) = Basics_never ever

    let inline Char_isOctDigit (ch: char) : bool =
        let code = int ch

        code <= 0x37 && 0x30 <= code

    [<CustomEquality; CustomComparison>]
    type StringRope =
        | StringRopeOne of string
        | StringRopeAppend of struct (StringRope * StringRope)

        static member toString(this: StringRope) : string =
            match this with
            | StringRopeOne content -> content
            | StringRopeAppend(fullLeftRope, fullRightRope) ->
                let mutableBuilder = System.Text.StringBuilder()
                let mutable stringRopeToMatchNext = fullLeftRope
                let mutable shouldKeepGoing = true

                let mutableRemainingRightStringRopes
                    : System.Collections.Generic.Stack<StringRope> =
                    System.Collections.Generic.Stack()

                mutableRemainingRightStringRopes.Push(fullRightRope)

                while (shouldKeepGoing) do
                    match stringRopeToMatchNext with
                    | StringRopeOne segment ->
                        let _ = mutableBuilder.Append(segment)

                        if mutableRemainingRightStringRopes.Count = 0 then
                            shouldKeepGoing <- false
                        else
                            stringRopeToMatchNext <-
                                mutableRemainingRightStringRopes.Pop()
                    | StringRopeAppend(left, right) ->
                        stringRopeToMatchNext <- left
                        mutableRemainingRightStringRopes.Push(right)

                mutableBuilder.ToString()

        override x.GetHashCode() = hash (StringRope.toString x)

        override x.Equals(other) =
            match other with
            | :? StringRope as otherStringRope ->
                StringRope.toString x = StringRope.toString otherStringRope
            | _ -> false

        interface System.IComparable with
            member x.CompareTo(other) =
                match other with
                | :? StringRope as otherStringRope ->
                    (StringRope.toString x)
                        .CompareTo(StringRope.toString otherStringRope)
                | _ -> -1

    let stringRopeEmpty: StringRope = StringRopeOne ""

    let rec String_isEmpty (stringToCheck: StringRope) : bool =
        match stringToCheck with
        | StringRopeOne string -> System.String.IsNullOrEmpty(string)
        | StringRopeAppend(left, right) ->
            String_isEmpty left && String_isEmpty right

    let inline String_length (str: StringRope) : int64 =
        String.length (StringRope.toString str)

    let inline String_repeat
        (repetitions: int64)
        (segment: StringRope)
        : StringRope =
        StringRopeOne(
            String.replicate (int repetitions) (StringRope.toString segment)
        )

    let String_toList (string: StringRope) : List<char> =
        List.ofArray ((StringRope.toString string).ToCharArray())

    let inline String_fromList (chars: List<char>) : StringRope =
        StringRopeOne(new string (List.toArray chars))

    let inline String_contains
        (substringRope: StringRope)
        (string: StringRope)
        : bool =
        (StringRope.toString string).Contains(StringRope.toString substringRope)

    let inline String_startsWith (start: StringRope) (string: StringRope) : bool =
        (StringRope.toString string).StartsWith(StringRope.toString start)

    let inline String_endsWith (ending: StringRope) (string: StringRope) : bool =
        (StringRope.toString string).EndsWith(StringRope.toString ending)

    let inline String_any
        ([<InlineIfLambda>] charIsNeedle: char -> bool)
        (string: StringRope)
        : bool =
        // can be optimized
        String.exists charIsNeedle (StringRope.toString string)

    let inline String_all
        ([<InlineIfLambda>] charIsExpected: char -> bool)
        (string: StringRope)
        : bool =
        // can be optimized
        String.forall charIsExpected (StringRope.toString string)

    let inline String_map
        ([<InlineIfLambda>] charChange: char -> char)
        (string: StringRope)
        : StringRope =
        StringRopeOne(String.map charChange (StringRope.toString string))

    let inline String_filter
        ([<InlineIfLambda>] charShouldBeKept: char -> bool)
        (string: StringRope)
        : StringRope =
        StringRopeOne(String.filter charShouldBeKept (StringRope.toString string))

    let inline String_foldl
        ([<InlineIfLambda>] reduce: char -> 'folded -> 'folded)
        (initialFolded: 'folded)
        (string: StringRope)
        : 'folded =
        Seq.fold
            (fun soFar char -> reduce char soFar)
            initialFolded
            (StringRope.toString string)

    let inline String_foldr
        ([<InlineIfLambda>] reduce: char -> 'folded -> 'folded)
        (initialFolded: 'folded)
        (string: StringRope)
        : 'folded =
        Seq.foldBack reduce (StringRope.toString string) initialFolded

    let inline String_trim (string: StringRope) : StringRope =
        StringRopeOne((StringRope.toString string).Trim())

    let inline String_trimLeft (string: StringRope) : StringRope =
        StringRopeOne((StringRope.toString string).TrimStart())

    let inline String_trimRight (string: StringRope) : StringRope =
        StringRopeOne((StringRope.toString string).TrimEnd())

    let String_right
        (takenElementCount: int64)
        (stringRope: StringRope)
        : StringRope =
        let string: string = StringRope.toString stringRope

        StringRopeOne(
            string.Substring(
                String.length string - int takenElementCount,
                int takenElementCount
            )
        )

    let inline String_left
        (skippedElementCount: int64)
        (string: StringRope)
        : StringRope =
        StringRopeOne(
            (StringRope.toString string).Substring(0, int skippedElementCount)
        )

    let String_dropRight
        (skippedElementCount: int64)
        (stringRope: StringRope)
        : StringRope =
        let string: string = StringRope.toString stringRope

        StringRopeOne(
            string.Substring(0, String.length string - int skippedElementCount)
        )

    let String_dropLeft
        (skippedElementCount: int64)
        (stringRope: StringRope)
        : StringRope =
        let string: string = StringRope.toString stringRope

        StringRopeOne(
            string.Substring(
                int skippedElementCount,
                String.length string - int skippedElementCount
            )
        )

    let inline String_append (early: StringRope) (late: StringRope) : StringRope =
        StringRopeAppend(early, late)

    let inline String_fromChar (char: char) : StringRope =
        StringRopeOne(string char)

    let inline String_cons (newHeadChar: char) (late: StringRope) : StringRope =
        StringRopeAppend(StringRopeOne(string newHeadChar), late)

    let String_uncons
        (stringRope: StringRope)
        : ValueOption<struct (char * StringRope)> =
        let string: string = StringRope.toString stringRope

        if System.String.IsNullOrEmpty(string) then
            ValueNone
        else
            ValueSome(struct (string[0], StringRopeOne(string[1..])))

    let String_split
        (separator: StringRope)
        (string: StringRope)
        : List<StringRope> =
        // can be optimized
        List.ofArray (
            Array.map
                (fun segment -> StringRopeOne segment)
                ((StringRope.toString string).Split(StringRope.toString separator))
        )

    let newLineOptions: array<string> = [| "\\r\\n"; "\\n" |]

    let String_lines (string: StringRope) : List<StringRope> =
        // can be optimized
        List.ofArray (
            (Array.map
                (fun line -> StringRopeOne line)
                ((StringRope.toString string)
                    .Split(newLineOptions, System.StringSplitOptions.None)))
        )

    let String_reverse (string: StringRope) : StringRope =
        StringRopeOne(
            new string (Array.rev ((StringRope.toString string).ToCharArray()))
        )

    let inline String_replace
        (toReplace: StringRope)
        (replacement: StringRope)
        (string: StringRope)
        : StringRope =
        StringRopeOne(
            (StringRope.toString string)
                .Replace(
                    StringRope.toString toReplace,
                    StringRope.toString replacement
                )
        )

    let inline String_toUpper (string: StringRope) : StringRope =
        StringRopeOne((StringRope.toString string).ToUpperInvariant())

    let inline String_toLower (string: StringRope) : StringRope =
        StringRopeOne((StringRope.toString string).ToLowerInvariant())

    let String_join
        (separator: StringRope)
        (strings: List<StringRope>)
        : StringRope =
        // can be optimized
        StringRopeOne(
            String.concat
                (StringRope.toString separator)
                (List.map StringRope.toString strings)
        )

    let String_concat (strings: List<StringRope>) : StringRope =
        // can be optimized
        StringRopeOne(System.String.Concat(List.map StringRope.toString strings))

    let inline String_padLeft
        (newMinimumLength: int64)
        (padding: char)
        (string: StringRope)
        : StringRope =
        StringRopeOne(
            (StringRope.toString string).PadLeft(int newMinimumLength, padding)
        )

    let inline String_padRight
        (newMinimumLength: int64)
        (padding: char)
        (string: StringRope)
        : StringRope =
        StringRopeOne(
            (StringRope.toString string).PadRight(int newMinimumLength, padding)
        )

    let inline String_fromFloat (n: float) : StringRope = StringRopeOne(string n)
    let inline String_fromInt (n: int64) : StringRope = StringRopeOne(string n)

    let String_toInt (string: StringRope) : ValueOption<int64> =
        let (success, num) = System.Int64.TryParse(StringRope.toString string)

        if success then ValueSome num else ValueNone

    let String_toFloat (string: StringRope) : ValueOption<float> =
        let (success, num) = System.Double.TryParse(StringRope.toString string)

        if success then ValueSome num else ValueNone

    let String_slice
        (startInclusivePossiblyNegative: int64)
        (endExclusivePossiblyNegative: int64)
        (stringRope: StringRope)
        : StringRope =
        let string = StringRope.toString stringRope

        let realStartIndex: int =
            if (startInclusivePossiblyNegative < 0L) then
                max 0 (int startInclusivePossiblyNegative + String.length string)
            else
                int startInclusivePossiblyNegative

        let realEndIndexExclusive: int =
            if (endExclusivePossiblyNegative < 0L) then
                max 0 (int endExclusivePossiblyNegative + String.length string)
            else
                min (int endExclusivePossiblyNegative) (String.length string)

        if (realStartIndex >= realEndIndexExclusive) then
            stringRopeEmpty
        else
            StringRopeOne(
                string.Substring(
                    realStartIndex,
                    realEndIndexExclusive - realStartIndex
                )
            )

    let inline List_length (list: List<'a>) : int64 = List.length list

    let inline List_head (list: List<'a>) : ValueOption<'a> =
        match list with
        | [] -> ValueNone
        | head :: _ -> ValueSome head

    let inline List_tail (list: List<'a>) : ValueOption<List<'a>> =
        match list with
        | [] -> ValueNone
        | head :: tail -> ValueSome tail

    let inline List_filterMap
        ([<InlineIfLambda>] elementToMaybe: 'a -> ValueOption<'b>)
        (list: List<'a>)
        : List<'b> =
        List.choose
            (fun element -> ValueOption.toOption (elementToMaybe element))
            list

    let inline List_member (needle: 'a) (list: List<'a>) : bool =
        List.contains needle list

    let List_minimum (list: List<'a>) : ValueOption<'a> =
        match list with
        | [] -> ValueNone
        | _ :: _ -> ValueSome(List.min list)

    let List_maximum (list: List<'a>) : ValueOption<'a> =
        match list with
        | [] -> ValueNone
        | _ :: _ -> ValueSome(List.max list)

    let List_fproduct (list: List<float>) : float = List.fold (*) 1.0 list
    let List_iproduct (list: List<int64>) : int64 = List.fold (*) 1L list

    let inline List_cons (newHead: 'a) (tail: List<'a>) : List<'a> = newHead :: tail

    let inline List_repeat (repetitions: int64) (element: 'a) : List<'a> =
        List.replicate (int repetitions) element

    let inline List_take
        (elementCountFromStart: int64)
        (list: List<'a>)
        : List<'a> =
        List.truncate (int elementCountFromStart) list

    let inline List_drop
        (skippedElementCountFromStart: int64)
        (list: List<'a>)
        : List<'a> =
        try
            List.skip (int skippedElementCountFromStart) list
        with _ ->
            []

    let inline List_sortWith
        ([<InlineIfLambda>] elementCompare: 'a -> 'a -> Basics_Order)
        (list: List<'a>)
        : List<'a> =
        List.sortWith (fun a b -> int (elementCompare a b)) list

    let List_intersperse (sep: 'a) (list: List<'a>) =
        match list with
        | [] -> []
        | listHead :: listTail ->
            List.foldBack (fun x soFar -> x :: sep :: soFar) listTail [ listHead ]

    let inline List_foldl
        ([<InlineIfLambda>] reduce: 'a -> 'state -> 'state)
        (initialState: 'state)
        (list: List<'a>)
        : 'state =
        List.fold (fun soFar element -> reduce element soFar) initialState list

    let inline List_foldr
        ([<InlineIfLambda>] reduce: 'a -> 'state -> 'state)
        (initialState: 'state)
        (list: List<'a>)
        : 'state =
        List.foldBack reduce list initialState

    let inline List_range (startFloat: int64) (endFloat: int64) : List<int64> =
        [ startFloat..endFloat ]

    let rec List_map4_into_reverse
        (combinedSoFarReverse: List<'combined>)
        (combine: 'a -> 'b -> 'c -> 'd -> 'combined)
        (aList: List<'a>)
        (bList: List<'b>)
        (cList: List<'c>)
        (dList: List<'d>)
        : List<'combined> =
        // optimization possibility: construct into an array first
        match aList with
        | [] -> List.rev combinedSoFarReverse
        | aHead :: aTail ->
            match bList with
            | [] -> List.rev combinedSoFarReverse
            | bHead :: bTail ->
                match cList with
                | [] -> List.rev combinedSoFarReverse
                | cHead :: cTail ->
                    match dList with
                    | [] -> List.rev combinedSoFarReverse
                    | dHead :: dTail ->
                        List_map4_into_reverse
                            (combine aHead bHead cHead dHead :: combinedSoFarReverse)
                            combine
                            aTail
                            bTail
                            cTail
                            dTail

    let inline List_map4
        ([<InlineIfLambda>] combine: 'a -> 'b -> 'c -> 'd -> 'combined)
        (aList: List<'a>)
        (bList: List<'b>)
        (cList: List<'c>)
        (dList: List<'d>)
        : List<'combined> =
        List_map4_into_reverse [] combine aList bList cList dList

    let rec List_map5_into_reverse
        (combinedSoFarReverse: List<'combined>)
        (combine: 'a -> 'b -> 'c -> 'd -> 'e -> 'combined)
        (aList: List<'a>)
        (bList: List<'b>)
        (cList: List<'c>)
        (dList: List<'d>)
        (eList: List<'e>)
        : List<'combined> =
        // optimization possibility: construct into an array first
        match aList with
        | [] -> List.rev combinedSoFarReverse
        | aHead :: aTail ->
            match bList with
            | [] -> List.rev combinedSoFarReverse
            | bHead :: bTail ->
                match cList with
                | [] -> List.rev combinedSoFarReverse
                | cHead :: cTail ->
                    match dList with
                    | [] -> List.rev combinedSoFarReverse
                    | dHead :: dTail ->
                        match eList with
                        | [] -> List.rev combinedSoFarReverse
                        | eHead :: eTail ->
                            List_map5_into_reverse
                                (combine aHead bHead cHead dHead eHead
                                 :: combinedSoFarReverse)
                                combine
                                aTail
                                bTail
                                cTail
                                dTail
                                eTail

    let inline List_map5
        ([<InlineIfLambda>] combine: 'a -> 'b -> 'c -> 'd -> 'e -> 'combined)
        (aList: List<'a>)
        (bList: List<'b>)
        (cList: List<'c>)
        (dList: List<'d>)
        (eList: List<'e>)
        : List<'combined> =
        List_map5_into_reverse [] combine aList bList cList dList eList


    let inline Maybe_map4
        ([<InlineIfLambda>] valuesCombine: 'a -> 'b -> 'c -> 'd -> 'combined)
        (aOption: ValueOption<'a>)
        (bOption: ValueOption<'b>)
        (cOption: ValueOption<'c>)
        (dOption: ValueOption<'d>)
        : ValueOption<'combined> =
        match aOption, bOption, cOption, dOption with
        | ValueSome(a), ValueSome(b), ValueSome(c), ValueSome(d) ->
            ValueSome(valuesCombine a b c d)
        | _ -> ValueNone

    let inline Maybe_map5
        ([<InlineIfLambda>] valuesCombine: 'a -> 'b -> 'c -> 'd -> 'e -> 'combined)
        (aOption: ValueOption<'a>)
        (bOption: ValueOption<'b>)
        (cOption: ValueOption<'c>)
        (dOption: ValueOption<'d>)
        (eOption: ValueOption<'e>)
        : ValueOption<'combined> =
        match aOption, bOption, cOption, dOption, eOption with
        | ValueSome(a), ValueSome(b), ValueSome(c), ValueSome(d), ValueSome(e) ->
            ValueSome(valuesCombine a b c d e)
        | _ -> ValueNone


    let inline Result_map2
        ([<InlineIfLambda>] valuesCombine: 'a -> 'b -> 'combined)
        (aResult: Result<'a, 'error>)
        (bResult: Result<'b, 'error>)
        : Result<'combined, 'error> =
        match aResult with
        | Error(error) -> Error(error)
        | Ok(a) ->
            match bResult with
            | Error(error) -> Error(error)
            | Ok(b) -> Ok(valuesCombine a b)

    let inline Result_map3
        ([<InlineIfLambda>] valuesCombine: 'a -> 'b -> 'c -> 'combined)
        (aResult: Result<'a, 'error>)
        (bResult: Result<'b, 'error>)
        (cResult: Result<'c, 'error>)
        : Result<'combined, 'error> =
        match aResult with
        | Error(error) -> Error(error)
        | Ok(a) ->
            match bResult with
            | Error(error) -> Error(error)
            | Ok(b) ->
                match cResult with
                | Error(error) -> Error(error)
                | Ok(c) -> Ok(valuesCombine a b c)

    let inline Result_map4
        ([<InlineIfLambda>] valuesCombine: 'a -> 'b -> 'c -> 'd -> 'combined)
        (aResult: Result<'a, 'error>)
        (bResult: Result<'b, 'error>)
        (cResult: Result<'c, 'error>)
        (dResult: Result<'d, 'error>)
        : Result<'combined, 'error> =
        match aResult with
        | Error(error) -> Error(error)
        | Ok(a) ->
            match bResult with
            | Error(error) -> Error(error)
            | Ok(b) ->
                match cResult with
                | Error(error) -> Error(error)
                | Ok(c) ->
                    match dResult with
                    | Error(error) -> Error(error)
                    | Ok(d) -> Ok(valuesCombine a b c d)

    let inline Result_map5
        ([<InlineIfLambda>] valuesCombine: 'a -> 'b -> 'c -> 'd -> 'e -> 'combined)
        (aResult: Result<'a, 'error>)
        (bResult: Result<'b, 'error>)
        (cResult: Result<'c, 'error>)
        (dResult: Result<'d, 'error>)
        (eResult: Result<'e, 'error>)
        : Result<'combined, 'error> =
        match aResult with
        | Error(error) -> Error(error)
        | Ok(a) ->
            match bResult with
            | Error(error) -> Error(error)
            | Ok(b) ->
                match cResult with
                | Error(error) -> Error(error)
                | Ok(c) ->
                    match dResult with
                    | Error(error) -> Error(error)
                    | Ok(d) ->
                        match eResult with
                        | Error(error) -> Error(error)
                        | Ok(e) -> Ok(valuesCombine a b c d e)

    let inline Result_fromMaybe
        (errorOnNothing: 'error)
        (maybe: ValueOption<'value>)
        : Result<'value, 'error> =
        match maybe with
        | ValueNone -> Error(errorOnNothing)
        | ValueSome(value) -> Ok(value)


    let inline Dict_size (dict: Map<'key, 'value>) : int64 = Map.count dict

    let inline Dict_singleton (key: 'key) (value: 'value) : Map<'key, 'value> =
        Map [ (key, value) ]

    let inline Dict_toList
        (dict: Map<'key, 'value>)
        : List<struct ('key * 'value)> =
        Map.foldBack (fun key value soFar -> (struct (key, value)) :: soFar) dict []

    let inline Dict_fromList
        (keyValuePairs: List<struct ('key * 'value)>)
        : Map<'key, 'value> =
        List.fold
            (fun soFar (struct (key, value)) -> Map.add key value soFar)
            Map.empty
            keyValuePairs

    let inline Dict_foldr
        ([<InlineIfLambda>] reduce: 'key -> 'value -> 'state -> 'state)
        (initialState: 'state)
        (dict: Map<'key, 'value>)
        : 'state =
        Map.foldBack reduce dict initialState

    let inline Dict_foldl
        ([<InlineIfLambda>] reduce: 'key -> 'value -> 'state -> 'state)
        (initialState: 'state)
        (dict: Map<'key, 'value>)
        : 'state =
        Map.fold (fun soFar k v -> reduce k v soFar) initialState dict

    let inline Dict_get
        (key: 'key)
        (dict: Map<'key, 'value>)
        : ValueOption<'value> =
        Option.toValueOption (Map.tryFind key dict)

    let inline Dict_update
        (key: 'key)
        ([<InlineIfLambda>] slotChange: ValueOption<'value> -> ValueOption<'value>)
        (dict: Map<'key, 'value>)
        : Map<'key, 'value> =
        Map.change
            key
            (fun slot ->
                ValueOption.toOption (slotChange (Option.toValueOption slot)))
            dict

    let inline Dict_keys (dict: Map<'key, 'value>) : List<'key> =
        Seq.toList (Map.keys dict)

    let inline Dict_values (dict: Map<'key, 'value>) : List<'value> =
        Seq.toList (Map.values dict)

    let Dict_diff
        (baseDict: Map<'key, 'a>)
        (dictWithKeysToRemove: Map<'key, 'b>)
        : Map<'key, 'a> =
        Map.fold (fun soFar k _ -> Map.remove k soFar) baseDict dictWithKeysToRemove

    let Dict_union (aDict: Map<'key, 'a>) (bDict: Map<'key, 'a>) : Map<'key, 'a> =
        Map.fold (fun soFar k v -> Map.add k v soFar) bDict aDict

    let Dict_intersect (aDict: Map<'comparable, 'v>) (bDict: Map<'comparable, 'v>) =
        Map.filter (fun key _ -> Map.containsKey key bDict) aDict

    let Dict_merge
        (leftStep: ('comparable -> 'aValue -> 'result -> 'result))
        (bothStep: ('comparable -> 'aValue -> 'bValue -> 'result -> 'result))
        (rightStep: ('comparable -> 'bValue -> 'result -> 'result))
        (leftDict: Map<'comparable, 'aValue>)
        (rightDict: Map<'comparable, 'bValue>)
        (initialResult: 'result)
        : 'result =
        // can be optimized using ValueTuple
        let rec stepState
            (list: List<('comparable * 'aValue)>, result: 'result)
            (rKey: 'comparable)
            (rValue: 'bValue)
            =
            match list with
            | [] -> (list, rightStep rKey rValue result)

            | (lKey, lValue) :: rest ->
                if lKey < rKey then
                    stepState (rest, leftStep lKey lValue result) rKey rValue

                else if lKey > rKey then
                    (list, rightStep rKey rValue result)

                else
                    (rest, bothStep lKey lValue rValue result)

        let (leftovers: List<('comparable * 'aValue)>, intermediateResult: 'result) =
            Map.fold stepState (Map.toList leftDict, initialResult) rightDict

        List.fold
            (fun result (k, v) -> leftStep k v result)
            intermediateResult
            leftovers

    let inline Set_size (set: Set<'element>) : int64 = Set.count set

    let inline Set_foldr
        ([<InlineIfLambda>] reduce: 'key -> 'state -> 'state)
        (initialState: 'state)
        (set: Set<'key>)
        : 'state =
        Set.foldBack reduce set initialState

    let inline Set_foldl
        ([<InlineIfLambda>] reduce: 'key -> 'state -> 'state)
        (initialState: 'state)
        (set: Set<'key>)
        : 'state =
        Set.fold (fun soFar k -> reduce k soFar) initialState set

    let inline Array_length (array: array<'a>) : int64 = Array.length array

    let Array_get (index: int64) (array: array<'element>) : ValueOption<'element> =
        Option.toValueOption (Array.tryItem (int index) array)

    let inline Array_initialize
        (count: int64)
        ([<InlineIfLambda>] indexToElement: int64 -> 'element)
        : array<'element> =
        Array.init (max 0 (int count)) (fun index -> indexToElement index)

    let inline Array_repeat (count: int64) (element: 'element) : array<'element> =
        Array.replicate (max 0 (int count)) element

    let Array_set
        (index: int64)
        (replacementElement: 'element)
        (array: array<'element>)
        : array<'element> =
        if index < 0 then array
        else if index >= Array.length array then array
        else Array.updateAt (int index) replacementElement array

    let Array_push
        (newLastElement: 'element)
        (array: array<'element>)
        : array<'element> =
        Array.append array [| newLastElement |]

    let inline Array_indexedMap
        ([<InlineIfLambda>] elementChange: int64 -> 'a -> 'b)
        (array: array<'a>)
        : array<'b> =
        Array.mapi (fun index element -> elementChange index element) array

    let Array_toIndexedList (array: array<'a>) : List<struct (int64 * 'a)> =
        (Array.foldBack
            (fun
                (element: 'a)
                (soFar:
                    {| Index: int64
                       List: List<struct (int64 * 'a)> |}) ->
                {| Index = soFar.Index - 1L
                   List = (struct (soFar.Index, element)) :: soFar.List |})
            array
            {| Index = int64 (Array.length array - 1)
               List = [] |})
            .List

    let inline Array_foldl
        ([<InlineIfLambda>] reduce: 'a -> 'state -> 'state)
        (initialState: 'state)
        (array: array<'a>)
        : 'state =
        Array.fold (fun state element -> reduce element state) initialState array

    let inline Array_foldr
        ([<InlineIfLambda>] reduce: 'a -> 'state -> 'state)
        (initialState: 'state)
        (array: array<'a>)
        : 'state =
        Array.foldBack reduce array initialState

    let Array_slice
        (startInclusivePossiblyNegative: int64)
        (endExclusivePossiblyNegative: int64)
        (array: array<'a>)
        : array<'a> =
        let realStartIndex: int =
            if (startInclusivePossiblyNegative < 0L) then
                max 0 (int startInclusivePossiblyNegative + Array.length array)
            else
                int startInclusivePossiblyNegative

        let realEndIndexExclusive: int =
            if (endExclusivePossiblyNegative < 0L) then
                max 0 (int endExclusivePossiblyNegative + Array.length array)
            else
                min (int endExclusivePossiblyNegative) (Array.length array)

        if (realStartIndex >= realEndIndexExclusive) then
            Array.empty
        else
            Array.sub array realStartIndex (realEndIndexExclusive - realStartIndex)


    let JsonEncode_null: System.Text.Json.Nodes.JsonNode =
        System.Text.Json.Nodes.JsonValue.Create(null)

    let inline JsonEncode_bool (bool: bool) : System.Text.Json.Nodes.JsonNode =
        System.Text.Json.Nodes.JsonValue.Create(bool)

    let inline JsonEncode_stringRaw
        (string: string)
        : System.Text.Json.Nodes.JsonNode =
        System.Text.Json.Nodes.JsonValue.Create(string)

    let inline JsonEncode_string
        (string: StringRope)
        : System.Text.Json.Nodes.JsonNode =
        JsonEncode_stringRaw(StringRope.toString string)

    let inline JsonEncode_int (int: int64) : System.Text.Json.Nodes.JsonNode =
        System.Text.Json.Nodes.JsonValue.Create(int)

    let inline JsonEncode_float (float: float) : System.Text.Json.Nodes.JsonNode =
        System.Text.Json.Nodes.JsonValue.Create(float)

    let inline JsonEncode_list
        ([<InlineIfLambda>] elementToValue:
            'element -> System.Text.Json.Nodes.JsonNode)
        (elements: List<'element>)
        : System.Text.Json.Nodes.JsonNode =
        // can be optimized
        System.Text.Json.Nodes.JsonArray(
            Array.ofList (List.map elementToValue elements)
        )

    let inline JsonEncode_array
        ([<InlineIfLambda>] elementToValue:
            'element -> System.Text.Json.Nodes.JsonNode)
        (elements: array<'element>)
        : System.Text.Json.Nodes.JsonNode =
        System.Text.Json.Nodes.JsonArray(Array.map elementToValue elements)

    let inline JsonEncode_set
        ([<InlineIfLambda>] elementToValue:
            'element -> System.Text.Json.Nodes.JsonNode)
        (elements: Set<'element>)
        : System.Text.Json.Nodes.JsonNode =
        // can be optimized
        System.Text.Json.Nodes.JsonArray(
            Array.map elementToValue (Set.toArray elements)
        )

    let inline JsonEncode_object
        (fields: List<struct (StringRope * System.Text.Json.Nodes.JsonNode)>)
        : System.Text.Json.Nodes.JsonNode =
        System.Text.Json.Nodes.JsonObject(
            List.fold
                (fun soFar (struct (fieldName, fieldValue)) ->
                    Map.add (StringRope.toString fieldName) fieldValue soFar)
                Map.empty
                fields
        )

    let inline JsonEncode_dict
        ([<InlineIfLambda>] keyToString: 'key -> StringRope)
        ([<InlineIfLambda>] valueToJson: 'value -> System.Text.Json.Nodes.JsonNode)
        (dict: Map<'key, 'value>)
        : System.Text.Json.Nodes.JsonNode =
        System.Text.Json.Nodes.JsonObject(
            Map.fold
                (fun soFar key value ->
                    Map.add
                        (StringRope.toString (keyToString key))
                        (valueToJson value)
                        soFar)
                Map.empty
                dict
        )
        
    let lineSetIndentSizeFrom2To (newIndentSize: int) (line: string) : string =
        let lineWithoutIndentation: string = line.TrimStart(' ')
        let lineIndentation: int = (String.length line - String.length lineWithoutIndentation) / 2

        String.replicate (int newIndentSize * lineIndentation) " "
            + lineWithoutIndentation

    let setIndentSizeFrom2To (newIndentSize: int) (printed: string) : string =
        if newIndentSize = 2 then
            printed
        else
            String.concat "\\n"
                (Array.map
                    (fun (line: string) -> lineSetIndentSizeFrom2To newIndentSize line)
                    (printed.Split('\\n'))
                )

    let JsonEncode_encode
        (indentDepth: int64)
        (json: System.Text.Json.Nodes.JsonNode)
        : StringRope =
        let printOptions = System.Text.Json.JsonSerializerOptions()

        if (indentDepth = 0) then
            StringRopeOne(json.ToJsonString(printOptions))
        else
            printOptions.WriteIndented <- true
            // JsonSerializerOptions.IndentSize is only available since .net9.0
            StringRopeOne(
                setIndentSizeFrom2To (int indentDepth)
                    (json.ToJsonString(printOptions))
            )

    type JsonDecode_Error =
        | JsonDecode_Field of (struct (StringRope * JsonDecode_Error))
        | JsonDecode_Index of (struct (int64 * JsonDecode_Error))
        | JsonDecode_OneOf of List<JsonDecode_Error>
        | JsonDecode_Failure of
            (struct (StringRope * System.Text.Json.Nodes.JsonNode))

    type JsonDecode_Decoder<'value> =
        System.Text.Json.Nodes.JsonNode -> Result<'value, JsonDecode_Error>

    let inline JsonDecode_decodeValue
        (decoder: JsonDecode_Decoder<'value>)
        (value: System.Text.Json.Nodes.JsonNode)
        : Result<'value, JsonDecode_Error> =
        decoder value

    let inline JsonDecode_decodeString
        (decoder: JsonDecode_Decoder<'value>)
        (string: StringRope)
        : Result<'value, JsonDecode_Error> =
        try
            decoder (
                System.Text.Json.Nodes.JsonNode.Parse(StringRope.toString string)
            )
        with :? System.Text.Json.JsonException ->
            Error(
                JsonDecode_Failure(
                    StringRopeOne "This is not valid JSON!",
                    System.Text.Json.Nodes.JsonValue.Create(
                        StringRope.toString string
                    )
                )
            )

    let inline JsonDecode_succeed (value: 'value) : JsonDecode_Decoder<'value> =
        fun _ -> Ok(value)

    let inline JsonDecode_fail
        (errorMessage: StringRope)
        : JsonDecode_Decoder<'value> =
        fun jsonDomNode -> Error(JsonDecode_Failure(errorMessage, jsonDomNode))

    let inline JsonDecode_map
        ([<InlineIfLambda>] valueChange: 'a -> 'b)
        (decoder: JsonDecode_Decoder<'a>)
        : JsonDecode_Decoder<'b> =
        fun jsonDomNode ->
            match decoder jsonDomNode with
            | Error(error) -> Error(error)
            | Ok(value) -> Ok(valueChange value)

    let JsonDecode_lazy
        (lazilyConstructDecoder: unit -> JsonDecode_Decoder<'value>)
        : JsonDecode_Decoder<'value> =
        fun json -> lazilyConstructDecoder () json

    let inline JsonDecode_andThen
        ([<InlineIfLambda>] decoderBasedOnValue: 'a -> JsonDecode_Decoder<'b>)
        (decoder: JsonDecode_Decoder<'a>)
        : JsonDecode_Decoder<'b> =
        fun json ->
            match decoder json with
            | Error(error) -> Error(error)
            | Ok(value) -> decoderBasedOnValue value json

    let inline JsonDecode_map2
        ([<InlineIfLambda>] combine: 'a -> 'b -> 'combined)
        (aDecoder: JsonDecode_Decoder<'a>)
        (bDecoder: JsonDecode_Decoder<'b>)
        : JsonDecode_Decoder<'combined> =
        fun json ->
            match aDecoder json with
            | Error error -> Error error
            | Ok a ->
                match bDecoder json with
                | Error error -> Error error
                | Ok b -> Ok(combine a b)

    let inline JsonDecode_map3
        ([<InlineIfLambda>] combine: 'a -> 'b -> 'c -> 'combined)
        (aDecoder: JsonDecode_Decoder<'a>)
        (bDecoder: JsonDecode_Decoder<'b>)
        (cDecoder: JsonDecode_Decoder<'c>)
        : JsonDecode_Decoder<'combined> =
        fun json ->
            match aDecoder json with
            | Error error -> Error error
            | Ok a ->
                match bDecoder json with
                | Error error -> Error error
                | Ok b ->
                    match cDecoder json with
                    | Error error -> Error error
                    | Ok c -> Ok(combine a b c)

    let inline JsonDecode_map4
        ([<InlineIfLambda>] combine: 'a -> 'b -> 'c -> 'd -> 'combined)
        (aDecoder: JsonDecode_Decoder<'a>)
        (bDecoder: JsonDecode_Decoder<'b>)
        (cDecoder: JsonDecode_Decoder<'c>)
        (dDecoder: JsonDecode_Decoder<'d>)
        : JsonDecode_Decoder<'combined> =
        fun json ->
            match aDecoder json with
            | Error error -> Error error
            | Ok a ->
                match bDecoder json with
                | Error error -> Error error
                | Ok b ->
                    match cDecoder json with
                    | Error error -> Error error
                    | Ok c ->
                        match dDecoder json with
                        | Error error -> Error error
                        | Ok d -> Ok(combine a b c d)

    let inline JsonDecode_map5
        ([<InlineIfLambda>] combine: 'a -> 'b -> 'c -> 'd -> 'e -> 'combined)
        (aDecoder: JsonDecode_Decoder<'a>)
        (bDecoder: JsonDecode_Decoder<'b>)
        (cDecoder: JsonDecode_Decoder<'c>)
        (dDecoder: JsonDecode_Decoder<'d>)
        (eDecoder: JsonDecode_Decoder<'e>)
        : JsonDecode_Decoder<'combined> =
        fun json ->
            match aDecoder json with
            | Error error -> Error error
            | Ok a ->
                match bDecoder json with
                | Error error -> Error error
                | Ok b ->
                    match cDecoder json with
                    | Error error -> Error error
                    | Ok c ->
                        match dDecoder json with
                        | Error error -> Error error
                        | Ok d ->
                            match eDecoder json with
                            | Error error -> Error error
                            | Ok e -> Ok(combine a b c d e)

    let inline JsonDecode_map6
        ([<InlineIfLambda>] combine: 'a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'combined)
        (aDecoder: JsonDecode_Decoder<'a>)
        (bDecoder: JsonDecode_Decoder<'b>)
        (cDecoder: JsonDecode_Decoder<'c>)
        (dDecoder: JsonDecode_Decoder<'d>)
        (eDecoder: JsonDecode_Decoder<'e>)
        (fDecoder: JsonDecode_Decoder<'f>)
        : JsonDecode_Decoder<'combined> =
        fun json ->
            match aDecoder json with
            | Error error -> Error error
            | Ok a ->
                match bDecoder json with
                | Error error -> Error error
                | Ok b ->
                    match cDecoder json with
                    | Error error -> Error error
                    | Ok c ->
                        match dDecoder json with
                        | Error error -> Error error
                        | Ok d ->
                            match eDecoder json with
                            | Error error -> Error error
                            | Ok e ->
                                match fDecoder json with
                                | Error error -> Error error
                                | Ok f -> Ok(combine a b c d e f)

    let inline JsonDecode_map7
        ([<InlineIfLambda>] combine:
            'a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g -> 'combined)
        (aDecoder: JsonDecode_Decoder<'a>)
        (bDecoder: JsonDecode_Decoder<'b>)
        (cDecoder: JsonDecode_Decoder<'c>)
        (dDecoder: JsonDecode_Decoder<'d>)
        (eDecoder: JsonDecode_Decoder<'e>)
        (fDecoder: JsonDecode_Decoder<'f>)
        (gDecoder: JsonDecode_Decoder<'g>)
        : JsonDecode_Decoder<'combined> =
        fun json ->
            match aDecoder json with
            | Error error -> Error error
            | Ok a ->
                match bDecoder json with
                | Error error -> Error error
                | Ok b ->
                    match cDecoder json with
                    | Error error -> Error error
                    | Ok c ->
                        match dDecoder json with
                        | Error error -> Error error
                        | Ok d ->
                            match eDecoder json with
                            | Error error -> Error error
                            | Ok e ->
                                match fDecoder json with
                                | Error error -> Error error
                                | Ok f ->
                                    match gDecoder json with
                                    | Error error -> Error error
                                    | Ok g -> Ok(combine a b c d e f g)

    let inline JsonDecode_map8
        ([<InlineIfLambda>] combine:
            'a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g -> 'h -> 'combined)
        (aDecoder: JsonDecode_Decoder<'a>)
        (bDecoder: JsonDecode_Decoder<'b>)
        (cDecoder: JsonDecode_Decoder<'c>)
        (dDecoder: JsonDecode_Decoder<'d>)
        (eDecoder: JsonDecode_Decoder<'e>)
        (fDecoder: JsonDecode_Decoder<'f>)
        (gDecoder: JsonDecode_Decoder<'g>)
        (hDecoder: JsonDecode_Decoder<'h>)
        : JsonDecode_Decoder<'combined> =
        fun json ->
            match aDecoder json with
            | Error error -> Error error
            | Ok a ->
                match bDecoder json with
                | Error error -> Error error
                | Ok b ->
                    match cDecoder json with
                    | Error error -> Error error
                    | Ok c ->
                        match dDecoder json with
                        | Error error -> Error error
                        | Ok d ->
                            match eDecoder json with
                            | Error error -> Error error
                            | Ok e ->
                                match fDecoder json with
                                | Error error -> Error error
                                | Ok f ->
                                    match gDecoder json with
                                    | Error error -> Error error
                                    | Ok g ->
                                        match hDecoder json with
                                        | Error error -> Error error
                                        | Ok h -> Ok(combine a b c d e f g h)

    let JsonDecode_maybe
        (valueDecoder: JsonDecode_Decoder<'value>)
        : JsonDecode_Decoder<ValueOption<'value>> =
        fun json ->
            Ok(
                match valueDecoder json with
                | Ok valueDecodeResult -> ValueSome valueDecodeResult
                | Error valueError -> ValueNone
            )

    let rec JsonDecode_oneOfWithErrorsReverse
        (errorsReverse: List<JsonDecode_Error>)
        (options: List<JsonDecode_Decoder<'value>>)
        : JsonDecode_Decoder<'value> =
        fun json ->
            match options with
            | [] -> Error(JsonDecode_OneOf(List.rev errorsReverse))
            | nextOptionToTry :: remainingOptions ->
                match nextOptionToTry json with
                | Ok value -> Ok value
                | Error error ->
                    JsonDecode_oneOfWithErrorsReverse
                        (error :: errorsReverse)
                        remainingOptions
                        json

    let JsonDecode_oneOf
        (options: List<JsonDecode_Decoder<'value>>)
        : JsonDecode_Decoder<'value> =
        JsonDecode_oneOfWithErrorsReverse [] options


    let JsonDecode_value: JsonDecode_Decoder<System.Text.Json.Nodes.JsonNode> =
        fun json -> Ok json

    let JsonDecode_stringRaw: JsonDecode_Decoder<string> =
        fun json ->
            try
                Ok(json.AsValue().GetValue<string>())
            with _ ->
                Error(
                    JsonDecode_Failure(
                        struct (StringRopeOne "Expecting a STRING", json)
                    )
                )

    let JsonDecode_string: JsonDecode_Decoder<StringRope> =
        fun json ->
            try
                Ok(StringRopeOne(json.AsValue().GetValue<string>()))
            with _ ->
                Error(
                    JsonDecode_Failure(
                        struct (StringRopeOne "Expecting a STRING", json)
                    )
                )

    let JsonDecode_int: JsonDecode_Decoder<int64> =
        fun json ->
            try
                Ok(json.AsValue().GetValue<int64>())
            with _ ->
                Error(
                    JsonDecode_Failure(
                        struct (StringRopeOne "Expecting an INT", json)
                    )
                )

    let JsonDecode_float: JsonDecode_Decoder<float> =
        fun json ->
            try
                Ok(json.AsValue().GetValue<float>())
            with _ ->
                Error(
                    JsonDecode_Failure(
                        struct (StringRopeOne "Expecting a FLOAT", json)
                    )
                )

    let JsonDecode_bool: JsonDecode_Decoder<bool> =
        fun json ->
            try
                Ok(json.AsValue().GetValue<bool>())
            with _ ->
                Error(
                    JsonDecode_Failure(
                        struct (StringRopeOne "Expecting a BOOL", json)
                    )
                )

    let inline JsonDecode_null (value: 'value) : JsonDecode_Decoder<'value> =
        fun json ->
            if json = JsonEncode_null then
                Ok value
            else
                match json.GetValueKind() with
                | System.Text.Json.JsonValueKind.Null -> Ok value
                | _ ->
                    Error(
                        JsonDecode_Failure(
                            struct (StringRopeOne "Expecting NULL", json)
                        )
                    )

    let JsonDecode_index
        (index: int64)
        (elementDecoder: JsonDecode_Decoder<'element>)
        : JsonDecode_Decoder<'element> =
        fun json ->
            if index < 0 then
                Error(
                    JsonDecode_Failure(
                        struct (StringRopeOne(
                                    "Expecting an element at array index "
                                    + string index
                                    + " (likely a logic error in decoder code)"
                                ),
                                json)
                    )
                )
            else
                try
                    let jsonArray: System.Text.Json.Nodes.JsonArray = json.AsArray()

                    if index >= jsonArray.Count then
                        Error(
                            JsonDecode_Failure(
                                struct (StringRopeOne(
                                            "Expecting a LONGER array. Need index "
                                            + string index
                                            + " but only see "
                                            + string jsonArray.Count
                                            + " elements"
                                        ),
                                        json)
                            )
                        )
                    else
                        match elementDecoder (jsonArray[int index]) with
                        | Ok elementDecoded -> Ok elementDecoded
                        | Error error ->
                            Error(JsonDecode_Index(struct (index, error)))
                with _ ->
                    Error(
                        JsonDecode_Failure(
                            struct (StringRopeOne "Expecting an ARRAY", json)
                        )
                    )

    let JsonDecode_list
        (elementDecoder: JsonDecode_Decoder<'element>)
        : JsonDecode_Decoder<List<'element>> =
        fun json ->
            try
                let jsonArray: System.Text.Json.Nodes.JsonArray = json.AsArray()

                let folded =
                    Seq.foldBack
                        (fun
                            element
                            (soFar:
                                {| Index: int64
                                   Result: Result<List<'element>, JsonDecode_Error> |}) ->
                            match soFar.Result with
                            | Error _ -> soFar
                            | Ok tail ->
                                {| Index = soFar.Index - 1L
                                   Result =
                                    match elementDecoder element with
                                    | Error error ->
                                        Error(
                                            JsonDecode_Index(
                                                struct (soFar.Index, error)
                                            )
                                        )
                                    | Ok head -> Ok(head :: tail) |})
                        jsonArray
                        {| Index = int64 jsonArray.Count
                           Result = Ok [] |}

                folded.Result
            with _ ->
                Error(
                    JsonDecode_Failure(
                        struct (StringRopeOne "Expecting a LIST", json)
                    )
                )

    let JsonDecode_array
        (elementDecoder: JsonDecode_Decoder<'element>)
        : JsonDecode_Decoder<array<'element>> =
        // can be optimized
        JsonDecode_map Array.ofList (JsonDecode_list elementDecoder)

    let JsonDecode_fieldRaw
        (fieldNameString: string)
        (valueDecoder: JsonDecode_Decoder<'value>)
        : JsonDecode_Decoder<'value> =
        fun json ->
            try
                let jsonObject: System.Text.Json.Nodes.JsonObject = json.AsObject()

                match jsonObject[fieldNameString] with
                | null ->
                    Error(
                        JsonDecode_Failure(
                            struct (StringRopeOne(
                                        "Expecting an OBJECT with a field named '"
                                        + fieldNameString
                                        + "'"
                                    ),
                                    json)
                        )
                    )
                | fieldValueJson ->
                    match valueDecoder fieldValueJson with
                    | Ok fieldValue -> Ok fieldValue
                    | Error error ->
                        Error(
                            JsonDecode_Field(
                                struct (StringRopeOne fieldNameString, error)
                            )
                        )
            with _ ->
                Error(
                    JsonDecode_Failure(
                        struct (StringRopeOne(
                                    "Expecting an OBJECT with a field named '"
                                    + fieldNameString
                                    + "'"
                                ),
                                json)
                    )
                )

    let inline JsonDecode_field
        (fieldNameStringRope: StringRope)
        (valueDecoder: JsonDecode_Decoder<'value>)
        : JsonDecode_Decoder<'value> =
        JsonDecode_fieldRaw (StringRope.toString fieldNameStringRope) valueDecoder

    let JsonDecode_at
        (fieldNames: List<StringRope>)
        (valueDecoder: JsonDecode_Decoder<'value>)
        : JsonDecode_Decoder<'value> =
        List.foldBack
            (fun (fieldName: StringRope) (decoderSoFar: JsonDecode_Decoder<'value>) ->
                JsonDecode_field fieldName decoderSoFar)
            fieldNames
            valueDecoder

    let JsonDecode_dict
        (valueDecoder: JsonDecode_Decoder<'value>)
        : JsonDecode_Decoder<Map<StringRope, 'value>> =
        fun json ->
            try
                let jsonObject: System.Text.Json.Nodes.JsonObject = json.AsObject()

                Seq.foldBack
                    (fun
                        (field:
                            System.Collections.Generic.KeyValuePair<
                                string,
                                System.Text.Json.Nodes.JsonNode
                             >)
                        (soFarOrError:
                            Result<Map<StringRope, 'value>, JsonDecode_Error>) ->
                        match soFarOrError with
                        | Error _ -> soFarOrError
                        | Ok soFar ->
                            match valueDecoder field.Value with
                            | Error error ->
                                Error(
                                    JsonDecode_Field(
                                        struct (StringRopeOne field.Key, error)
                                    )
                                )
                            | Ok fieldValue ->
                                Ok(
                                    Map.add
                                        (StringRopeOne field.Key)
                                        fieldValue
                                        soFar
                                ))
                    jsonObject
                    (Ok Map.empty)
            with _ ->
                Error(
                    JsonDecode_Failure(
                        struct (StringRopeOne "Expecting an OBJECT", json)
                    )
                )

    let JsonDecode_keyValuePairs
        (valueDecoder: JsonDecode_Decoder<'value>)
        : JsonDecode_Decoder<List<struct (StringRope * 'value)>> =
        // can be optimized
        JsonDecode_map Dict_toList (JsonDecode_dict valueDecoder)

    let JsonDecode_nullable
        (valueDecoder: JsonDecode_Decoder<'value>)
        : JsonDecode_Decoder<ValueOption<'value>> =
        fun json ->
            match JsonDecode_null ValueNone json with
            | Ok nullDecodeResult -> Ok nullDecodeResult
            | Error nullError ->
                match valueDecoder json with
                | Ok valueDecodeResult -> Ok(ValueSome valueDecodeResult)
                | Error valueError ->
                    Error(JsonDecode_OneOf [ nullError; valueError ])

    let inline JsonDecode_oneOrMore
        ([<InlineIfLambda>] combineHeadTail: 'element -> List<'element> -> 'combined)
        (elementDecoder: JsonDecode_Decoder<'element>)
        : JsonDecode_Decoder<'combined> =
        JsonDecode_map2
            combineHeadTail
            elementDecoder
            (JsonDecode_list elementDecoder)

    let inline indent (str: string) : string =
        String.concat "\\n    " (Array.toList (str.Split("\\n")))

    let rec JsonDecode_errorToStringHelp
        (error: JsonDecode_Error)
        (context: List<string>)
        : string =
        match error with
        | JsonDecode_Field(f, err) ->
            let isSimple =
                match String_uncons f with
                | ValueNone -> false
                | ValueSome(char, rest) ->
                    System.Char.IsLetter(char)
                    && String_all System.Char.IsLetter rest

            let fieldName =
                if isSimple then
                    "." + StringRope.toString f
                else
                    "['" + StringRope.toString f + "']"

            JsonDecode_errorToStringHelp err (fieldName :: context)

        | JsonDecode_Index(i, err) ->
            let indexName = "[" + string i + "]"

            JsonDecode_errorToStringHelp err (indexName :: context)

        | JsonDecode_OneOf(errors) ->
            match errors with
            | [] ->
                "Ran into a Json.Decode.oneOf with no possibilities"
                + (match context with
                   | [] -> "!"
                   | _ :: _ -> " at json" + String.concat "" (List.rev context))

            | [ err ] -> JsonDecode_errorToStringHelp err context

            | _ :: _ :: _ ->
                let starter =
                    match context with
                    | [] -> "Json.Decode.oneOf"
                    | _ :: _ ->
                        "The Json.Decode.oneOf at json"
                        + String.concat "" (List.rev context)

                let introduction =
                    starter
                    + " failed in the following "
                    + string (List.length errors)
                    + " ways:"

                String.concat
                    "\\n\\n"
                    (introduction
                     :: List.mapi
                         (fun (i: int32) (error: JsonDecode_Error) ->
                             "\\n\\n("
                             + string (i + 1)
                             + ") "
                             + indent (JsonDecode_errorToStringHelp error []))
                         errors)

        | JsonDecode_Failure(msg, json) ->
            let introduction =
                match context with
                | [] -> "Problem with the given value:\\n\\n"
                | _ :: _ ->
                    "Problem with the value at json"
                    + String.concat "" (List.rev context)
                    + ":\\n\\n    "

            introduction
            + indent (StringRope.toString (JsonEncode_encode 4 json))
            + "\\n\\n"
            + StringRope.toString msg

    let JsonDecode_errorToString (error: JsonDecode_Error) : StringRope =
        StringRopeOne(JsonDecode_errorToStringHelp error [])


    [<Struct>]
    type Regex_Options =
        { CaseInsensitive: bool
          Multiline: bool }

    [<Struct>]
    type Regex_Match =
        { Match: StringRope
          Index: int64
          Number: int64
          Submatches: List<ValueOption<StringRope>> }

    let Regex_fromString
        (string: StringRope)
        : ValueOption<System.Text.RegularExpressions.Regex> =
        try
            ValueSome(
                System.Text.RegularExpressions.Regex(
                    StringRope.toString string,
                    System.Text.RegularExpressions.RegexOptions.ECMAScript
                )
            )
        with _ ->
            ValueNone

    let Regex_fromStringWith
        (options: Regex_Options)
        (string: StringRope)
        : ValueOption<System.Text.RegularExpressions.Regex> =
        try
            ValueSome(
                System.Text.RegularExpressions.Regex(
                    StringRope.toString string,
                    if options.Multiline then
                        if options.CaseInsensitive then
                            System.Text.RegularExpressions.RegexOptions.ECMAScript
                            ||| System.Text.RegularExpressions.RegexOptions.Multiline
                            ||| System.Text.RegularExpressions.RegexOptions.IgnoreCase
                        else
                            System.Text.RegularExpressions.RegexOptions.ECMAScript
                            ||| System.Text.RegularExpressions.RegexOptions.Multiline

                    else if
                        // !options.Multiline
                        options.CaseInsensitive
                    then
                        System.Text.RegularExpressions.RegexOptions.ECMAScript
                        ||| System.Text.RegularExpressions.RegexOptions.Singleline
                        ||| System.Text.RegularExpressions.RegexOptions.IgnoreCase
                    else
                        System.Text.RegularExpressions.RegexOptions.ECMAScript
                        ||| System.Text.RegularExpressions.RegexOptions.Singleline
                )
            )
        with _ ->
            ValueNone

    let Regex_never: System.Text.RegularExpressions.Regex =
        System.Text.RegularExpressions.Regex("/.^/")

    let inline Regex_contains
        (regex: System.Text.RegularExpressions.Regex)
        (string: StringRope)
        : bool =
        regex.IsMatch(StringRope.toString string)

    let inline Regex_split
        (regex: System.Text.RegularExpressions.Regex)
        (string: StringRope)
        : List<StringRope> =
        // can be optimized
        Array.toList (
            Array.map StringRopeOne (regex.Split(StringRope.toString string))
        )

    let inline Regex_splitAtMost
        (maxSplitCount: int64)
        (regex: System.Text.RegularExpressions.Regex)
        (string: StringRope)
        : List<StringRope> =
        // can be optimized
        Array.toList (
            Array.map
                StringRopeOne
                (regex.Split(StringRope.toString string, int maxSplitCount))
        )

    let inline regexMatchToRegex_MatchAtIndex0Based
        (matchNumber0Based: int64)
        (regexMatch: System.Text.RegularExpressions.Match)
        : Regex_Match =
        { Match = StringRopeOne regexMatch.Value
          Index = regexMatch.Index
          Number = matchNumber0Based + 1L
          Submatches =
            Seq.toList (
                Seq.map
                    (fun (subMatch: System.Text.RegularExpressions.Group) ->
                        // TODO when does elm return ValueNone?
                        ValueSome(StringRopeOne subMatch.Value))
                    regexMatch.Groups
            ) }

    let inline Regex_find
        (regex: System.Text.RegularExpressions.Regex)
        (string: StringRope)
        : List<Regex_Match> =
        Seq.toList (
            Seq.mapi
                (fun index regexMatch ->
                    regexMatchToRegex_MatchAtIndex0Based index regexMatch)
                (regex.Matches(StringRope.toString string))
        )

    let inline Regex_findAtMost
        (maxMatchCount: int64)
        (regex: System.Text.RegularExpressions.Regex)
        (string: StringRope)
        : List<Regex_Match> =
        Seq.toList (
            Seq.mapi
                (fun index regexMatch ->
                    regexMatchToRegex_MatchAtIndex0Based index regexMatch)
                (regex.Matches(StringRope.toString string, int maxMatchCount))
        )

    let inline createRegexMatchNumber0BasedMap
        (regex: System.Text.RegularExpressions.Regex)
        (string: string)
        : Map<string, int64> =
        (Seq.fold
            (fun
                (soFar:
                    {| Index: int64
                       Map: Map<string, int64> |})
                (regexMatch: System.Text.RegularExpressions.Match) ->
                {| Index = soFar.Index + 1L
                   Map = Map.add regexMatch.Value soFar.Index soFar.Map |})
            {| Index = 0L; Map = Map.empty |}
            (regex.Matches(string)))
            .Map

    let Regex_replace
        (regex: System.Text.RegularExpressions.Regex)
        (replacementForMatch: Regex_Match -> StringRope)
        (stringRope: StringRope)
        : StringRope =
        let string = StringRope.toString stringRope

        let matchNumbers0Based: Map<string, int64> =
            createRegexMatchNumber0BasedMap regex string

        StringRopeOne(
            regex.Replace(
                string,
                System.Text.RegularExpressions.MatchEvaluator(fun regexMatch ->
                    StringRope.toString (
                        replacementForMatch (
                            regexMatchToRegex_MatchAtIndex0Based
                                (Map.find regexMatch.Value matchNumbers0Based)
                                regexMatch
                        )
                    ))
            )
        )

    let Regex_replaceAtMost
        (maxMatchReplacementCount: int64)
        (regex: System.Text.RegularExpressions.Regex)
        (replacementForMatch: Regex_Match -> StringRope)
        (stringRope: StringRope)
        : StringRope =
        let string = StringRope.toString stringRope

        let matchNumbers0Based: Map<string, int64> =
            createRegexMatchNumber0BasedMap regex string

        StringRopeOne(
            regex.Replace(
                string,
                System.Text.RegularExpressions.MatchEvaluator(fun regexMatch ->
                    StringRope.toString (
                        replacementForMatch (
                            regexMatchToRegex_MatchAtIndex0Based
                                (Map.find regexMatch.Value matchNumbers0Based)
                                regexMatch
                        )
                    )),
                int maxMatchReplacementCount
            )
        )


    let inline Debug_log (tag: StringRope) (value: 'value) : 'value =
        System.Diagnostics.Debug.Print(StringRope.toString tag + ": {0}", value)

        value

    let inline Debug_toString (value: 'value) : StringRope =
        StringRopeOne(value.ToString())

    let inline Debug_todo (message: string) : 'value =
        raise (new System.NotImplementedException(message))


    let ElmKernelParser_isSubString
        (smallStringRope: StringRope)
        (offsetOriginal: int64)
        (rowOriginal: int64)
        (colOriginal: int64)
        (bigStringRope: StringRope)
        : struct (int64 * int64 * int64) =
        let smallString = StringRope.toString smallStringRope
        let bigString = StringRope.toString bigStringRope
        let smallLength = String.length smallString
        let mutable row = int rowOriginal
        let mutable col = int colOriginal
        let mutable offset = int offsetOriginal
        let mutable isGood = int offset + smallLength <= String.length bigString
        let mutable i = 0

        while isGood && i < smallLength do
            let code = int (bigString[offset])
            isGood <- smallString[i] = bigString[offset]

            if code = 0x000A then // \\n
                i <- i + 1
                row <- row + 1
                col <- 1
            else
                col <- col + 1

                if (code &&& 0xF800) = 0xD800 then
                    isGood <- isGood && (smallString[i + 1] = bigString[offset + 1])
                    i <- i + 2
                    offset <- offset + 2
                else
                    i <- i + 1

        (struct ((if isGood then offset else -1), row, col))

    let ElmKernelParser_isSubChar
        (predicate: char -> bool)
        (offset: int64)
        (stringRope: StringRope)
        : int64 =
        let string = StringRope.toString stringRope

        if String.length string <= int offset then
            -1
        else if (int (string[int offset]) &&& 0xF800) = 0xD800 then
            (if predicate (char (string.Substring(int offset, 2))) then
                 offset + 2L
             else
                 -1L)
        else if predicate (string[int offset]) then
            (if (string[int offset] = '\\n') then -2L else offset + 1L)
        else
            -1

    let inline ElmKernelParser_isAsciiCode
        (code: int64)
        (offset: int64)
        (string: StringRope)
        : bool =
        int64 ((StringRope.toString string)[int offset]) = code

    let ElmKernelParser_chompBase10
        (offsetOriginal: int64)
        (stringRope: StringRope)
        : int64 =
        let string = StringRope.toString stringRope
        let mutable offset = int offsetOriginal
        let mutable foundNonBase10 = false

        while (offset < String.length string) && not foundNonBase10 do
            foundNonBase10 <- not (System.Char.IsAsciiDigit(string[offset]))
            offset <- offset + 1

        offset

    let ElmKernelParser_consumeBase
        (base_: int64)
        (offsetOriginal: int64)
        (stringRope: StringRope)
        : struct (int64 * int64) =
        let string = StringRope.toString stringRope
        let mutable offset = int offsetOriginal
        let mutable total = 0
        let mutable foundNonBase = false

        while (offset < String.length string) && not foundNonBase do
            let digit = int (string[offset]) - 0x30

            if (digit < 0 || base_ <= digit) then
                foundNonBase <- true
            else
                total <- int base_ * total + digit
                offset <- offset + 1

        (struct (offset, total))

    let ElmKernelParser_consumeBase16
        (offsetOriginal: int64)
        (stringRope: StringRope)
        : struct (int64 * int64) =
        let string = StringRope.toString stringRope
        let mutable offset = int offsetOriginal
        let mutable total = 0
        let mutable foundNonBase16 = false

        while (offset < String.length string) && not foundNonBase16 do
            let code = int (string[offset])

            if (0x30 <= code && code <= 0x39) then
                total <- 16 * total + code - 0x30
            else if (0x41 <= code && code <= 0x46) then
                total <- 16 * total + code - 55
            else if (0x61 <= code && code <= 0x66) then
                total <- 16 * total + code - 87
            else
                foundNonBase16 <- true

        (struct (offset, total))

    let ElmKernelParser_findSubString
        (smallStringRope: StringRope)
        (offsetOriginal: int64)
        (rowOriginal: int64)
        (colOriginal: int64)
        (bigStringRope: StringRope)
        : struct (int64 * int64 * int64) =
        let smallString = StringRope.toString smallStringRope
        let bigString = StringRope.toString bigStringRope
        let newOffset = bigString.IndexOf(smallString, int offsetOriginal)

        let target =
            if newOffset < 0 then
                String.length bigString
            else
                newOffset + String.length smallString

        let mutable row = int rowOriginal
        let mutable col = int colOriginal
        let mutable offset = int offsetOriginal

        while (offset < target) do
            let code = int (bigString[offset])
            offset <- offset + 1

            if code = 0x000A then // \\n
                col <- 1
                row <- row + 1
            else
                col <- col + 1

                if (code &&& 0xF800) = 0xD800 then
                    offset <- offset + 1

        (struct (newOffset, row, col))

    let inline ElmKernelUrl_percentEncode (string: StringRope) : StringRope =
        StringRopeOne(System.Net.WebUtility.UrlEncode(StringRope.toString string))

    let inline ElmKernelUrl_percentDecode
        (string: StringRope)
        : ValueOption<StringRope> =
        match System.Net.WebUtility.UrlDecode(StringRope.toString string) with
        | null -> ValueNone
        | decodedString -> ValueSome(StringRopeOne decodedString)


    [<Struct>]
    type Random_Seed =
        | Random_Seed of
            Random_Seed:
                // can be optimized by switching to int32
                (struct (int64 * int64))

    type Random_Generator<'a> = Random_Seed -> (struct ('a * Random_Seed))

    let Random_step (generator: Random_Generator<'a>) (seed: Random_Seed) =
        generator seed

    let Random_peel (Random_Seed(state, _): Random_Seed) =
        let word: int64 =
            (*)
                ((^^^)
                    state
                    (Bitwise_shiftRightZfBy
                        ((+) (Bitwise_shiftRightZfBy 28L state) 4L)
                        state))
                277803737L

        Bitwise_shiftRightZfBy 0L ((^^^) (Bitwise_shiftRightZfBy 22L word) word)

    let Random_next (Random_Seed(state0, incr): Random_Seed) =
        Random_Seed(
            struct (Bitwise_shiftRightZfBy 0L ((+) ((*) state0 1664525L) incr), incr)
        )

    let Random_minInt: int64 = -2147483648L

    let Random_maxInt: int64 = 2147483647L

    let Random_map5
        (func: 'a -> 'b -> 'c -> 'd -> 'e -> 'f)
        (genA: Random_Generator<'a>)
        (genB: Random_Generator<'b>)
        (genC: Random_Generator<'c>)
        (genD: Random_Generator<'d>)
        (genE: Random_Generator<'e>)
        =
        fun (seed0: Random_Seed) ->
            let ((struct (a, seed1)): (struct ('a * Random_Seed))) = genA seed0

            let ((struct (b, seed2)): (struct ('b * Random_Seed))) = genB seed1

            let ((struct (c, seed3)): (struct ('c * Random_Seed))) = genC seed2

            let ((struct (d, seed4)): (struct ('d * Random_Seed))) = genD seed3

            let ((struct (e, seed5)): (struct ('e * Random_Seed))) = genE seed4

            (struct (func a b c d e, seed5))

    let Random_map4
        (func: 'a -> 'b -> 'c -> 'd -> 'e)
        (genA: Random_Generator<'a>)
        (genB: Random_Generator<'b>)
        (genC: Random_Generator<'c>)
        (genD: Random_Generator<'d>)
        =
        fun (seed0: Random_Seed) ->
            let ((struct (a, seed1)): (struct ('a * Random_Seed))) = genA seed0

            let ((struct (b, seed2)): (struct ('b * Random_Seed))) = genB seed1

            let ((struct (c, seed3)): (struct ('c * Random_Seed))) = genC seed2

            let ((struct (d, seed4)): (struct ('d * Random_Seed))) = genD seed3

            (struct (func a b c d, seed4))

    let Random_map3
        (func: 'a -> 'b -> 'c -> 'd)
        (genA: Random_Generator<'a>)
        (genB: Random_Generator<'b>)
        (genC: Random_Generator<'c>)
        =
        fun (seed0: Random_Seed) ->
            let ((struct (a, seed1)): (struct ('a * Random_Seed))) = genA seed0

            let ((struct (b, seed2)): (struct ('b * Random_Seed))) = genB seed1

            let ((struct (c, seed3)): (struct ('c * Random_Seed))) = genC seed2

            (struct (func a b c, seed3))

    let Random_map2
        (func: 'a -> 'b -> 'c)
        (genA: Random_Generator<'a>)
        (genB: Random_Generator<'b>)
        =
        fun (seed0: Random_Seed) ->
            let ((struct (a, seed1)): (struct ('a * Random_Seed))) = genA seed0

            let ((struct (b, seed2)): (struct ('b * Random_Seed))) = genB seed1

            (struct (func a b, seed2))

    let Random_pair (genA: Random_Generator<'a>) (genB: Random_Generator<'b>) =
        Random_map2 (fun (a: 'a) (b: 'b) -> (struct (a, b))) genA genB

    let Random_map (func: 'a -> 'b) (genA: Random_Generator<'a>) =
        fun (seed0: Random_Seed) ->
            let ((struct (a, seed1)): (struct ('a * Random_Seed))) = genA seed0

            (struct (func a, seed1))

    let rec Random_listHelp
        (revList: List<'a>)
        (n: int64)
        (gen: Random_Seed -> (struct ('a * Random_Seed)))
        (seed: Random_Seed)
        =
        if (<) n 1L then
            (struct (revList, seed))

        else
            let ((struct (value, newSeed)): (struct ('a * Random_Seed))) = gen seed

            Random_listHelp (List_cons value revList) ((-) n 1L) gen newSeed

    let Random_list (n: int64) (gen: Random_Generator<'a>) =
        fun (seed: Random_Seed) -> Random_listHelp [] n gen seed

    let Random_lazy (callback: unit -> Random_Generator<'a>) =
        fun (seed: Random_Seed) ->
            let (gen: Random_Generator<'a>) = callback ()

            gen seed

    let Random_int (a: int64) (b: int64) =
        fun (seed0: Random_Seed) ->
            let ((struct (lo, hi)): (struct (int64 * int64))) =
                if (<) a b then
                    (struct (a, b))

                else
                    (struct (b, a))

            let range: int64 = (+) ((-) hi lo) 1L

            if Basics_eq ((&&&) ((-) range 1L) range) 0L then
                (struct ((+)
                             (Bitwise_shiftRightZfBy
                                 0L
                                 ((&&&) ((-) range 1L) (Random_peel seed0)))
                             lo,
                         Random_next seed0))

            else
                let threshold: int64 =
                    Bitwise_shiftRightZfBy
                        0L
                        (Basics_remainderBy
                            range
                            (Bitwise_shiftRightZfBy 0L (Basics_inegate range)))

                let rec accountForBias (seed: Random_Seed) =
                    let x: int64 = Random_peel seed

                    let seedN: Random_Seed = Random_next seed

                    if (<) x threshold then
                        accountForBias seedN

                    else
                        (struct ((+) (Basics_remainderBy range x) lo, seedN))

                accountForBias seed0

    let Random_initialSeed (x: int64) =
        let (Random_Seed(state1, incr): Random_Seed) =
            Random_next(Random_Seed(struct (0L, 1013904223L)))

        let state2: int64 = Bitwise_shiftRightZfBy 0L ((+) state1 x)

        Random_next(Random_Seed(struct (state2, incr)))

    let Random_independentSeed: Random_Generator<Random_Seed> =
        fun (seed0: Random_Seed) ->
            let makeIndependentSeed (state: int64) (b: int64) (c: int64) =
                Random_next(
                    Random_Seed(
                        struct (state,
                                Bitwise_shiftRightZfBy 0L ((|||) 1L ((^^^) b c)))
                    )
                )

            let gen: Random_Generator<int64> = Random_int 0L 4294967295L

            Random_step (Random_map3 makeIndependentSeed gen gen gen) seed0

    let rec Random_getByWeight
        ((struct (weight, value)): (struct (float * 'a)))
        (others: List<(struct (float * 'a))>)
        (countdown: float)
        =
        match others with
        | [] -> value

        | second :: otherOthers ->
            if (<=) countdown (Basics_fabs weight) then
                value

            else
                Random_getByWeight
                    second
                    otherOthers
                    ((-) countdown (Basics_fabs weight))

    let Random_float (a: float) (b: float) =
        fun (seed0: Random_Seed) ->
            let seed1: Random_Seed = Random_next seed0

            let range: float = Basics_fabs((-) b a)

            let n1: int64 = Random_peel seed1

            let n0: int64 = Random_peel seed0

            let lo: float = (*) (float ((&&&) 134217727L n1)) 1.0

            let hi: float = (*) (float ((&&&) 67108863L n0)) 1.0

            let val_: float = (/) ((+) ((*) hi 134217728.0) lo) 9007199254740992.0

            let scaled: float = (+) ((*) val_ range) a

            (struct (scaled, Random_next seed1))

    let Random_weighted
        (first: (struct (float * 'a)))
        (others: List<(struct (float * 'a))>)
        =
        let normalize ((struct (weight, _)): (struct (float * 'ignored))) =
            Basics_fabs weight

        let total: float =
            (+) (normalize first) (List.sum (List.map normalize others))

        Random_map (Random_getByWeight first others) (Random_float 0.0 total)

    let inline Random_constant (value: 'a) : Random_Generator<'a> =
        fun (seed: Random_Seed) -> (struct (value, seed))

    let Random_andThen
        (callback: 'a -> Random_Generator<'b>)
        (genA: Random_Generator<'a>)
        =
        fun (seed: Random_Seed) ->
            let ((struct (result, newSeed)): (struct ('a * Random_Seed))) =
                genA seed

            let (genB: Random_Generator<'b>) = callback result

            genB newSeed

    let Random_addOne (value: 'a) = (struct (1.0, value))

    let Random_uniform (value: 'a) (valueList: List<'a>) =
        Random_weighted (struct (1.0, value)) (List.map Random_addOne valueList)


    [<Struct>]
    type Time_Posix = Time_Posix of int64

    [<Struct>]
    type Time_Era = { Start: int64; Offset: int64 }

    [<Struct>]
    type Time_Zone = Time_Zone of (struct (int64 * List<Time_Era>))

    [<Struct>]
    type Time_Weekday =
        | Time_Mon
        | Time_Tue
        | Time_Wed
        | Time_Thu
        | Time_Fri
        | Time_Sat
        | Time_Sun

    [<Struct>]
    type Time_Month =
        | Time_Jan
        | Time_Feb
        | Time_Mar
        | Time_Apr
        | Time_May
        | Time_Jun
        | Time_Jul
        | Time_Aug
        | Time_Sep
        | Time_Oct
        | Time_Nov
        | Time_Dec

    [<Struct>]
    type Time_ZoneName =
        | Time_Name of Time_Name: StringRope
        | Time_Offset of Time_Offset: int64

    [<Struct>]
    type Time_Civil =
        { Year: int64
          Month: int64
          Day: int64 }

    let inline Time_posixToMillis ((Time_Posix millis): Time_Posix) : int64 = millis
    let inline Time_millisToPosix (millis: int64) : Time_Posix = Time_Posix millis

    let Time_utc: Time_Zone = Time_Zone(struct (0L, []))

    let Time_customZone (n: int64) (eras: List<Time_Era>) : Time_Zone =
        Time_Zone(struct (n, eras))

    let inline flooredDiv (numerator: int64) (denominator: int64) : int64 =
        int64 (floor (float numerator / float denominator))

    let rec Time_toAdjustedMinutesHelp
        (defaultOffset: int64)
        (posixMinutes: int64)
        (eras: List<Time_Era>)
        : int64 =
        match eras with
        | [] -> posixMinutes + defaultOffset

        | era :: olderEras ->
            if era.Start < posixMinutes then
                posixMinutes + era.Offset
            else
                Time_toAdjustedMinutesHelp defaultOffset posixMinutes olderEras

    let Time_toAdjustedMinutes
        ((Time_Zone(struct (defaultOffset, eras))): Time_Zone)
        (time: Time_Posix)
        =
        Time_toAdjustedMinutesHelp
            defaultOffset
            (flooredDiv (Time_posixToMillis time) 60000)
            eras

    let Time_toCivil (minutes: int64) : Time_Civil =
        let rawDay = flooredDiv minutes (60L * 24L) + 719468L
        let era = (if rawDay >= 0 then rawDay else rawDay - 146096L) / 146097L
        let dayOfEra = rawDay - era * 146097L // [0, 146096]

        let yearOfEra =
            (dayOfEra - dayOfEra / 1460L + dayOfEra / 36524L - dayOfEra / 146096L)
            / 365L // [0, 399]

        let year = yearOfEra + era * 400L

        let dayOfYear =
            dayOfEra - (365L * yearOfEra + yearOfEra / 4L - yearOfEra / 100L) // [0, 365]

        let mp = (5L * dayOfYear + 2L) / 153L // [0, 11]
        let month = mp + (if mp < 10 then 3L else -9L) // [1, 12]

        { Year = year + (if month <= 2 then 1L else 0L)
          Month = month
          Day = dayOfYear - (153L * mp + 2L) / 5L + 1L // [1, 31]
        }

    let Time_toYear (zone: Time_Zone) (time: Time_Posix) : int64 =
        (Time_toCivil(Time_toAdjustedMinutes zone time)).Year

    let Time_toMonth (zone: Time_Zone) (time: Time_Posix) : Time_Month =
        match (Time_toCivil(Time_toAdjustedMinutes zone time)).Month with
        | 1L -> Time_Jan
        | 2L -> Time_Feb
        | 3L -> Time_Mar
        | 4L -> Time_Apr
        | 5L -> Time_May
        | 6L -> Time_Jun
        | 7L -> Time_Jul
        | 8L -> Time_Aug
        | 9L -> Time_Sep
        | 10L -> Time_Oct
        | 11L -> Time_Nov
        | _ -> Time_Dec

    let Time_toDay (zone: Time_Zone) (time: Time_Posix) : int64 =
        (Time_toCivil(Time_toAdjustedMinutes zone time)).Day

    let Time_toWeekday (zone: Time_Zone) (time: Time_Posix) : Time_Weekday =
        match
            Basics_modBy
                7
                (flooredDiv (Time_toAdjustedMinutes zone time) (60L * 24L))
        with
        | 0L -> Time_Thu
        | 1L -> Time_Fri
        | 2L -> Time_Sat
        | 3L -> Time_Sun
        | 4L -> Time_Mon
        | 5L -> Time_Tue
        | _ -> Time_Wed

    let Time_toHour zone time =
        Basics_modBy 24 (flooredDiv (Time_toAdjustedMinutes zone time) 60)

    let Time_toMinute (zone: Time_Zone) (time: Time_Posix) : int64 =
        Basics_modBy 60 (Time_toAdjustedMinutes zone time)

    let inline Time_toSecond (_: Time_Zone) (time: Time_Posix) : int64 =
        Basics_modBy 60 (flooredDiv (Time_posixToMillis time) 1000)

    let inline Time_toMillis (_: Time_Zone) (time: Time_Posix) : int64 =
        Basics_modBy 1000 (Time_posixToMillis time)


    type Bytes_Bytes = array<byte>

    [<Struct>]
    type Bytes_Endianness =
        | Bytes_LE
        | Bytes_BE

    type BytesEncode_Encoder =
        | BytesEncode_I8 of int64
        | BytesEncode_I16 of (struct (Bytes_Endianness * int64))
        | BytesEncode_I32 of (struct (Bytes_Endianness * int64))
        | BytesEncode_U8 of int64
        | BytesEncode_U16 of (struct (Bytes_Endianness * int64))
        | BytesEncode_U32 of (struct (Bytes_Endianness * int64))
        | BytesEncode_F32 of (struct (Bytes_Endianness * float))
        | BytesEncode_F64 of (struct (Bytes_Endianness * float))
        | BytesEncode_Seq of (struct (int * List<BytesEncode_Encoder>))
        | BytesEncode_Utf8 of (struct (int * StringRope))
        | BytesEncode_Bytes of Bytes_Bytes

    let Bytes_width (bytes: Bytes_Bytes) : int64 = Array.length bytes


    let BytesEncode_getStringWidth (string: StringRope) : int64 =
        System.Text.Encoding.UTF8.GetByteCount(StringRope.toString string)

    let BytesEncode_signedInt8 (i8: int64) : BytesEncode_Encoder = BytesEncode_I8 i8

    let BytesEncode_signedInt16
        (endianness: Bytes_Endianness)
        (i16: int64)
        : BytesEncode_Encoder =
        BytesEncode_I16(endianness, i16)

    let BytesEncode_signedInt32
        (endianness: Bytes_Endianness)
        (i32: int64)
        : BytesEncode_Encoder =
        BytesEncode_I32(endianness, i32)

    let BytesEncode_unsignedInt8 (u8: int64) : BytesEncode_Encoder =
        BytesEncode_U8 u8

    let BytesEncode_unsignedInt16
        (endianness: Bytes_Endianness)
        (u16: int64)
        : BytesEncode_Encoder =
        BytesEncode_U16(endianness, u16)

    let BytesEncode_unsignedInt32
        (endianness: Bytes_Endianness)
        (u32: int64)
        : BytesEncode_Encoder =
        BytesEncode_U32(endianness, u32)

    let BytesEncode_float32
        (endianness: Bytes_Endianness)
        (f32: float)
        : BytesEncode_Encoder =
        BytesEncode_F32(endianness, f32)

    let BytesEncode_float64
        (endianness: Bytes_Endianness)
        (f64: float)
        : BytesEncode_Encoder =
        BytesEncode_F64(endianness, f64)

    let BytesEncode_bytes (bytes: Bytes_Bytes) : BytesEncode_Encoder =
        BytesEncode_Bytes bytes

    let BytesEncode_string (string: StringRope) : BytesEncode_Encoder =
        BytesEncode_Utf8(
            System.Text.Encoding.UTF8.GetByteCount(StringRope.toString string),
            string
        )

    let BytesEncode_EncoderByteCount (encoder: BytesEncode_Encoder) : int32 =
        match encoder with
        | BytesEncode_I8(_) -> 1
        | BytesEncode_I16(_) -> 2
        | BytesEncode_I32(_) -> 4
        | BytesEncode_U8(_) -> 1
        | BytesEncode_U16(_) -> 2
        | BytesEncode_U32(_) -> 4
        | BytesEncode_F32(_) -> 4
        | BytesEncode_F64(_) -> 8
        | BytesEncode_Seq(w, _) -> w
        | BytesEncode_Utf8(w, _) -> w
        | BytesEncode_Bytes bytes -> Array.length bytes

    let BytesEncode_sequence
        (encoders: List<BytesEncode_Encoder>)
        : BytesEncode_Encoder =
        BytesEncode_Seq(
            Seq.sum (Seq.map BytesEncode_EncoderByteCount encoders),
            encoders
        )

    let convertedBytesAdaptEndianness
        (endianness: Bytes_Endianness)
        (asLeBytes: Bytes_Bytes)
        : array<byte> =
        // can be optimized to use specialized endian operations
        // https://learn.microsoft.com/en-us/dotnet/api/system.buffers.binary.binaryprimitives?view=net-9.0
        if (endianness = Bytes_LE) <> System.BitConverter.IsLittleEndian then
            System.Array.Reverse(asLeBytes)

        asLeBytes

    let BytesEncode_encode (encoder: BytesEncode_Encoder) : Bytes_Bytes =
        let mutableBuffer =
            new System.IO.MemoryStream(BytesEncode_EncoderByteCount encoder)

        let mutable toEncodeNext = encoder

        let mutable mutableRemainingRightEncoders =
            System.Collections.Generic.Stack<BytesEncode_Encoder>()

        let mutable shouldKeepGoing = true

        while shouldKeepGoing do
            match toEncodeNext with
            | BytesEncode_I8(i8) ->
                mutableBuffer.WriteByte(byte (sbyte i8))

                if mutableRemainingRightEncoders.Count = 0 then
                    shouldKeepGoing <- false
                else
                    toEncodeNext <- mutableRemainingRightEncoders.Pop()
            | BytesEncode_I16(endianness, i16) ->
                mutableBuffer.Write(
                    convertedBytesAdaptEndianness
                        endianness
                        (System.BitConverter.GetBytes(int16 i16))
                )

                if mutableRemainingRightEncoders.Count = 0 then
                    shouldKeepGoing <- false
                else
                    toEncodeNext <- mutableRemainingRightEncoders.Pop()
            | BytesEncode_I32(endianness, i32) ->
                mutableBuffer.Write(
                    convertedBytesAdaptEndianness
                        endianness
                        (System.BitConverter.GetBytes(int32 i32))
                )

                if mutableRemainingRightEncoders.Count = 0 then
                    shouldKeepGoing <- false
                else
                    toEncodeNext <- mutableRemainingRightEncoders.Pop()
            | BytesEncode_U8(u8) ->
                mutableBuffer.WriteByte(byte u8)

                if mutableRemainingRightEncoders.Count = 0 then
                    shouldKeepGoing <- false
                else
                    toEncodeNext <- mutableRemainingRightEncoders.Pop()
            | BytesEncode_U16(endianness, u16) ->
                mutableBuffer.Write(
                    convertedBytesAdaptEndianness
                        endianness
                        (System.BitConverter.GetBytes(uint16 u16))
                )

                if mutableRemainingRightEncoders.Count = 0 then
                    shouldKeepGoing <- false
                else
                    toEncodeNext <- mutableRemainingRightEncoders.Pop()
            | BytesEncode_U32(endianness, u32) ->
                mutableBuffer.Write(
                    convertedBytesAdaptEndianness
                        endianness
                        (System.BitConverter.GetBytes(uint32 u32))
                )

                if mutableRemainingRightEncoders.Count = 0 then
                    shouldKeepGoing <- false
                else
                    toEncodeNext <- mutableRemainingRightEncoders.Pop()
            | BytesEncode_F32(endianness, f32) ->
                mutableBuffer.Write(
                    convertedBytesAdaptEndianness
                        endianness
                        (System.BitConverter.GetBytes(float32 f32))
                )

                if mutableRemainingRightEncoders.Count = 0 then
                    shouldKeepGoing <- false
                else
                    toEncodeNext <- mutableRemainingRightEncoders.Pop()
            | BytesEncode_F64(endianness, f64) ->
                mutableBuffer.Write(
                    convertedBytesAdaptEndianness
                        endianness
                        (System.BitConverter.GetBytes(f64))
                )

                if mutableRemainingRightEncoders.Count = 0 then
                    shouldKeepGoing <- false
                else
                    toEncodeNext <- mutableRemainingRightEncoders.Pop()
            | BytesEncode_Utf8(byteLength, stringRope) ->
                mutableBuffer.Write(
                    new System.ReadOnlySpan<byte>(
                        System.Text.Encoding.UTF8.GetBytes(
                            StringRope.toString stringRope
                        )
                    )
                )

                if mutableRemainingRightEncoders.Count = 0 then
                    shouldKeepGoing <- false
                else
                    toEncodeNext <- mutableRemainingRightEncoders.Pop()
            | BytesEncode_Bytes(byteArray) ->
                mutableBuffer.Write(new System.ReadOnlySpan<byte>(byteArray))

                if mutableRemainingRightEncoders.Count = 0 then
                    shouldKeepGoing <- false
                else
                    toEncodeNext <- mutableRemainingRightEncoders.Pop()
            | BytesEncode_Seq(byteLength, encoders) ->
                match encoders with
                | [] ->
                    if mutableRemainingRightEncoders.Count = 0 then
                        shouldKeepGoing <- false
                    else
                        toEncodeNext <- mutableRemainingRightEncoders.Pop()
                | nextSubEncoder :: subEncodersAfterNextSubEncoder ->
                    toEncodeNext <- nextSubEncoder
                    // can probably be optimized
                    Seq.iter
                        (fun subEncoderAfterNextSubEncoder ->
                            mutableRemainingRightEncoders.Push(
                                subEncoderAfterNextSubEncoder
                            ))
                        (Seq.rev subEncodersAfterNextSubEncoder)

        mutableBuffer.ToArray()


    type BytesDecode_Decoder<'value> =
        Bytes_Bytes -> int32 -> ValueOption<struct (int32 * 'value)>

    [<Struct>]
    type BytesDecode_Step<'state, 'a> =
        | BytesDecode_Loop of BytesDecode_Loop: 'state
        | BytesDecode_Done of BytesDecode_Done: 'a

    let BytesDecode_decode
        (decoder: BytesDecode_Decoder<'value>)
        (bytes: Bytes_Bytes)
        : ValueOption<'value> =
        match decoder bytes 0 with
        | ValueNone -> ValueNone
        | ValueSome(_, value) -> ValueSome value

    let BytesDecode_succeed (value: 'value) : BytesDecode_Decoder<'value> =
        fun bytes index -> ValueSome(index, value)

    let BytesDecode_fail: BytesDecode_Decoder<'value> = fun bytes index -> ValueNone

    let BytesDecode_andThen
        (valueToFollowingDecoder: 'value -> BytesDecode_Decoder<'mappedValue>)
        (decoder: BytesDecode_Decoder<'value>)
        : BytesDecode_Decoder<'mappedValue> =
        fun bytes index ->
            match decoder bytes index with
            | ValueNone -> ValueNone
            | ValueSome(indexAfter, value) ->
                valueToFollowingDecoder value bytes indexAfter

    let BytesDecode_map
        (valueChange: 'value -> 'mappedValue)
        (decoder: BytesDecode_Decoder<'value>)
        : BytesDecode_Decoder<'mappedValue> =
        fun bytes index ->
            match decoder bytes index with
            | ValueNone -> ValueNone
            | ValueSome(indexAfter, value) ->
                ValueSome(indexAfter, valueChange value)

    let rec BytesDecode_loop
        (initialState: 'state)
        (step: 'state -> BytesDecode_Decoder<BytesDecode_Step<'state, 'a>>)
        : BytesDecode_Decoder<'a> =
        fun bytes index ->
            match step initialState bytes index with
            | ValueNone -> ValueNone
            | ValueSome(indexAfterStep, stepValue) ->
                match stepValue with
                | BytesDecode_Loop(newState) ->
                    BytesDecode_loop newState step bytes indexAfterStep

                | BytesDecode_Done(result) -> ValueSome(indexAfterStep, result)

    let BytesDecode_map2
        (valuesCombine: 'a -> 'b -> 'combined)
        (aDecoder: BytesDecode_Decoder<'a>)
        (bDecoder: BytesDecode_Decoder<'b>)
        : BytesDecode_Decoder<'combined> =
        fun bytes index ->
            match aDecoder bytes index with
            | ValueNone -> ValueNone
            | ValueSome(indexAfterA, a) ->
                match bDecoder bytes indexAfterA with
                | ValueNone -> ValueNone
                | ValueSome(indexAfterB, b) ->
                    ValueSome(indexAfterB, valuesCombine a b)

    let BytesDecode_map3
        (valuesCombine: 'a -> 'b -> 'c -> 'combined)
        (aDecoder: BytesDecode_Decoder<'a>)
        (bDecoder: BytesDecode_Decoder<'b>)
        (cDecoder: BytesDecode_Decoder<'c>)
        : BytesDecode_Decoder<'combined> =
        fun bytes index ->
            match aDecoder bytes index with
            | ValueNone -> ValueNone
            | ValueSome(indexAfterA, a) ->
                match bDecoder bytes indexAfterA with
                | ValueNone -> ValueNone
                | ValueSome(indexAfterB, b) ->
                    match cDecoder bytes indexAfterA with
                    | ValueNone -> ValueNone
                    | ValueSome(indexAfterC, c) ->
                        ValueSome(indexAfterC, valuesCombine a b c)

    let BytesDecode_map4
        (valuesCombine: 'a -> 'b -> 'c -> 'd -> 'combined)
        (aDecoder: BytesDecode_Decoder<'a>)
        (bDecoder: BytesDecode_Decoder<'b>)
        (cDecoder: BytesDecode_Decoder<'c>)
        (dDecoder: BytesDecode_Decoder<'d>)
        : BytesDecode_Decoder<'combined> =
        fun bytes index ->
            match aDecoder bytes index with
            | ValueNone -> ValueNone
            | ValueSome(indexAfterA, a) ->
                match bDecoder bytes indexAfterA with
                | ValueNone -> ValueNone
                | ValueSome(indexAfterB, b) ->
                    match cDecoder bytes indexAfterA with
                    | ValueNone -> ValueNone
                    | ValueSome(indexAfterC, c) ->
                        match dDecoder bytes indexAfterA with
                        | ValueNone -> ValueNone
                        | ValueSome(indexAfterD, d) ->
                            ValueSome(indexAfterD, valuesCombine a b c d)

    let BytesDecode_map5
        (valuesCombine: 'a -> 'b -> 'c -> 'd -> 'e -> 'combined)
        (aDecoder: BytesDecode_Decoder<'a>)
        (bDecoder: BytesDecode_Decoder<'b>)
        (cDecoder: BytesDecode_Decoder<'c>)
        (dDecoder: BytesDecode_Decoder<'d>)
        (eDecoder: BytesDecode_Decoder<'e>)
        : BytesDecode_Decoder<'combined> =
        fun bytes index ->
            match aDecoder bytes index with
            | ValueNone -> ValueNone
            | ValueSome(indexAfterA, a) ->
                match bDecoder bytes indexAfterA with
                | ValueNone -> ValueNone
                | ValueSome(indexAfterB, b) ->
                    match cDecoder bytes indexAfterA with
                    | ValueNone -> ValueNone
                    | ValueSome(indexAfterC, c) ->
                        match dDecoder bytes indexAfterA with
                        | ValueNone -> ValueNone
                        | ValueSome(indexAfterD, d) ->
                            match eDecoder bytes indexAfterA with
                            | ValueNone -> ValueNone
                            | ValueSome(indexAfterE, e) ->
                                ValueSome(indexAfterE, valuesCombine a b c d e)

    let BytesDecode_signedInt8: BytesDecode_Decoder<int64> =
        fun bytes index ->
            let indexAfter = index + 1

            if indexAfter >= Array.length bytes then
                ValueNone
            else
                ValueSome(indexAfter, int64 (sbyte (bytes[index])))

    let BytesDecode_signedInt16
        (endianness: Bytes_Endianness)
        : BytesDecode_Decoder<int64> =
        fun bytes index ->
            let indexAfter = index + 2

            if indexAfter >= Array.length bytes then
                ValueNone
            else
                ValueSome(
                    indexAfter,
                    int64 (
                        match endianness with
                        | Bytes_LE ->
                            System
                                .Buffers
                                .Binary
                                .BinaryPrimitives
                                .ReadInt16LittleEndian(bytes[index..indexAfter])
                        | Bytes_BE ->
                            System
                                .Buffers
                                .Binary
                                .BinaryPrimitives
                                .ReadInt16BigEndian(bytes[index..indexAfter])
                    )
                )

    let BytesDecode_signedInt32
        (endianness: Bytes_Endianness)
        : BytesDecode_Decoder<int64> =
        fun bytes index ->
            let indexAfter = index + 4

            if indexAfter >= Array.length bytes then
                ValueNone
            else
                ValueSome(
                    indexAfter,
                    int64 (
                        match endianness with
                        | Bytes_LE ->
                            System
                                .Buffers
                                .Binary
                                .BinaryPrimitives
                                .ReadInt32LittleEndian(bytes[index..indexAfter])
                        | Bytes_BE ->
                            System
                                .Buffers
                                .Binary
                                .BinaryPrimitives
                                .ReadInt32BigEndian(bytes[index..indexAfter])
                    )
                )

    let BytesDecode_unsignedInt8: BytesDecode_Decoder<int64> =
        fun bytes index ->
            let indexAfter = index + 1

            if indexAfter >= Array.length bytes then
                ValueNone
            else
                ValueSome(indexAfter, int64 (bytes[index]))

    let BytesDecode_unsignedInt16
        (endianness: Bytes_Endianness)
        : BytesDecode_Decoder<int64> =
        fun bytes index ->
            let indexAfter = index + 2

            if indexAfter >= Array.length bytes then
                ValueNone
            else
                ValueSome(
                    indexAfter,
                    int64 (
                        match endianness with
                        | Bytes_LE ->
                            System
                                .Buffers
                                .Binary
                                .BinaryPrimitives
                                .ReadUInt16LittleEndian(bytes[index..indexAfter])
                        | Bytes_BE ->
                            System
                                .Buffers
                                .Binary
                                .BinaryPrimitives
                                .ReadUInt16BigEndian(bytes[index..indexAfter])
                    )
                )

    let BytesDecode_unsignedInt32
        (endianness: Bytes_Endianness)
        : BytesDecode_Decoder<int64> =
        fun bytes index ->
            let indexAfter = index + 4

            if indexAfter >= Array.length bytes then
                ValueNone
            else
                ValueSome(
                    indexAfter,
                    int64 (
                        match endianness with
                        | Bytes_LE ->
                            System
                                .Buffers
                                .Binary
                                .BinaryPrimitives
                                .ReadUInt32LittleEndian(bytes[index..indexAfter])
                        | Bytes_BE ->
                            System
                                .Buffers
                                .Binary
                                .BinaryPrimitives
                                .ReadUInt32BigEndian(bytes[index..indexAfter])
                    )
                )

    let BytesDecode_float32
        (endianness: Bytes_Endianness)
        : BytesDecode_Decoder<float> =
        fun bytes index ->
            let indexAfter = index + 4

            if indexAfter >= Array.length bytes then
                ValueNone
            else
                ValueSome(
                    indexAfter,
                    float (
                        match endianness with
                        | Bytes_LE ->
                            System
                                .Buffers
                                .Binary
                                .BinaryPrimitives
                                .ReadSingleLittleEndian(bytes[index..indexAfter])
                        | Bytes_BE ->
                            System
                                .Buffers
                                .Binary
                                .BinaryPrimitives
                                .ReadSingleBigEndian(bytes[index..indexAfter])
                    )
                )

    let BytesDecode_float64
        (endianness: Bytes_Endianness)
        : BytesDecode_Decoder<float> =
        fun bytes index ->
            let indexAfter = index + 8

            if indexAfter >= Array.length bytes then
                ValueNone
            else
                ValueSome(
                    indexAfter,
                    match endianness with
                    | Bytes_LE ->
                        System
                            .Buffers
                            .Binary
                            .BinaryPrimitives
                            .ReadDoubleLittleEndian(bytes[index..indexAfter])
                    | Bytes_BE ->
                        System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian(
                            bytes[index..indexAfter]
                        )
                )

    let BytesDecode_bytes
        (byteCountToRead: int64)
        : BytesDecode_Decoder<Bytes_Bytes> =
        fun bytes index ->
            let indexAfter = index + int byteCountToRead

            if indexAfter >= Array.length bytes then
                ValueNone
            else
                ValueSome(indexAfter, bytes[index..indexAfter])

    let BytesDecode_string
        (byteCountToRead: int64)
        : BytesDecode_Decoder<StringRope> =
        fun bytes index ->
            let indexAfter = index + 8

            if indexAfter >= Array.length bytes then
                ValueNone
            else
                ValueSome(
                    indexAfter,
                    StringRopeOne(
                        System.Text.Encoding.UTF8.GetString(
                            bytes,
                            index,
                            int byteCountToRead
                        )
                    )
                )


    let VirtualDom_RE_js: System.Text.RegularExpressions.Regex =
        System.Text.RegularExpressions.Regex(
            "/^\\s*j\\s*a\\s*v\\s*a\\s*s\\s*c\\s*r\\s*i\\s*p\\s*t\\s*:/i"
        )

    let VirtualDom_RE_js_html: System.Text.RegularExpressions.Regex =
        System.Text.RegularExpressions.Regex(
            "/^\\s*(j\\s*a\\s*v\\s*a\\s*s\\s*c\\s*r\\s*i\\s*p\\s*t\\s*:|d\\s*a\\s*t\\s*a\\s*:\\s*t\\s*e\\s*x\\s*t\\s*\\/\\s*h\\s*t\\s*m\\s*l\\s*(,|;))/i"
        )

    let VirtualDom_noJavaScriptUri (uri: StringRope) : StringRope =
        if VirtualDom_RE_js.IsMatch(StringRope.toString uri) then
            stringRopeEmpty
        else
            uri

    let VirtualDom_noJavaScriptOrHtmlUri (uri: StringRope) : StringRope =
        if VirtualDom_RE_js_html.IsMatch(StringRope.toString uri) then
            stringRopeEmpty
        else
            uri

    [<Struct>]
    type VirtualDom_ModifierAttribute =
        { Namespace: ValueOption<string>
          Key: string
          Value: string }

    [<Struct>]
    type VirtualDom_ModifierStyle = { Key: string; Value: string }

    [<Struct>]
    type VirtualDom_ModifierProperty =
        { Key: string
          Value: System.Text.Json.Nodes.JsonNode }

    [<Struct>]
    type Generated_Message_PreventDefault_StopPropagation<'message, 'preventDefault, 'stopPropagation>
        =
        { Message: 'message
          PreventDefault: 'preventDefault
          StopPropagation: 'stopPropagation }

    type VirtualDom_CustomHandledEvent<'event> =
        Generated_Message_PreventDefault_StopPropagation<'event, bool, bool>

    [<Struct>]
    type VirtualDom_Handler<'event> =
        | VirtualDom_Normal of VirtualDom_Normal: (JsonDecode_Decoder<'event>)
        | VirtualDom_MayStopPropagation of
            VirtualDom_MayStopPropagation:
                (JsonDecode_Decoder<struct ('event * bool)>)
        | VirtualDom_MayPreventDefault of
            VirtualDom_MayPreventDefault:
                (JsonDecode_Decoder<struct ('event * bool)>)
        | VirtualDom_Custom of
            VirtualDom_Custom:
                (JsonDecode_Decoder<VirtualDom_CustomHandledEvent<'event>>)

    let inline VirtualDom_customHandledEventMap
        (eventChange: 'event -> 'eventMapped)
        (handledEvent: VirtualDom_CustomHandledEvent<'event>)
        : VirtualDom_CustomHandledEvent<'eventMapped> =
        { Message = eventChange handledEvent.Message
          StopPropagation = handledEvent.StopPropagation
          PreventDefault = handledEvent.PreventDefault }

    let VirtualDom_handlerMap
        (eventChange: 'event -> 'eventMapped)
        (handler: VirtualDom_Handler<'event>)
        : VirtualDom_Handler<'eventMapped> =
        match handler with
        | VirtualDom_Normal decoder ->
            VirtualDom_Normal(JsonDecode_map eventChange decoder)
        | VirtualDom_MayStopPropagation decoder ->
            VirtualDom_MayStopPropagation(
                JsonDecode_map
                    (fun (struct (event, stopPropagation)) ->
                        struct (eventChange event, stopPropagation))
                    decoder
            )
        | VirtualDom_MayPreventDefault decoder ->
            VirtualDom_MayPreventDefault(
                JsonDecode_map
                    (fun (struct (event, preventDefault)) ->
                        struct (eventChange event, preventDefault))
                    decoder
            )
        | VirtualDom_Custom decoder ->
            VirtualDom_Custom(
                JsonDecode_map
                    (fun custom ->
                        VirtualDom_customHandledEventMap eventChange custom)
                    decoder
            )

    [<Struct>]
    type VirtualDom_ModifierEventListener<'event> =
        { Name: string
          Handler: VirtualDom_Handler<'event> }

    type VirtualDom_Attribute<'event> =
        | VirtualDom_ModifierAttribute of VirtualDom_ModifierAttribute
        | VirtualDom_ModifierStyle of VirtualDom_ModifierStyle
        | VirtualDom_ModifierProperty of VirtualDom_ModifierProperty
        | VirtualDom_ModifierEventListener of
            VirtualDom_ModifierEventListener<'event>

    [<Struct>]
    type VirtualDom_Element<'event> =
        { Tag: string
          Namespace: ValueOption<string>
          Subs: List<VirtualDom_Node<'event>>
          Modifiers: List<VirtualDom_Attribute<'event>> }

    and [<Struct>] VirtualDom_ElementKeyed<'event> =
        { Tag: string
          Namespace: ValueOption<string>
          Subs: List<VirtualDom_SubNodeKeyed<'event>>
          Modifiers: List<VirtualDom_Attribute<'event>> }

    and [<Struct>] VirtualDom_SubNodeKeyed<'event> =
        { Key: string
          Node: VirtualDom_Node<'event> }

    and [<Struct>] VirtualDom_NodeLazy<'event> =
        { Keys: array<obj>
          Construct: unit -> VirtualDom_Node<'event> }

    and VirtualDom_Node<'event> =
        | VirtualDom_Text of string
        | VirtualDom_Element of VirtualDom_Element<'event>
        | VirtualDom_ElementKeyed of VirtualDom_ElementKeyed<'event>
        | VirtualDom_NodeLazy of VirtualDom_NodeLazy<'event>

    let inline VirtualDom_text (string: StringRope) : VirtualDom_Node<'event> =
        VirtualDom_Text(StringRope.toString string)

    let inline VirtualDom_node
        (tag: StringRope)
        (modifiers: List<VirtualDom_Attribute<'event>>)
        (subs: List<VirtualDom_Node<'event>>)
        : VirtualDom_Node<'event> =
        VirtualDom_Element
            { Tag = StringRope.toString tag
              Namespace = ValueNone
              Modifiers = modifiers
              Subs = subs }

    let inline VirtualDom_nodeNS
        (namespace_: StringRope)
        (tag: StringRope)
        (modifiers: List<VirtualDom_Attribute<'event>>)
        (subs: List<VirtualDom_Node<'event>>)
        : VirtualDom_Node<'event> =
        VirtualDom_Element
            { Tag = StringRope.toString tag
              Namespace = ValueSome(StringRope.toString namespace_)
              Modifiers = modifiers
              Subs = subs }

    let inline VirtualDom_keyedNode
        (tag: StringRope)
        (modifiers: List<VirtualDom_Attribute<'event>>)
        (subs: List<struct (StringRope * VirtualDom_Node<'event>)>)
        : VirtualDom_Node<'event> =
        VirtualDom_ElementKeyed
            { Tag = StringRope.toString tag
              Namespace = ValueNone
              Modifiers = modifiers
              Subs =
                List.map
                    (fun (struct (key, node)) ->
                        { Key = StringRope.toString key
                          Node = node })
                    subs }

    let inline VirtualDom_keyedNodeNS
        (namespace_: StringRope)
        (tag: StringRope)
        (modifiers: List<VirtualDom_Attribute<'event>>)
        (subs: List<struct (StringRope * VirtualDom_Node<'event>)>)
        : VirtualDom_Node<'event> =
        VirtualDom_ElementKeyed
            { Tag = StringRope.toString tag
              Namespace = ValueSome(StringRope.toString namespace_)
              Modifiers = modifiers
              Subs =
                List.map
                    (fun (struct (key, node)) ->
                        { Key = StringRope.toString key
                          Node = node })
                    subs }

    let inline VirtualDom_style
        (key: StringRope)
        (value: StringRope)
        : VirtualDom_Attribute<'event> =
        VirtualDom_ModifierStyle
            { Key = StringRope.toString key
              Value = StringRope.toString value }

    let inline VirtualDom_property
        (key: StringRope)
        (value: System.Text.Json.Nodes.JsonNode)
        : VirtualDom_Attribute<'event> =
        VirtualDom_ModifierProperty
            { Key = StringRope.toString key
              Value = value }

    let inline VirtualDom_attribute
        (key: StringRope)
        (value: StringRope)
        : VirtualDom_Attribute<'event> =
        VirtualDom_ModifierAttribute
            { Namespace = ValueNone
              Key = StringRope.toString key
              Value = StringRope.toString value }

    let inline VirtualDom_attributeNS
        (namespace_: StringRope)
        (key: StringRope)
        (value: StringRope)
        : VirtualDom_Attribute<'event> =
        VirtualDom_ModifierAttribute
            { Namespace = ValueSome(StringRope.toString namespace_)
              Key = StringRope.toString key
              Value = StringRope.toString value }

    let inline VirtualDom_on
        (name: StringRope)
        (handler: VirtualDom_Handler<'event>)
        : VirtualDom_Attribute<'event> =
        VirtualDom_ModifierEventListener
            { Name = StringRope.toString name
              Handler = handler }

    let VirtualDom_mapAttribute
        (eventChange: 'event -> 'eventMapped)
        (modifier: VirtualDom_Attribute<'event>)
        : VirtualDom_Attribute<'eventMapped> =
        match modifier with
        | VirtualDom_ModifierAttribute virtualDomAttribute ->
            VirtualDom_ModifierAttribute virtualDomAttribute
        | VirtualDom_ModifierStyle virtualDomStyle ->
            VirtualDom_ModifierStyle virtualDomStyle
        | VirtualDom_ModifierProperty virtualDomProperty ->
            VirtualDom_ModifierProperty virtualDomProperty
        | VirtualDom_ModifierEventListener virtualDomEventListener ->
            VirtualDom_ModifierEventListener
                { Name = virtualDomEventListener.Name
                  Handler =
                    VirtualDom_handlerMap
                        eventChange
                        virtualDomEventListener.Handler }

    let rec VirtualDom_elementMap
        (eventChange: 'event -> 'eventMapped)
        (element: VirtualDom_Element<'event>)
        : VirtualDom_Element<'eventMapped> =
        { Tag = element.Tag
          Namespace = element.Namespace
          Subs = List.map (fun sub -> VirtualDom_map eventChange sub) element.Subs
          Modifiers =
            List.map
                (fun modifier -> VirtualDom_mapAttribute eventChange modifier)
                element.Modifiers }

    and VirtualDom_elementKeyedMap
        (eventChange: 'event -> 'eventMapped)
        (element: VirtualDom_ElementKeyed<'event>)
        : VirtualDom_ElementKeyed<'eventMapped> =
        { Tag = element.Tag
          Namespace = element.Namespace
          Subs =
            List.map
                (fun subKeyed ->
                    { Key = subKeyed.Key
                      Node = VirtualDom_map eventChange subKeyed.Node })
                element.Subs
          Modifiers =
            List.map
                (fun modifier -> VirtualDom_mapAttribute eventChange modifier)
                element.Modifiers }

    and VirtualDom_NodeLazyMap
        (eventChange: 'event -> 'eventMapped)
        (nodeLazy: VirtualDom_NodeLazy<'event>)
        : VirtualDom_NodeLazy<'eventMapped> =
        { Keys = nodeLazy.Keys
          Construct = fun () -> VirtualDom_map eventChange (nodeLazy.Construct()) }

    and VirtualDom_map
        (eventChange: 'event -> 'eventMapped)
        (node: VirtualDom_Node<'event>)
        : VirtualDom_Node<'eventMapped> =
        match node with
        | VirtualDom_Text text -> VirtualDom_Text text
        | VirtualDom_Element element ->
            VirtualDom_Element(VirtualDom_elementMap eventChange element)
        | VirtualDom_ElementKeyed element ->
            VirtualDom_ElementKeyed(VirtualDom_elementKeyedMap eventChange element)
        | VirtualDom_NodeLazy nodeLazy ->
            VirtualDom_NodeLazy(VirtualDom_NodeLazyMap eventChange nodeLazy)

    let inline VirtualDom_lazy
        (construct: 'a -> VirtualDom_Node<'event>)
        (a: 'a)
        : VirtualDom_Node<'event> =
        VirtualDom_NodeLazy
            { Keys = [| a |]
              Construct = fun () -> construct a }

    let inline VirtualDom_lazy2
        (construct: 'a -> 'b -> VirtualDom_Node<'event>)
        (a: 'a)
        (b: 'b)
        : VirtualDom_Node<'event> =
        VirtualDom_NodeLazy
            { Keys = [| a; b |]
              Construct = fun () -> construct a b }

    let inline VirtualDom_lazy3
        (construct: 'a -> 'b -> 'c -> VirtualDom_Node<'event>)
        (a: 'a)
        (b: 'b)
        (c: 'c)
        : VirtualDom_Node<'event> =
        VirtualDom_NodeLazy
            { Keys = [| a; b; c |]
              Construct = fun () -> construct a b c }

    let inline VirtualDom_lazy4
        (construct: 'a -> 'b -> 'c -> 'd -> VirtualDom_Node<'event>)
        (a: 'a)
        (b: 'b)
        (c: 'c)
        (d: 'd)
        : VirtualDom_Node<'event> =
        VirtualDom_NodeLazy
            { Keys = [| a; b; c; d |]
              Construct = fun () -> construct a b c d }

    let inline VirtualDom_lazy5
        (construct: 'a -> 'b -> 'c -> 'd -> 'e -> VirtualDom_Node<'event>)
        (a: 'a)
        (b: 'b)
        (c: 'c)
        (d: 'd)
        (e: 'e)
        : VirtualDom_Node<'event> =
        VirtualDom_NodeLazy
            { Keys = [| a; b; c; d; e |]
              Construct = fun () -> construct a b c d e }

    let inline VirtualDom_lazy6
        (construct: 'a -> 'b -> 'c -> 'd -> 'e -> 'f -> VirtualDom_Node<'event>)
        (a: 'a)
        (b: 'b)
        (c: 'c)
        (d: 'd)
        (e: 'e)
        (f: 'f)
        : VirtualDom_Node<'event> =
        VirtualDom_NodeLazy
            { Keys = [| a; b; c; d; e; f |]
              Construct = fun () -> construct a b c d e f }

    let inline VirtualDom_lazy7
        (construct:
            'a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g -> VirtualDom_Node<'event>)
        (a: 'a)
        (b: 'b)
        (c: 'c)
        (d: 'd)
        (e: 'e)
        (f: 'f)
        (g: 'g)
        : VirtualDom_Node<'event> =
        VirtualDom_NodeLazy
            { Keys = [| a; b; c; d; e; f; g |]
              Construct = fun () -> construct a b c d e f g }

    let inline VirtualDom_lazy8
        (construct:
            'a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g -> 'h -> VirtualDom_Node<'event>)
        (a: 'a)
        (b: 'b)
        (c: 'c)
        (d: 'd)
        (e: 'e)
        (f: 'f)
        (g: 'g)
        (h: 'h)
        : VirtualDom_Node<'event> =
        VirtualDom_NodeLazy
            { Keys = [| a; b; c; d; e; f; g; h |]
              Construct = fun () -> construct a b c d e f g h }


    let inline MathVector2_vec2 (x: float) (y: float) : System.Numerics.Vector2 =
        System.Numerics.Vector2(float32 x, float32 y)

    let inline MathVector2_getX (vector2: System.Numerics.Vector2) : float =
        float vector2.X

    let inline MathVector2_getY (vector2: System.Numerics.Vector2) : float =
        float vector2.Y

    let inline MathVector2_setX
        (newX: float)
        (vector2: System.Numerics.Vector2)
        : System.Numerics.Vector2 =
        System.Numerics.Vector2(float32 newX, vector2.Y)

    let inline MathVector2_setY
        (newY: float)
        (vector2: System.Numerics.Vector2)
        : System.Numerics.Vector2 =
        System.Numerics.Vector2(vector2.X, float32 newY)

    let inline MathVector2_add
        (a: System.Numerics.Vector2)
        (b: System.Numerics.Vector2)
        : System.Numerics.Vector2 =
        System.Numerics.Vector2.Add(a, b)

    let inline MathVector2_sub
        (baseVector2: System.Numerics.Vector2)
        (toSubtract: System.Numerics.Vector2)
        : System.Numerics.Vector2 =
        System.Numerics.Vector2.Subtract(baseVector2, toSubtract)

    let inline MathVector2_negate
        (vector2: System.Numerics.Vector2)
        : System.Numerics.Vector2 =
        System.Numerics.Vector2.Negate(vector2)

    let inline MathVector2_scale
        (factor: float)
        (vector2: System.Numerics.Vector2)
        : System.Numerics.Vector2 =
        System.Numerics.Vector2.Multiply(vector2, float32 factor)

    let inline MathVector2_dot
        (a: System.Numerics.Vector2)
        (b: System.Numerics.Vector2)
        : float =
        float (System.Numerics.Vector2.Dot(a, b))

    let inline MathVector2_normalize
        (vector2: System.Numerics.Vector2)
        : System.Numerics.Vector2 =
        System.Numerics.Vector2.Normalize(vector2)

    let inline MathVector2_direction
        (a: System.Numerics.Vector2)
        (b: System.Numerics.Vector2)
        : System.Numerics.Vector2 =
        System.Numerics.Vector2.Normalize(System.Numerics.Vector2.Subtract(a, b))

    let inline MathVector2_length (vector2: System.Numerics.Vector2) : float =
        float (vector2.Length())

    let inline MathVector2_lengthSquared
        (vector2: System.Numerics.Vector2)
        : float =
        float (vector2.LengthSquared())

    let inline MathVector2_distance
        (a: System.Numerics.Vector2)
        (b: System.Numerics.Vector2)
        : float =
        float (System.Numerics.Vector2.Distance(a, b))

    let inline MathVector2_distanceSquared
        (a: System.Numerics.Vector2)
        (b: System.Numerics.Vector2)
        : float =
        float (System.Numerics.Vector2.DistanceSquared(a, b))

    [<Struct>]
    type MathVector2_AsRecord = { X: float; Y: float }

    let inline MathVector2_toRecord
        (vector2: System.Numerics.Vector2)
        : MathVector2_AsRecord =
        { X = float vector2.X
          Y = float vector2.Y }

    let inline MathVector2_fromRecord
        (asRecord: MathVector2_AsRecord)
        : System.Numerics.Vector2 =
        System.Numerics.Vector2(float32 asRecord.X, float32 asRecord.Y)



    let MathVector3_vec3
        (x: float)
        (y: float)
        (z: float)
        : System.Numerics.Vector3 =
        System.Numerics.Vector3(float32 x, float32 y, float32 z)

    let MathVector3_i: System.Numerics.Vector3 =
        System.Numerics.Vector3(1f, 0f, 0f)

    let MathVector3_j: System.Numerics.Vector3 =
        System.Numerics.Vector3(0f, 1f, 0f)

    let MathVector3_k: System.Numerics.Vector3 =
        System.Numerics.Vector3(0f, 0f, 1f)

    let MathVector3_getX (vector3: System.Numerics.Vector3) : float =
        float vector3.X

    let MathVector3_getY (vector3: System.Numerics.Vector3) : float =
        float vector3.Y

    let MathVector3_getZ (vector3: System.Numerics.Vector3) : float =
        float vector3.Z

    let MathVector3_setX
        (newX: float)
        (vector3: System.Numerics.Vector3)
        : System.Numerics.Vector3 =
        System.Numerics.Vector3(float32 newX, vector3.Y, vector3.Z)

    let MathVector3_setY
        (newY: float)
        (vector3: System.Numerics.Vector3)
        : System.Numerics.Vector3 =
        System.Numerics.Vector3(vector3.X, float32 newY, vector3.Z)

    let MathVector3_setZ
        (newZ: float)
        (vector3: System.Numerics.Vector3)
        : System.Numerics.Vector3 =
        System.Numerics.Vector3(vector3.X, vector3.Y, float32 newZ)

    let MathVector3_add
        (a: System.Numerics.Vector3)
        (b: System.Numerics.Vector3)
        : System.Numerics.Vector3 =
        System.Numerics.Vector3.Add(a, b)

    let MathVector3_sub
        (baseVector3: System.Numerics.Vector3)
        (toSubtract: System.Numerics.Vector3)
        : System.Numerics.Vector3 =
        System.Numerics.Vector3.Subtract(baseVector3, toSubtract)

    let MathVector3_negate
        (vector3: System.Numerics.Vector3)
        : System.Numerics.Vector3 =
        System.Numerics.Vector3.Negate(vector3)

    let MathVector3_scale
        (factor: float)
        (vector3: System.Numerics.Vector3)
        : System.Numerics.Vector3 =
        System.Numerics.Vector3.Multiply(vector3, float32 factor)

    let MathVector3_dot
        (a: System.Numerics.Vector3)
        (b: System.Numerics.Vector3)
        : float =
        float (System.Numerics.Vector3.Dot(a, b))

    let MathVector3_cross
        (a: System.Numerics.Vector3)
        (b: System.Numerics.Vector3)
        : System.Numerics.Vector3 =
        System.Numerics.Vector3.Cross(a, b)

    let MathVector3_normalize
        (vector3: System.Numerics.Vector3)
        : System.Numerics.Vector3 =
        System.Numerics.Vector3.Normalize(vector3)

    let MathVector3_direction
        (a: System.Numerics.Vector3)
        (b: System.Numerics.Vector3)
        : System.Numerics.Vector3 =
        System.Numerics.Vector3.Normalize(System.Numerics.Vector3.Subtract(a, b))

    let MathVector3_length (vector3: System.Numerics.Vector3) : float =
        float (vector3.Length())

    let MathVector3_lengthSquared (vector3: System.Numerics.Vector3) : float =
        float (vector3.LengthSquared())

    let MathVector3_distance
        (a: System.Numerics.Vector3)
        (b: System.Numerics.Vector3)
        : float =
        float (System.Numerics.Vector3.Distance(a, b))

    let MathVector3_distanceSquared
        (a: System.Numerics.Vector3)
        (b: System.Numerics.Vector3)
        : float =
        float (System.Numerics.Vector3.DistanceSquared(a, b))

    [<Struct>]
    type MathVector3_AsRecord = { X: float; Y: float; Z: float }

    let inline MathVector3_toRecord
        (vector3: System.Numerics.Vector3)
        : MathVector3_AsRecord =
        { X = float vector3.X
          Y = float vector3.Y
          Z = float vector3.Z }

    let inline MathVector3_fromRecord
        (asRecord: MathVector3_AsRecord)
        : System.Numerics.Vector3 =
        System.Numerics.Vector3(
            float32 asRecord.X,
            float32 asRecord.Y,
            float32 asRecord.Z
        )



    let inline MathVector4_vec4
        (x: float)
        (y: float)
        (z: float)
        (w: float)
        : System.Numerics.Vector4 =
        System.Numerics.Vector4(float32 x, float32 y, float32 z, float32 w)

    let inline MathVector4_getX (vector4: System.Numerics.Vector4) : float =
        float vector4.X

    let inline MathVector4_getY (vector4: System.Numerics.Vector4) : float =
        float vector4.Y

    let inline MathVector4_getZ (vector4: System.Numerics.Vector4) : float =
        float vector4.Z

    let inline MathVector4_getW (vector4: System.Numerics.Vector4) : float =
        float vector4.W

    let inline MathVector4_setX
        (newX: float)
        (vector4: System.Numerics.Vector4)
        : System.Numerics.Vector4 =
        System.Numerics.Vector4(
            float32 newX,
            vector4.Y,
            vector4.Z,
            vector4.W
        )

    let inline MathVector4_setY
        (newY: float)
        (vector4: System.Numerics.Vector4)
        : System.Numerics.Vector4 =
        System.Numerics.Vector4(
            vector4.X,
            float32 newY,
            vector4.Z,
            vector4.W
        )

    let inline MathVector4_setZ
        (newZ: float)
        (vector4: System.Numerics.Vector4)
        : System.Numerics.Vector4 =
        System.Numerics.Vector4(
            vector4.X,
            vector4.Y,
            float32 newZ,
            vector4.W
        )

    let inline MathVector4_setW
        (newW: float)
        (vector4: System.Numerics.Vector4)
        : System.Numerics.Vector4 =
        System.Numerics.Vector4(
            vector4.X,
            vector4.Y,
            vector4.Z,
            float32 newW
        )

    let inline MathVector4_add
        (a: System.Numerics.Vector4)
        (b: System.Numerics.Vector4)
        : System.Numerics.Vector4 =
        System.Numerics.Vector4.Add(a, b)

    let inline MathVector4_sub
        (baseVector4: System.Numerics.Vector4)
        (toSubtract: System.Numerics.Vector4)
        : System.Numerics.Vector4 =
        System.Numerics.Vector4.Subtract(baseVector4, toSubtract)

    let inline MathVector4_negate
        (vector4: System.Numerics.Vector4)
        : System.Numerics.Vector4 =
        System.Numerics.Vector4.Negate(vector4)

    let inline MathVector4_scale
        (factor: float)
        (vector4: System.Numerics.Vector4)
        : System.Numerics.Vector4 =
        System.Numerics.Vector4.Multiply(vector4, float32 factor)

    let inline MathVector4_dot
        (a: System.Numerics.Vector4)
        (b: System.Numerics.Vector4)
        : float =
        float (System.Numerics.Vector4.Dot(a, b))

    let inline MathVector4_normalize
        (vector4: System.Numerics.Vector4)
        : System.Numerics.Vector4 =
        System.Numerics.Vector4.Normalize(vector4)

    let inline MathVector4_direction
        (a: System.Numerics.Vector4)
        (b: System.Numerics.Vector4)
        : System.Numerics.Vector4 =
        System.Numerics.Vector4.Normalize(System.Numerics.Vector4.Subtract(a, b))

    let inline MathVector4_length (vector4: System.Numerics.Vector4) : float =
        float (vector4.Length())

    let inline MathVector4_lengthSquared
        (vector4: System.Numerics.Vector4)
        : float =
        float (vector4.LengthSquared())

    let inline MathVector4_distance
        (a: System.Numerics.Vector4)
        (b: System.Numerics.Vector4)
        : float =
        float (System.Numerics.Vector4.Distance(a, b))

    let inline MathVector4_distanceSquared
        (a: System.Numerics.Vector4)
        (b: System.Numerics.Vector4)
        : float =
        float (System.Numerics.Vector4.DistanceSquared(a, b))

    [<Struct>]
    type MathVector4_AsRecord =
        { X: float
          Y: float
          Z: float
          W: float }

    let inline MathVector4_toRecord
        (vector4: System.Numerics.Vector4)
        : MathVector4_AsRecord =
        { X = float vector4.X
          Y = float vector4.Y
          Z = float vector4.Z
          W = float vector4.W }

    let inline MathVector4_fromRecord
        (asRecord: MathVector4_AsRecord)
        : System.Numerics.Vector4 =
        System.Numerics.Vector4(
            float32 asRecord.X,
            float32 asRecord.Y,
            float32 asRecord.Z,
            float32 asRecord.W
        )



    let MathMatrix4_identity: System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.Identity

    let MathMatrix4_inverse
        (matrix4: System.Numerics.Matrix4x4)
        : ValueOption<System.Numerics.Matrix4x4> =
        let (wasSuccessful, result) = System.Numerics.Matrix4x4.Invert(matrix4)
        if wasSuccessful then ValueSome(result) else ValueNone

    let inline MathMatrix4_mul
        (a: System.Numerics.Matrix4x4)
        (b: System.Numerics.Matrix4x4)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.Multiply(a, b)

    let inline MathMatrix4_transpose
        (matrix4: System.Numerics.Matrix4x4)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.Transpose(matrix4)

    let inline MathMatrix4_makeBasis
        (vx: System.Numerics.Vector3)
        (vy: System.Numerics.Vector3)
        (vz: System.Numerics.Vector3)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4(
            vx.X,
            vx.Y,
            vx.Z,
            0f,
            vy.X,
            vy.Y,
            vy.Z,
            0f,
            vz.X,
            vz.Y,
            vz.Z,
            0f,
            0f,
            0f,
            0f,
            1f
        )

    let inline MathMatrix4_transform
        (matrix4: System.Numerics.Matrix4x4)
        (position: System.Numerics.Vector3)
        : System.Numerics.Vector3 =
        System.Numerics.Vector3.Transform(position, matrix4)

    let MathMatrix4_makeFrustum
        (left: float)
        (right: float)
        (bottom: float)
        (top: float)
        (zNearPlane: float)
        (zFarPlane: float)
        : System.Numerics.Matrix4x4 =
        let left32 = float32 left
        let right32 = float32 right
        let bottom32 = float32 bottom
        let top32 = float32 top
        let zNearPlane32 = float32 zNearPlane
        let zFarPlane32 = float32 zFarPlane

        System.Numerics.Matrix4x4(
            2f * zNearPlane32 / (right32 - left32),
            0f,
            0f,
            0f,
            0f,
            2f * zNearPlane32 / (top32 - bottom32),
            0f,
            0f,
            (right32 + left32) / (right32 - left32),
            (top32 + bottom32) / (top32 - bottom32),
            -(zFarPlane32 + zNearPlane32) / (zFarPlane32 - zNearPlane32),
            -1f,
            0f,
            0f,
            -2f * zFarPlane32 * zNearPlane32 / (zFarPlane32 - zNearPlane32),
            0f
        )

    let inline MathMatrix4_makePerspective
        (fieldOfView: float)
        (aspectRatio: float)
        (nearPlaneDistance: float)
        (farPlaneDistance: float)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.CreatePerspectiveFieldOfView(
            float32 fieldOfView,
            float32 aspectRatio,
            float32 nearPlaneDistance,
            float32 farPlaneDistance
        )

    let inline MathMatrix4_makeOrtho
        (left: float)
        (right: float)
        (bottom: float)
        (top: float)
        (zNearPlane: float)
        (zFarPlane: float)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.CreateOrthographicOffCenter(
            float32 left,
            float32 right,
            float32 bottom,
            float32 top,
            float32 zNearPlane,
            float32 zFarPlane
        )

    let inline MathMatrix4_makeOrtho2D
        (left: float)
        (right: float)
        (bottom: float)
        (top: float)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.CreateOrthographicOffCenter(
            float32 left,
            float32 right,
            float32 bottom,
            float32 top,
            -1f,
            1f
        )

    let inline MathMatrix4_makeLookAt
        (cameraPosition: System.Numerics.Vector3)
        (cameraTarget: System.Numerics.Vector3)
        (cameraUpVector: System.Numerics.Vector3)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.CreateLookAt(
            cameraPosition,
            cameraTarget,
            cameraUpVector
        )

    let inline MathMatrix4_rotate
        (angle: float)
        (axis: System.Numerics.Vector3)
        (matrix4: System.Numerics.Matrix4x4)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.Multiply(
            matrix4,
            System.Numerics.Matrix4x4.CreateFromAxisAngle(axis, float32 angle)
        )

    let inline MathMatrix4_scale
        (scales: System.Numerics.Vector3)
        (matrix4: System.Numerics.Matrix4x4)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.Multiply(
            matrix4,
            System.Numerics.Matrix4x4.CreateScale(scales)
        )

    let inline MathMatrix4_scale3
        (xScale: float)
        (yScale: float)
        (zScale: float)
        (matrix4: System.Numerics.Matrix4x4)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.Multiply(
            matrix4,
            System.Numerics.Matrix4x4.CreateScale(
                float32 xScale,
                float32 yScale,
                float32 zScale
            )
        )

    let inline MathMatrix4_translate
        (position: System.Numerics.Vector3)
        (matrix4: System.Numerics.Matrix4x4)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.Multiply(
            matrix4,
            System.Numerics.Matrix4x4.CreateTranslation(position)
        )

    let inline MathMatrix4_translate3
        (xPosition: float)
        (yPosition: float)
        (zPosition: float)
        (matrix4: System.Numerics.Matrix4x4)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.Multiply(
            matrix4,
            System.Numerics.Matrix4x4.CreateTranslation(
                float32 xPosition,
                float32 yPosition,
                float32 zPosition
            )
        )

    let inline MathMatrix4_makeRotate
        (angle: float)
        (axis: System.Numerics.Vector3)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.CreateFromAxisAngle(axis, float32 angle)

    let inline MathMatrix4_makeScale
        (scales: System.Numerics.Vector3)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.CreateScale(scales)

    let inline MathMatrix4_makeScale3
        (xScale: float)
        (yScale: float)
        (zScale: float)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.CreateScale(
            float32 xScale,
            float32 yScale,
            float32 zScale
        )

    let inline MathMatrix4_makeTranslate
        (position: System.Numerics.Vector3)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.CreateTranslation(position)

    let inline MathMatrix4_makeTranslate3
        (xPosition: float)
        (yPosition: float)
        (zPosition: float)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4.CreateTranslation(
            float32 xPosition,
            float32 yPosition,
            float32 zPosition
        )

    [<Struct>]
    type MathMatrix4_AsRecord =
        { M11: float
          M21: float
          M31: float
          M41: float
          M12: float
          M22: float
          M32: float
          M42: float
          M13: float
          M23: float
          M33: float
          M43: float
          M14: float
          M24: float
          M34: float
          M44: float }

    let inline MathMatrix4_toRecord
        (matrix4: System.Numerics.Matrix4x4)
        : MathMatrix4_AsRecord =
        { M11 = float matrix4.M11
          M21 = float matrix4.M21
          M31 = float matrix4.M31
          M41 = float matrix4.M41
          M12 = float matrix4.M12
          M22 = float matrix4.M22
          M32 = float matrix4.M32
          M42 = float matrix4.M42
          M13 = float matrix4.M13
          M23 = float matrix4.M23
          M33 = float matrix4.M33
          M43 = float matrix4.M43
          M14 = float matrix4.M14
          M24 = float matrix4.M24
          M34 = float matrix4.M34
          M44 = float matrix4.M44 }

    let inline MathMatrix4_fromRecord
        (asRecord: MathMatrix4_AsRecord)
        : System.Numerics.Matrix4x4 =
        System.Numerics.Matrix4x4(
            float32 asRecord.M11,
            float32 asRecord.M12,
            float32 asRecord.M13,
            float32 asRecord.M14,
            float32 asRecord.M21,
            float32 asRecord.M22,
            float32 asRecord.M23,
            float32 asRecord.M24,
            float32 asRecord.M31,
            float32 asRecord.M32,
            float32 asRecord.M33,
            float32 asRecord.M34,
            float32 asRecord.M41,
            float32 asRecord.M42,
            float32 asRecord.M43,
            float32 asRecord.M44
        )


    [<Struct>]
    type PlatformCmd_PortOutgoing =
        { Name: string
          Value: System.Text.Json.Nodes.JsonNode }

    [<Struct>]
    type PlatformCmd_CmdSingle<'event> =
        | PlatformCmd_PortOutgoing of
            PlatformCmd_PortOutgoing: PlatformCmd_PortOutgoing

    type PlatformCmd_Cmd<'event> = List<PlatformCmd_CmdSingle<'event>>

    let PlatformCmd_none: PlatformCmd_Cmd<'event> = []

    let inline PlatformCmd_batch
        (subCommands: List<PlatformCmd_Cmd<'event>>)
        : PlatformCmd_Cmd<'event> =
        List.concat subCommands

    let PlatformCmd_singleMap
        (eventChange: 'event -> 'mappedEvent)
        (commandSingle: PlatformCmd_CmdSingle<'event>)
        : PlatformCmd_CmdSingle<'mappedEvent> =
        match commandSingle with
        | PlatformCmd_PortOutgoing(portOutgoing) ->
            PlatformCmd_PortOutgoing portOutgoing

    let inline PlatformCmd_map
        (eventChange: 'event -> 'mappedEvent)
        (command: PlatformCmd_Cmd<'event>)
        : PlatformCmd_Cmd<'mappedEvent> =
        List.map (fun single -> PlatformCmd_singleMap eventChange single) command

    let inline PlatformCmd_portOutgoingWithName
        (name: StringRope)
        (value: System.Text.Json.Nodes.JsonNode)
        : PlatformCmd_Cmd<'event> =
        [ PlatformCmd_PortOutgoing
              { Name = StringRope.toString name
                Value = value } ]

    [<Struct>]
    type PlatformSub_PortIncoming<'event> =
        { Name: string
          OnValue: System.Text.Json.Nodes.JsonNode -> 'event }

    [<Struct>]
    type PlatformSub_SubSingle<'event> =
        | PlatformSub_PortIncoming of
            PlatformSub_PortIncoming: PlatformSub_PortIncoming<'event>

    type PlatformSub_Sub<'event> = List<PlatformSub_SubSingle<'event>>

    let PlatformSub_none: PlatformSub_Sub<'event> = []

    let inline PlatformSub_batch
        (subSubscriptions: List<PlatformSub_Sub<'event>>)
        : PlatformSub_Sub<'event> =
        List.concat subSubscriptions

    let PlatformSub_singleMap
        (eventChange: 'event -> 'mappedEvent)
        (subscriptionSingle: PlatformSub_SubSingle<'event>)
        : PlatformSub_SubSingle<'mappedEvent> =
        match subscriptionSingle with
        | PlatformSub_PortIncoming(portIncoming) ->
            PlatformSub_PortIncoming
                { Name = portIncoming.Name
                  OnValue = fun value -> eventChange (portIncoming.OnValue value) }

    let inline PlatformSub_map
        (eventChange: 'event -> 'mappedEvent)
        (subscription: PlatformSub_Sub<'event>)
        : PlatformSub_Sub<'mappedEvent> =
        List.map
            (fun single -> PlatformSub_singleMap eventChange single)
            subscription

    let inline PlatformSub_portIncomingWithName
        (name: StringRope)
        (onValue: System.Text.Json.Nodes.JsonNode -> 'event)
        : PlatformSub_Sub<'event> =
        [ PlatformSub_PortIncoming
              { Name = StringRope.toString name
                OnValue = onValue } ]

    [<Struct>]
    type Platform_Program<'flags, 'state, 'event> =
        { Init: 'flags -> struct ('state * PlatformCmd_Cmd<'event>)
          Update: 'event -> 'state -> struct ('state * PlatformCmd_Cmd<'event>)
          Subscriptions: 'state -> PlatformSub_Sub<'event> }

    let inline Platform_worker
        (config: Platform_Program<'flags, 'state, 'event>)
        : Platform_Program<'flags, 'state, 'event> =
        config
"""


fastDictMapAndToList :
    (key -> value -> element)
    -> FastDict.Dict key value
    -> List element
fastDictMapAndToList keyValueToElement fastDict =
    fastDict
        |> FastDict.foldr
            (\key value soFar ->
                keyValueToElement key value
                    :: soFar
            )
            []


listMapAndCombineOk : (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOk elementToResult list =
    listMapAndCombineOkFrom [] elementToResult list


listMapAndCombineOkFrom : List ok -> (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOkFrom soFar elementToResult list =
    case list of
        [] ->
            Ok (soFar |> List.reverse)

        head :: tail ->
            case head |> elementToResult of
                Err headErr ->
                    Err headErr

                Ok headOk ->
                    listMapAndCombineOkFrom (headOk :: soFar)
                        elementToResult
                        tail


printLinebreakLinebreakIndented : Print.Print
printLinebreakLinebreakIndented =
    Print.linebreak
        |> Print.followedBy Print.linebreakIndented


printExactlyUnderscore : Print
printExactlyUnderscore =
    Print.exactly "_"


elmKernelParserTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelParserTypes =
    FastDict.singleton
        "Elm.Kernel.Parser"
        { signatures =
            FastDict.fromList
                [ ( "isSubString"
                  , inferredTypeFunction
                        [ typeString, typeInt, typeInt, typeInt, typeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = typeInt
                                , part1 = typeInt
                                , part2 = typeInt
                                }
                            )
                        )
                  )
                , ( "isSubChar"
                  , inferredTypeFunction
                        [ inferredTypeFunction [ typeChar ] typeBool, typeInt, typeString ]
                        typeInt
                  )
                , ( "isAsciiCode"
                  , inferredTypeFunction
                        [ typeInt, typeInt, typeString ]
                        typeBool
                  )
                , ( "chompBase10"
                  , inferredTypeFunction
                        [ typeInt, typeString ]
                        typeInt
                  )
                , ( "consumeBase"
                  , inferredTypeFunction [ typeInt, typeInt, typeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTuple
                                { part0 = typeInt
                                , part1 = typeInt
                                }
                            )
                        )
                  )
                , ( "consumeBase16"
                  , inferredTypeFunction
                        [ typeInt, typeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTuple
                                { part0 = typeInt
                                , part1 = typeInt
                                }
                            )
                        )
                  )
                , ( "findSubString"
                  , inferredTypeFunction
                        [ typeString, typeInt, typeInt, typeInt, typeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = typeInt
                                , part1 = typeInt
                                , part2 = typeInt
                                }
                            )
                        )
                  )
                ]
        , typeAliases = FastDict.empty
        , choiceTypes = FastDict.empty
        }


elmKernelUrlTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelUrlTypes =
    FastDict.singleton "Elm.Kernel.Url"
        { signatures =
            FastDict.fromList
                [ ( "percentEncode"
                  , inferredTypeFunction
                        [ typeString ]
                        typeString
                  )
                , ( "percentDecode"
                  , inferredTypeFunction
                        [ typeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Maybe"
                                , name = "Maybe"
                                , arguments = [ typeString ]
                                }
                            )
                        )
                  )
                , ( "findSubString"
                  , inferredTypeFunction
                        [ typeString, typeInt, typeInt, typeInt, typeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = typeInt
                                , part1 = typeInt
                                , part2 = typeInt
                                }
                            )
                        )
                  )
                ]
        , typeAliases = FastDict.empty
        , choiceTypes = FastDict.empty
        }


inferredTypeFunction :
    List ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeFunction inputs output =
    case inputs of
        [] ->
            output

        input :: remainingInputs ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeFunction
                    { input = input
                    , output =
                        inferredTypeFunction remainingInputs output
                    }
                )


typeBool : ElmSyntaxTypeInfer.Type
typeBool =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "Basics"
            , name = "Bool"
            , arguments = []
            }
        )


typeInt : ElmSyntaxTypeInfer.Type
typeInt =
    ElmSyntaxTypeInfer.TypeNotVariable typeNotVariableBasicsInt


typeNotVariableBasicsInt : ElmSyntaxTypeInfer.TypeNotVariable
typeNotVariableBasicsInt =
    ElmSyntaxTypeInfer.TypeConstruct
        { moduleOrigin = "Basics"
        , name = "Int"
        , arguments = []
        }


inferredTypeBasicsFloat : ElmSyntaxTypeInfer.Type
inferredTypeBasicsFloat =
    ElmSyntaxTypeInfer.TypeNotVariable typeNotVariableBasicsFloat


typeNotVariableBasicsFloat : ElmSyntaxTypeInfer.TypeNotVariable
typeNotVariableBasicsFloat =
    ElmSyntaxTypeInfer.TypeConstruct
        { moduleOrigin = "Basics", name = "Float", arguments = [] }


typeString : ElmSyntaxTypeInfer.Type
typeString =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "String"
            , name = "String"
            , arguments = []
            }
        )


typeChar : ElmSyntaxTypeInfer.Type
typeChar =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "Char"
            , name = "Char"
            , arguments = []
            }
        )


typeList : ElmSyntaxTypeInfer.Type -> ElmSyntaxTypeInfer.Type
typeList elementType =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin =
                "List"
            , name = "List"
            , arguments =
                [ elementType ]
            }
        )


elmRandomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmRandomTypes =
    FastDict.fromList
        [ ( "Random"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "constant"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "generate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Cmd"
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "independentSeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Random"
                                , name = "Generator"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Seed"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "initialSeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Seed"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    ElmSyntaxTypeInfer.TypeUnit
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "c"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "d"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "e"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "f"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Random"
                                                                                                        , name =
                                                                                                            "Generator"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Random"
                                                                                                        , name =
                                                                                                            "Generator"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maxInt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Int"
                                , arguments = []
                                }
                            )
                      )
                    , ( "minInt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Int"
                                , arguments = []
                                }
                            )
                      )
                    , ( "pair"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "step"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Seed"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Seed"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "uniform"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "weighted"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeTuple
                                            { part0 =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Generator"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Seed"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmBytesTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmBytesTypes =
    FastDict.fromList
        [ ( "Bytes"
          , { signatures =
                FastDict.fromList
                    [ ( "getHostEndianness"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "width"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Bytes"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Endianness"
                      , { parameters = []
                        , variants =
                            FastDict.fromList [ ( "LE", [] ), ( "BE", [] ) ]
                        }
                      )
                    ]
            }
          )
        , ( "Bytes.Decode"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bytes"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes"
                                                        , name = "Bytes"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "decode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes"
                                                        , name = "Bytes"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                }
                            )
                      )
                    , ( "float32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float64"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "loop"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "state"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "state"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Step"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "state"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "a"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "result"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Bytes.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Bytes.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "result"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "succeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Decoder"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Step"
                      , { parameters = [ "state", "a" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Loop"
                                  , [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "state"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                , ( "Done"
                                  , [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Bytes.Encode"
          , { signatures =
                FastDict.fromList
                    [ ( "bytes"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "encode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float64"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getStringWidth"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sequence"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Encoder"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmJsonTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmJsonTypes =
    FastDict.fromList
        [ ( "Json.Decode"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "array"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "at"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bool"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "decodeString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Error"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "decodeValue"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Error"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dict"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "errorToString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "field"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "index"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "keyValuePairs"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    ElmSyntaxTypeInfer.TypeUnit
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "value"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map6"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "value"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map7"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "value"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "g"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "value"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "value"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "g"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "Json.Decode"
                                                                                                                                            , name =
                                                                                                                                                "Decoder"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "h"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "Json.Decode"
                                                                                                                                            , name =
                                                                                                                                                "Decoder"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "value"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maybe"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "null"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nullable"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "oneOf"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "oneOrMore"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "succeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "value"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Value"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeConstruct
                                    { moduleOrigin = "Json.Encode"
                                    , name = "Value"
                                    , arguments = []
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes =
                FastDict.fromList
                    [ ( "Decoder"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Error"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Field"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "Index"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "OneOf"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Error"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "Failure"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Json.Encode"
          , { signatures =
                FastDict.fromList
                    [ ( "array"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bool"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dict"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "k"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "encode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "null"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Encode"
                                , name = "Value"
                                , arguments = []
                                }
                            )
                      )
                    , ( "object"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "set"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Value"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmKernelVirtualDomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelVirtualDomTypes =
    FastDict.fromList
        [ ( "Elm.Kernel.VirtualDom"
          , { signatures =
                FastDict.fromList
                    [ ( "noJavaScriptOrHtmlUri"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output = typeString
                                }
                            )
                      )
                    , ( "noJavaScriptUri"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output = typeString
                                }
                            )
                      )
                    , ( "attribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = typeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attributeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = typeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input = typeString
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "property"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "node"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                typeList
                                                    (ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "VirtualDom"
                                                            , name =
                                                                "Attribute"
                                                            , arguments =
                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                    { name =
                                                                        "msg"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                                ]
                                                            }
                                                        )
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            typeList
                                                                (ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "VirtualDom"
                                                                        , name =
                                                                            "Node"
                                                                        , arguments =
                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                { name =
                                                                                    "msg"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                            ]
                                                                        }
                                                                    )
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = typeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = typeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            typeList
                                                                (ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "VirtualDom"
                                                                        , name =
                                                                            "Attribute"
                                                                        , arguments =
                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                { name =
                                                                                    "msg"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                            ]
                                                                        }
                                                                    )
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        typeList
                                                                            (ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "VirtualDom"
                                                                                    , name =
                                                                                        "Node"
                                                                                    , arguments =
                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                            { name =
                                                                                                "msg"
                                                                                            , useRange =
                                                                                                Elm.Syntax.Range.empty
                                                                                            }
                                                                                        ]
                                                                                    }
                                                                                )
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.empty
            , choiceTypes = FastDict.empty
            }
          )
        ]


elmVirtualDomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmVirtualDomTypes =
    FastDict.fromList
        [ ( "VirtualDom"
          , { signatures =
                FastDict.fromList
                    [ ( "attribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attributeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keyedNode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeTuple
                                                                                { part0 =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "String"
                                                                                            , name =
                                                                                                "String"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , part1 =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keyedNodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Attribute"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeTuple
                                                                                            { part0 =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "String"
                                                                                                        , name =
                                                                                                            "String"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , part1 =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy6"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "VirtualDom"
                                                                                                                    , name =
                                                                                                                        "Node"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "msg"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "VirtualDom"
                                                                                                                    , name =
                                                                                                                        "Node"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "msg"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy7"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "VirtualDom"
                                                                                                                                , name =
                                                                                                                                    "Node"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "msg"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "VirtualDom"
                                                                                                                                , name =
                                                                                                                                    "Node"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "msg"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "VirtualDom"
                                                                                                                                            , name =
                                                                                                                                                "Node"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "msg"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "VirtualDom"
                                                                                                                                            , name =
                                                                                                                                                "Node"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "msg"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapAttribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "node"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Attribute"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "on"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Handler"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "property"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "style"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "text"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "VirtualDom"
                                            , name = "Node"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Attribute"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Handler"
                      , { parameters = [ "msg" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Normal"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "MayStopPropagation"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "MayPreventDefault"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "Custom"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeRecord
                                                        (FastDict.fromList
                                                            [ ( "message"
                                                              , ElmSyntaxTypeInfer.TypeVariable
                                                                    { name = "msg"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                              )
                                                            , ( "preventDefault"
                                                              , ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "Basics"
                                                                        , name =
                                                                            "Bool"
                                                                        , arguments =
                                                                            []
                                                                        }
                                                                    )
                                                              )
                                                            , ( "stopPropagation"
                                                              , ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "Basics"
                                                                        , name =
                                                                            "Bool"
                                                                        , arguments =
                                                                            []
                                                                        }
                                                                    )
                                                              )
                                                            ]
                                                        )
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    , ( "Node"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        ]


elmTimeTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmTimeTypes =
    FastDict.fromList
        [ ( "Time"
          , { signatures =
                FastDict.fromList
                    [ ( "customZone"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeRecord
                                                                    (FastDict.fromList
                                                                        [ ( "offset"
                                                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "Basics"
                                                                                    , name =
                                                                                        "Int"
                                                                                    , arguments =
                                                                                        []
                                                                                    }
                                                                                )
                                                                          )
                                                                        , ( "start"
                                                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "Basics"
                                                                                    , name =
                                                                                        "Int"
                                                                                    , arguments =
                                                                                        []
                                                                                    }
                                                                                )
                                                                          )
                                                                        ]
                                                                    )
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Zone"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "every"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Time"
                                                                    , name =
                                                                        "Posix"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Sub"
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZoneName"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "ZoneName"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "here"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "millisToPosix"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "now"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "posixToMillis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toDay"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toHour"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMillis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMinute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMonth"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Month"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toSecond"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toWeekday"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Weekday"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toYear"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "utc"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Time"
                                , name = "Zone"
                                , arguments = []
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Month"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Jan", [] )
                                , ( "Feb", [] )
                                , ( "Mar", [] )
                                , ( "Apr", [] )
                                , ( "May", [] )
                                , ( "Jun", [] )
                                , ( "Jul", [] )
                                , ( "Aug", [] )
                                , ( "Sep", [] )
                                , ( "Oct", [] )
                                , ( "Nov", [] )
                                , ( "Dec", [] )
                                ]
                        }
                      )
                    , ( "Posix"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Weekday"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Mon", [] )
                                , ( "Tue", [] )
                                , ( "Wed", [] )
                                , ( "Thu", [] )
                                , ( "Fri", [] )
                                , ( "Sat", [] )
                                , ( "Sun", [] )
                                ]
                        }
                      )
                    , ( "Zone"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "ZoneName"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Name"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "Offset"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        ]


elmExplorationsLinearAlgebraTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmExplorationsLinearAlgebraTypes =
    FastDict.fromList
        [ ( "Math.Matrix4"
          , { signatures =
                FastDict.fromList
                    [ ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "m11"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m12"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m13"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m14"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m21"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m22"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m23"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m24"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m31"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m32"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m33"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m34"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m41"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m42"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m43"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m44"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "identity"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Matrix4"
                                , name = "Mat4"
                                , arguments = []
                                }
                            )
                      )
                    , ( "inverse"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "inverseOrthonormal"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeBasis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeFrustum"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Basics"
                                                                                            , name =
                                                                                                "Float"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Basics"
                                                                                                        , name =
                                                                                                            "Float"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Math.Matrix4"
                                                                                                        , name =
                                                                                                            "Mat4"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeLookAt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeOrtho"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Basics"
                                                                                            , name =
                                                                                                "Float"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Basics"
                                                                                                        , name =
                                                                                                            "Float"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Math.Matrix4"
                                                                                                        , name =
                                                                                                            "Mat4"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeOrtho2D"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makePerspective"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeRotate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeScale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeScale3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeTranslate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeTranslate3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mul"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mulAffine"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "rotate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "m11"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m12"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m13"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m14"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m21"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m22"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m23"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m24"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m31"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m32"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m33"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m34"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m41"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m42"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m43"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m44"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "transform"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "translate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "translate3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "transpose"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Mat4"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector2"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec2"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector3"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cross"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "i"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "j"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "k"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec3"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector4"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "w"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getW"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setW"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "w"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Vector4"
                                                                                , name =
                                                                                    "Vec4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec4"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmRegexTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmRegexTypes =
    FastDict.fromList
        [ ( "Regex"
          , { signatures =
                FastDict.fromList
                    [ ( "contains"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "find"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Match"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "findAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Regex"
                                                                                , name =
                                                                                    "Match"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromStringWith"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Options"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Regex"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "never"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Regex"
                                , name = "Regex"
                                , arguments = []
                                }
                            )
                      )
                    , ( "replace"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Match"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "replaceAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Regex"
                                                                                , name =
                                                                                    "Match"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "split"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "splitAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Match"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeRecord
                                    (FastDict.fromList
                                        [ ( "index"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Int"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "match"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "String"
                                                    , name = "String"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "number"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Int"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "submatches"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "List"
                                                    , name = "List"
                                                    , arguments =
                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                { moduleOrigin =
                                                                    "Maybe"
                                                                , name =
                                                                    "Maybe"
                                                                , arguments =
                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                            { moduleOrigin =
                                                                                "String"
                                                                            , name =
                                                                                "String"
                                                                            , arguments =
                                                                                []
                                                                            }
                                                                        )
                                                                    ]
                                                                }
                                                            )
                                                        ]
                                                    }
                                                )
                                          )
                                        ]
                                    )
                                )
                        , recordFieldOrder =
                            Just [ "match", "index", "number", "submatches" ]
                        }
                      )
                    , ( "Options"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeRecord
                                    (FastDict.fromList
                                        [ ( "caseInsensitive"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Bool"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "multiline"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Bool"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        ]
                                    )
                                )
                        , recordFieldOrder =
                            Just [ "caseInsensitive", "multiline" ]
                        }
                      )
                    ]
            , choiceTypes =
                FastDict.fromList
                    [ ( "Regex"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]
